<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="리눅스 매뉴얼 페이지 일부 한글 번역">
    
    <link rel="canonical" href="https://wariua.github.io/man-pages-ko/FD_ISSET(3)/">
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>FD ISSET(3) - man-pages-ko</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/idea.min.css">
        
    
    <link href="../css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">man-pages-ko</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../section_file/">File</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_ipc/">IPC</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_memory/">Memory</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_network/">Network</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_process/">Process</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_thread/">Thread</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_trouble_shooting/">Trouble Shooting</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_others/">Others</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#name">NAME</a></li>
        <li class="first-level "><a href="#synopsis">SYNOPSIS</a></li>
        <li class="first-level "><a href="#description">DESCRIPTION</a></li>
            <li class="second-level"><a href="#_1">타임아웃</a></li>
                
        <li class="first-level "><a href="#return-value">RETURN VALUE</a></li>
        <li class="first-level "><a href="#errors">ERRORS</a></li>
        <li class="first-level "><a href="#versions">VERSIONS</a></li>
        <li class="first-level "><a href="#conforming-to">CONFORMING TO</a></li>
        <li class="first-level "><a href="#notes">NOTES</a></li>
            <li class="second-level"><a href="#select-poll">select()와 poll() 알림의 대응 관계</a></li>
                
            <li class="second-level"><a href="#_2">다중 스레드 응용</a></li>
                
            <li class="second-level"><a href="#c">C 라이브러리/커널 차이</a></li>
                
        <li class="first-level "><a href="#bugs">BUGS</a></li>
        <li class="first-level "><a href="#example">EXAMPLE</a></li>
        <li class="first-level "><a href="#see-also">SEE ALSO</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h2 id="name">NAME</h2>
<p>select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - 동기적 I/O 다중화</p>
<h2 id="synopsis">SYNOPSIS</h2>
<pre><code class="c">/* POSIX.1-2001, POSIX.1-2008에 따르면 */
#include &lt;sys/select.h&gt;

/* 이전 표준들에 따르면 */
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);

void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);

#include &lt;sys/select.h&gt;

int pselect(int nfds, fd_set *readfds, fd_set *writefds,
            fd_set *exceptfds, const struct timespec *timeout,
            const sigset_t *sigmask);
</code></pre>

<p>glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고):</p>
<dl>
<dt><code>pselect()</code>:</dt>
<dd><code>_POSIX_C_SOURCE &gt;= 200112L</code></dd>
</dl>
<h2 id="description">DESCRIPTION</h2>
<p><code>select()</code>와 <code>pselect()</code>를 이용해 프로그램에서 여러 파일 디스크립터들을 감시하고 그 중 하나 이상이 어떤 유형의 I/O 동작에 "준비" 상태(가령, 입력 가능)가 될 때까지 대기할 수 있다. 해당 I/O 동작(가령 <code>read(2)</code>나 충분히 작은 <code>write(2)</code>)을 블록킹 없이 수행하는 게 가능하면 파일 디스크립터가 준비 상태라고 본다.</p>
<p><code>select()</code>에서는 <code>FD_SETSIZE</code>보다 작은 파일 디스크립터 번호만 감시할 수 있다. <tt>[[poll(2)]]</tt>에는 그런 제한이 없다. BUGS 참고.</p>
<p><code>select()</code>와 <code>pselect()</code>의 동작은 다음 세 가지 차이를 빼면 동일하다.</p>
<p>(i) <code>select()</code>의 타임아웃은 <code>struct timeval</code>(초와 마이크로초)이지만 <code>pselect()</code>에서는 <code>struct timespec</code>(초와 나노초)을 쓴다.</p>
<p>(ii) <code>select()</code>에서는 남은 시간이 얼마인지 나타내기 위해 <code>timeout</code> 인자를 갱신할 수도 있다. <code>pselect()</code>에서는 그 인자를 바꾸지 않는다.</p>
<p>(iii) <code>select()</code>에는 <code>sigmask</code> 인자가 없고, 그래서 <code>sigmask</code>를 NULL로 해서 호출한 <code>pselect()</code>처럼 동작한다.</p>
<p>세 가지 독립적인 파일 디스크립터 집합을 감시한다. <code>readfds</code>에 나열된 파일 디스크립터들은 읽기 가능한 문자가 있는지 살펴본다. (더 정확히는 읽기가 블록 하지 않을지 확인한다. 특히 파일 끝에서도 파일 디스크립터가 준비된 상태이다.) <code>writefds</code>의 파일 디스크립터들은 쓰기를 위한 공간이 있는지 살펴본다. (큰 데이터를 쓰면 여전히 블록할 수도 있다.) <code>exceptfds</code>의 파일 디스크립터들은 예외 상황들을 확인한다. (예외 상황들의 몇 가지 예를 <tt>[[poll(2)]]</tt>의 <code>POLLPRI</code> 설명에서 볼 수 있다.)</p>
<p>빠져 나올 때 파일 디스크립터 집합 각각은 실제 상태가 바뀐 파일 디스크립터들을 나타내도록 변경되어 있다. (따라서 루프 안에서 <code>select()</code>를 쓴다면 호출 전에 매번 집합을 다시 설정해야 한다.)</p>
<p>해당 이벤트 유형에 대해 감시할 파일 디스크립터가 없다면 세 파일 디스크립터 집합 각각을 NULL로 지정할 수도 있다.</p>
<p>집합 조작을 위한 매크로 네 가지가 있다. <code>FD_ZERO()</code>는 집합을 비운다. <code>FD_SET()</code>과 <code>FD_CLR()</code>는 집합에 파일 디스크립터를 더하고 뺀다. <code>FD_ISSET()</code>은 파일 디스크립터가 집합에 포함돼 있는지 확인하는데, <code>select()</code> 반환 후에 쓰게 된다.</p>
<p><code>nfds</code>는 세 집합에서 번호가 가장 높은 파일 디스크립터에 1을 더한 값으로 설정하면 된다. 각 집합에서 파일 디스크립터가 표시돼 있는지를 그 제한치까지 확인한다. (하지만 BUGS 참고.)</p>
<p><code>timeout</code> 인자는 파일 디스크립터가 준비 상태가 되기를 기다리며 <code>select()</code>에서 블록 할 시간을 나타낸다. 다음 어느 경우든 해당할 때까지 호출이 블록 하게 된다.</p>
<ul>
<li>
<p>파일 디스크립터가 준비 상태가 된다.</p>
</li>
<li>
<p>호출이 시그널 핸들러에 의해 중단된다.</p>
</li>
<li>
<p>타임아웃이 만료된다.</p>
</li>
</ul>
<p>참고로 <code>timeout</code> 시간을 시스템 클럭 해상도에 따라 올림 하게 되며 커널 스케줄링 지연도 있기 때문에 그 블록 시간을 약간 넘길 수도 있다. <code>timeval</code> 구조체의 두 필드가 모두 0이면 <code>select()</code>가 즉시 반환한다. (폴링에 유용하다.) <code>timeout</code>이 NULL이면 (타임아웃이 없으면) <code>select()</code>에서 무한정 블록 할 수 있다.</p>
<p><code>sigmask</code>는 시그널 마스크(<tt>[[sigprocmask(2)]]</tt> 참고)에 대한 포인터다. NULL이 아닌 경우 <code>pselect()</code>에서는 먼저 현재 시그널 마스크를 <code>sigmask</code>가 가리키는 마스크로 교체하고, "select" 동작을 하고서, 원래 시그널 마스크를 복원한다.</p>
<p><code>timeout</code> 인자의 정밀도 차이를 제외하면 다음 <code>pselect()</code> 호출은</p>
<pre><code class="c">ready = pselect(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds,
                timeout, &amp;sigmask);
</code></pre>

<p>다음 호출들을 <em>원자적으로</em> 실행하는 것과 동등하다.</p>
<pre><code class="c">sigset_t origmask;

pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);
ready = select(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout);
pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);
</code></pre>

<p><code>pselect()</code>가 필요한 이유는 시그널과 파일 디스크립터 상태 변화를 함께 기다리려 할 때 경쟁 조건을 막으려면 원자적 검사가 필요하기 때문이다. (시그널 핸들러에서 전역 플래그를 설정하고 반환한다고 하자. 그 전역 플래그를 검사한 다음에 <code>select()</code> 호출을 한다고 할 때, 검사 후이자 호출 전에 시그널이 도착한다면 호출이 무한정 멈춰 있을 수도 있다. 반면 <code>pselect()</code>를 쓰는 경우에는 일단 시그널들을 막아 두고, 들어온 시그널들을 처리한 다음에 원하는 <code>sigmask</code>로 <code>pselect()</code>를 호출하여 경쟁을 피할 수 있다.)</p>
<h3 id="_1">타임아웃</h3>
<p>관련된 시간 구조체들이 <code>&lt;sys/time.h&gt;</code>에 정의돼 있으며 다음과 같은 형태이다.</p>
<pre><code class="c">struct timeval {
    long    tv_sec;         /* 초 */
    long    tv_usec;        /* 마이크로초 */
};
</code></pre>

<pre><code class="c">struct timespec {
    long    tv_sec;         /* 초 */
    long    tv_nsec;        /* 나노초 */
};
</code></pre>

<p>(하지만 아래의 POSIX.1 버전들 참고.)</p>
<p>어떤 코드에서는 세 집합을 모두 비우고 <code>nfds</code>를 0으로 하고서 NULL 아닌 <code>timeout</code>을 써서 <code>select()</code>를 호출하는데, 이는 초 단위 이하 정밀도로 잠잘 수 있는 꽤 이식성 좋은 방법이다.</p>
<p>리눅스에서는 잠자지 않은 시간의 양을 반영하도록 <code>timeout</code>을 변경한다. 하지만 대부분의 다른 구현들에서는 그러지 않는다. (POSIX.1에서는 어느 쪽 동작이든 허용한다.) 이 때문에 <code>timeout</code>을 읽는 리눅스 코드를 다른 운영 체제로 이식할 때, 그리고 루프에서 <code>struct timeval</code>을 재설정하지 않고 <code>select()</code> 여러 번에 재사용하는 코드를 리눅스로 이식할 때 문제가 생긴다. <code>select()</code> 반환 후에 <code>timeout</code>의 값은 규정돼 있지 않다고 보면 된다.</p>
<h2 id="return-value">RETURN VALUE</h2>
<p>성공 시 <code>select()</code>와 <code>pselect()</code>는 반환되는 세 디스크립터 집합에 담긴 파일 디스크립터들의 수를 (즉 <code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>에 설정된 비트들의 총개수를) 반환한다. 뭔가 이벤트가 생기기 전에 타임아웃이 만료된다면 0일 수도 있다. 오류 시 -1을 반환하며 오류를 나타내도록 <code>errno</code>를 설정한다. 그 경우 파일 디스크립터 집합들은 변경되지 않으며 <code>timeout</code>은 규정되지 않은 상태가 된다.</p>
<h2 id="errors">ERRORS</h2>
<dl>
<dt><code>EBADF</code></dt>
<dd>한 집합에 유효하지 않은 파일 디스크립터가 있다. (아마 이미 닫혔거나 오류가 발생했던 파일 디스크립터일 것이다.) 하지만 BUGS 참고.</dd>
<dt><code>EINTR</code></dt>
<dd>시그널을 잡았다. <tt>[[signal(7)]]</tt> 참고.</dd>
<dt><code>EINVAL</code></dt>
<dd><code>nfds</code>가 음수이거나 <code>RLIMIT_NOFILE</code> 자원 제한값(<tt>[[getrlimit(2)]]</tt> 참고)을 초과한다.</dd>
<dt><code>EINVAL</code></dt>
<dd><code>timeout</code>에 담긴 값이 유효하지 않다.</dd>
<dt><code>ENOMEM</code></dt>
<dd>내부 테이블을 위한 메모리를 할당할 수 없다.</dd>
</dl>
<h2 id="versions">VERSIONS</h2>
<p>리눅스 커널 2.6.16에서 <code>pselect()</code>가 추가되었다. 그 전에는 glibc에서 <code>pselect()</code>를 에뮬레이션 했다. (하지만 BUGS 참고.)</p>
<h2 id="conforming-to">CONFORMING TO</h2>
<p><code>select()</code>는 POSIX.1-2001, POSIX.1-2008, 4.4BSD를 (4.2BSD에서 <code>select()</code>가 처음 등장) 준수한다. BSD 소켓 계층 복제 형태를 지원하는 BSD 외 시스템들(시스템 V 계열 포함)과의 사이에서 일반적으로 서로 이식 가능하다. 하지만 시스템 V 계열에서는 보통 나오기 전에 타임아웃 변수를 설정하는 반면 BSD 계열에서는 그러지 않는다.</p>
<p><code>pselect()</code>는 POSIX.1g에, 그리고 POSIX.1-2001 및 POSIX.1-2008에 규정돼 있다.</p>
<h2 id="notes">NOTES</h2>
<p><code>fd_set</code>은 고정 크기 버퍼이다. 음수이거나 <code>FD_SETSIZE</code>와 같거나 더 큰 <code>fd</code> 값으로 <code>FD_CLR()</code>이나 <code>FD_SET()</code>을 실행할 때의 동작 방식은 규정돼 있지 않다. 또한 POSIX에서는 <code>fd</code>가 유효한 파일 디스크립터여야 한다고 요구한다.</p>
<p><code>select()</code> 및 <code>pselect()</code>의 동작은 <code>O_NONBLOCK</code> 플래그에 영향을 받지 않는다.</p>
<p>일부 다른 유닉스 시스템에서는 커널 내부 자원을 할당하지 못했을 때 리눅스의 <code>ENOMEM</code>이 아니라 <code>EAGAIN</code> 오류로 실패할 수 있다. POSIX에서 <tt>[[poll(2)]]</tt>에 이 오류를 명세하고 있지만 <code>select()</code>에 대해선 아니다. 이식 가능한 프로그램에서는 <code>EAGAIN</code>을 확인해서 <code>EINTR</code> 경우처럼 루프를 계속 도는 게 좋을 수 있다.</p>
<p><code>pselect()</code>가 없는 시스템에서는 자가 파이프 요령을 써서 신뢰성 있게 (그리고 더 이식성 있게) 시그널 잡기를 할 수 있다. 이 기법은 시그널 핸들러에서 파이프로 한 바이트를 써넣고 그 반대쪽을 주 프로그램의 <code>select()</code>로 감시하는 것이다. (가득 찬 파이프에 써넣거나 빈 파이프에서 읽을 때 블록 될 가능성을 피하기 위해 파이프에 읽고 쓸 때 논블로킹 I/O를 쓴다.)</p>
<p>사용 타입과 관련해서 전통적 환경에서는 <code>timeval</code> 구조체의 두 필드가 (위에 보인 것처럼) <code>long</code> 타입으로 되어 있으며 그 구조체가 <code>&lt;sys/time.h&gt;</code>에 정의돼 있다. 하지만 POSIX.1 환경에서는 다음과 같다.</p>
<pre><code class="c">struct timeval {
    time_t         tv_sec;     /* 초 */
    suseconds_t    tv_usec;    /* 마이크로초 */
};
</code></pre>

<p><code>&lt;sys/select.h&gt;</code>에 구조체가 정의돼 있으며 데이터 타입 <code>time_t</code>와 <code>suseconds_t</code>는 <code>&lt;sys/types.h&gt;</code>에 정의돼 있다.</p>
<p>원형과 관련해서 전통적 환경에서는 <code>select()</code>를 위해선 <code>&lt;time.h&gt;</code>를 포함시켜야 한다. POSIX.1 환경에서는 <code>select()</code>와 <code>pselect()</code>를 위해 <code>&lt;sys/select.h&gt;</code>를 포함시켜야 한다.</p>
<p>glibc 2.0 하에서 <code>&lt;sys/select.h&gt;</code>이 제공하는 <code>pselect()</code> 원형이 잘못돼 있다. glibc 2.1에서 2.2.1까지 하에선 <code>_GNU_SOURCE</code>가 정의돼 있을 때 <code>pselect()</code>를 제공한다. glibc 2.2.2부터는 요건이 SYNOPSIS에 나와 있는 대로이다.</p>
<h3 id="select-poll"><code>select()</code>와 <code>poll()</code> 알림의 대응 관계</h3>
<p>리눅스 커널 소스에서 찾을 수 있는 다음 정의들이 <code>select()</code>의 읽기 가능, 쓰기 가능, 예외 상황 알림과 <tt>[[poll(2)]]</tt>(과 <tt>[[epoll(7)]]</tt>)에서 제공하는 이벤트 알림 사이의 대응 관계를 보여 준다.</p>
<pre><code class="c">#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |
                    POLLERR)
                   /* 읽기 준비됨 */
#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)
                   /* 쓰기 준비됨 */
#define POLLEX_SET (POLLPRI)
                   /* 예외 상황 */
</code></pre>

<h3 id="_2">다중 스레드 응용</h3>
<p><code>select()</code>로 감시 중인 파일 디스크립터를 다른 스레드에서 닫는 경우의 결과는 명세돼 있지 않다. 어떤 유닉스 시스템에서는 <code>select()</code>가 블록을 멈추고 반환하며 그 파일 디스크립터가 준비 상태라고 표시한다. (그러면 이어지는 I/O 동작이 오류로 실패하게 된다. 단 <code>select()</code> 반환 시점과 I/O 동작 수행 시점 사이에 다른 프로세스에서 그 파일 디스크립터를 다시 열지 않아야 한다.) 리눅스에서는 (그리고 어떤 다른 시스템에서는) 다른 스레드에서 파일 디스크립터를 닫는 게 <code>select()</code>에 영향을 주지 않는다. 요컨데 이 상황에서 특정 동작 방식에 의존하는 응용은 버그가 있는 것으로 봐야 한다.</p>
<h3 id="c">C 라이브러리/커널 차이</h3>
<p>리눅스 커널에서는 임의 크기의 파일 디스크립터 집합이 가능하고 <code>nfds</code>의 값으로 검사할 집합의 길이를 알아낸다. 하지만 glibc 구현에서는 <code>fd_set</code> 타입의 길이가 고정돼 있다. BUGS도 참고.</p>
<p>이 페이지에서 기술하는 <code>pselect()</code> 인터페이스는 glibc에서 구현하고 있다. 기반 리눅스 시스템 호출의 이름은 <code>pselect6()</code>이다. 이 시스템 호출은 glibc 래퍼 함수와 동작 방식이 좀 다르다.</p>
<p>리눅스의 <code>pselect6()</code> 시스템 호출에서는 <code>timeout</code> 인자를 변경한다. 하지만 glibc 래퍼 함수에서 타임아웃 인자에 대한 지역 변수를 쓰고 그 변수를 시스템 호출로 전달하여 그 동작 방식을 감춘다. 그리하여 glibc의 <code>pselect()</code> 함수는 <code>timeout</code> 인자를 변경하지 않는다. 이는 POSIX.1-2001에서 요구하는 동작 방식이다.</p>
<p><code>pselect6()</code> 시스템 호출의 마지막 인자는 <code>sigset_t *</code> 포인터가 아니라 다음 형태의 구조체이다.</p>
<pre><code class="c">struct {
    const kernel_sigset_t *ss;   /* 시그널 집합에 대한 포인터 */
    size_t ss_len;               /* 'ss'가 가리키는 객체의 크기
                                    (바이트 단위) */
};
</code></pre>

<p>그래서 여러 아키텍처에서 시스템 호출에 최대 6개 인자만 지원한다는 점을 감안하면서 시스템 호출에서 시그널 집합 포인터와 그 크기를 모두 받을 수 있다. 커널과 libc에서의 시그널 집합 개념 차이에 대한 설명은 <tt>[[sigprocmask(2)]]</tt>를 보라.</p>
<h2 id="bugs">BUGS</h2>
<p>POSIX에서는 파일 디스크립터 집합에 지정할 수 있는 파일 디스크립터들의 범위에 대해 구현에서 상한을 정해서 상수 <code>FD_SETSIZE</code>를 통해 알리는 것을 허용한다. 리눅스 커널에서는 어떤 고정 제한도 두지 않지만 glibc 구현에서는 <code>FD_SETSIZE</code>를 1024로 해서 <code>fd_set</code>을 고정 크기 타입으로 만들고 <code>FD_*()</code> 매크로가 그 제한에 따라 동작하게 한다. 1023보다 큰 파일 디스크립터를 감시하려면 <tt>[[poll(2)]]</tt>을 써야 한다.</p>
<p><code>fd_set</code> 인자가 값-결과 인자로 구현돼 있으므로 <code>select()</code>를 호출할 때마다 다시 설정해 줘야 한다. <tt>[[poll(2)]]</tt>에서는 호출의 입력과 출력에 별도의 구조체 필드를 사용해서 이 설계 오류를 피한다.</p>
<p>POSIX에 따르면 <code>select()</code>에서는 세 파일 디스크립터 집합에 지정된 모든 파일 디스크립터들을 상한 <code>nfds-1</code>까지 확인해야 한다. 하지만 현재 구현에서는 프로세스가 현재 열어 둔 파일 디스크립터 번호의 최댓값보다 큰 파일 디스크립터를 무시한다. POSIX에 따르면 한 집합에 그런 파일 디스크립터가 지정돼 있으면 <code>EBADF</code> 오류가 발생해야 한다.</p>
<p>glibc 2.0에서는 <code>sigmask</code> 인자를 받지 않는 <code>pselect()</code> 버전을 제공했다.</p>
<p>glibc 버전 2.1부터 <tt>[[sigprocmask(2)]]</tt>와 <code>select()</code>를 이용해 구현한 <code>pselect()</code> 에뮬레이션을 제공했다. 그 구현은 <code>pselect()</code>가 방지해야 하는 바로 그 경쟁 조건에 여전히 취약했다. 최근의 glibc 버전들에서는 커널에서 (경쟁 없는) <code>pselect()</code> 시스템 호출을 제공하면 그걸 쓴다.</p>
<p>리눅스에서는 <code>select()</code>에서 어떤 소켓 파일 디스크립터를 "읽기 준비됨"으로 보고했는데 이어지는 읽기가 블록 될 수도 있다. 예를 들어 데이터가 도착했지만 조사해 보니 체크섬이 틀려서 폐기할 때 그럴 수 있다. 그 외에도 파일 디스크립터가 준비 상태라고 잘못 보고하는 다른 경우들이 있을 수 있다. 따라서 블록 해서는 안 되는 소켓에서는 <code>O_NONBLOCK</code>을 쓰는 게 안전할 수 있다.</p>
<p>리눅스에서는 시그널 핸들러에 의해 호출이 중단된 경우(즉 <code>EINTR</code> 오류 반환)에도 <code>select()</code>에서 <code>timeout</code>을 변경한다. 이는 POSIX.1에서 허용하지 않는 동작이다. 리눅스의 <code>pselect()</code> 시스템 호출도 동일하게 동작하지만 glibc 래퍼에서 내부적으로 <code>timeout</code>을 지역 변수로 복사하고 그 변수를 시스템 호출에 전달함으로써 그 동작 방식을 감춘다.</p>
<h2 id="example">EXAMPLE</h2>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int
main(void)
{
    fd_set rfds;
    struct timeval tv;
    int retval;

    /* stdin(fd 0)에 입력이 있는지 감시. */

    FD_ZERO(&amp;rfds);
    FD_SET(0, &amp;rfds);

    /* 5초까지 기다림. */

    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);
    /* tv의 값에 의존하지 말 것! */

    if (retval == -1)
        perror(&quot;select()&quot;);
    else if (retval)
        printf(&quot;Data is available now.\n&quot;);
        /* FD_ISSET(0, &amp;rfds)가 참임. */
    else
        printf(&quot;No data within five seconds.\n&quot;);

    exit(EXIT_SUCCESS);
}
</code></pre>

<h2 id="see-also">SEE ALSO</h2>
<p><code>accept(2)</code>, <code>connect(2)</code>, <tt>[[poll(2)]]</tt>, <code>read(2)</code>, <tt>[[recv(2)]]</tt>, <tt>[[restart_syscall(2)]]</tt>, <tt>[[send(2)]]</tt>, <tt>[[sigprocmask(2)]]</tt>, <code>write(2)</code>, <tt>[[epoll(7)]]</tt>, <tt>[[time(7)]]</tt></p>
<p>설명과 예시가 있는 자습서인 <tt>[[select_tut(2)]]</tt> 참고.</p>
<hr />
<p>2019-03-06</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
