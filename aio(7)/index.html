<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="리눅스 매뉴얼 페이지 일부 한글 번역">
    
    <link rel="canonical" href="https://wariua.github.io/man-pages-ko/aio(7)/">
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>Aio(7) - man-pages-ko</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/idea.min.css">
        
    
    <link href="../css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">man-pages-ko</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../section_file/">File</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_ipc/">IPC</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_memory/">Memory</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_network/">Network</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_process/">Process</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_thread/">Thread</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_trouble_shooting/">Trouble Shooting</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_others/">Others</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#name">NAME</a></li>
        <li class="first-level "><a href="#description">DESCRIPTION</a></li>
        <li class="first-level "><a href="#errors">ERRORS</a></li>
        <li class="first-level "><a href="#versions">VERSIONS</a></li>
        <li class="first-level "><a href="#conforming-to">CONFORMING TO</a></li>
        <li class="first-level "><a href="#notes">NOTES</a></li>
        <li class="first-level "><a href="#example">EXAMPLE</a></li>
            <li class="second-level"><a href="#_1">프로그램 소스</a></li>
                
        <li class="first-level "><a href="#see-also">SEE ALSO</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h2 id="name">NAME</h2>
<p>aio - POSIX 비동기 I/O 소개</p>
<h2 id="description">DESCRIPTION</h2>
<p>POSIX 비동기 I/O(AIO) 인터페이스를 응용에서 이용하여 비동기적으로 (즉 배경에서) 수행되는 I/O 동작을 한 개 이상 개시할 수 있다. I/O 동작 완료에 대한 알림을 응용에서 원하는 다양한 방식으로 받을 수 있다. 시그널 전달, 스레드 실행, 또는 알림을 받지 않을 수도 있다.</p>
<p>POSIX AIO 인터페이스는 다음 함수들로 이뤄져 있다.</p>
<dl>
<dt><tt>[[aio_read(3)]]</tt></dt>
<dd>읽기 요청을 큐에 넣는다. <code>read(2)</code>의 비동기 형태이다.</dd>
<dt><tt>[[aio_write(3)]]</tt></dt>
<dd>쓰기 요청을 큐에 넣는다. <code>write(2)</code>의 비동기 형태이다.</dd>
<dt><tt>[[aio_fsync(3)]]</tt></dt>
<dd>파일 디스크립터 상의 I/O 동작들에 대한 동기화 요청을 큐에 넣는다. <tt>[[fsync(2)]]</tt> 및 <tt>[[fdatasync(2)]]</tt>의 비동기 형태이다.</dd>
<dt><tt>[[aio_error(3)]]</tt></dt>
<dd>큐에 넣은 I/O 요청의 오류 상태를 얻는다.</dd>
<dt><tt>[[aio_return(3)]]</tt></dt>
<dd>완료된 I/O 요청의 반환 상태를 얻는다.</dd>
<dt><tt>[[aio_suspend(3)]]</tt></dt>
<dd>지정한 I/O 요청이 하나 이상 완료될 때까지 호출자를 멈춘다.</dd>
<dt><tt>[[aio_cancel(3)]]</tt></dt>
<dd>지정한 파일 디스크립터 상의 미처리 I/O 요청들을 취소 시도한다.</dd>
<dt><tt>[[lio_listio(3)]]</tt></dt>
<dd>한 번의 함수 호출로 여러 I/O 요청을 큐에 넣는다.</dd>
</dl>
<p><code>aiocb</code>(비동기 I/O 제어 블록) 구조체가 I/O 동작을 제어하는 매개변수들을 정의한다. 위에 나열한 함수 모두에서 이 타입의 인자를 쓴다. 이 구조체는 다음 형태이다.</p>
<pre><code class="c">#include &lt;aiocb.h&gt;

struct aiocb {
    /* 이 필드들의 순서는 구현에 따라 다름 */

    int             aio_fildes;     /* 파일 디스크립터 */
    off_t           aio_offset;     /* 파일 오프셋 */
    volatile void  *aio_buf;        /* 버퍼 위치 */
    size_t          aio_nbytes;     /* 전송 길이 */
    int             aio_reqprio;    /* 요청 우선순위 */
    struct sigevent aio_sigevent;   /* 알림 방법 */
    int             aio_lio_opcode; /* 수행할 동작.
                                       lio_listio()에서만 */

    /* 여러 구현 내부용 필드 생략 */
};

/* 'aio_lio_opcode'의 동작 코드 */

enum { LIO_READ, LIO_WRITE, LIO_NOP };
</code></pre>

<p>이 구조체의 필드들은 다음과 같다.</p>
<dl>
<dt><code>aio_fildes</code></dt>
<dd>I/O 동작을 수행할 파일 디스크립터.</dd>
<dt><code>aio_offset</code></dt>
<dd>I/O 동작을 수행할 파일 오프셋.</dd>
<dt><code>aio_buf</code></dt>
<dd>읽기 또는 쓰기 동작에서 데이터 이동에 사용하는 버퍼.</dd>
<dt><code>aio_nbytes</code></dt>
<dd><code>aio_buf</code>가 가리키는 버퍼의 크기.</dd>
<dt><code>aio_reqprio</code></dt>
<dd>이 필드에 지정한 값을 호출 스레드의 실시간 우선순위에서 빼서 이 I/O 요청의 실행 우선순위를 결정한다. (<tt>[[pthread_setschedparam(3)]]</tt> 참고.) 지정하는 값이 0과 <code>sysconf(_SC_AIO_PRIO_DELTA_MAX)</code> 반환 값 사이에 있어야 한다. 파일 동기화 동작에서는 이 필드를 무시한다.</dd>
<dt><code>aio_sigevent</code></dt>
<dd>비동기 I/O 동작이 완료됐을 때 호출자가 알림을 받는 방법을 지정하는 구조체이다. <code>aio_sigevent.sigev_notify</code>에 가능한 값은 <code>SIGEV_NONE</code>, <code>SIGEV_SIGNAL</code>, <code>SIGEV_THREAD</code>이다. 자세한 내용은 <tt>[[sigevent(7)]]</tt> 참고.</dd>
<dt><code>aio_lio_opcode</code></dt>
<dd>수행할 동작 종류. <tt>[[lio_listio(3)]]</tt>에서만 사용.</dd>
</dl>
<p>위에 나열한 표준 함수들에 더해서 GNU C 라이브러리에서는 POSIX AIO API에 대한 다음 확장을 제공한다.</p>
<dl>
<dt><tt>[[aio_init(3)]]</tt></dt>
<dd>glibc POSIX AIO 구현의 동작을 조정하는 매개변수들을 설정한다.</dd>
</dl>
<h2 id="errors">ERRORS</h2>
<dl>
<dt><code>EINVAL</code></dt>
<dd><code>aiocb</code> 구조체의 <code>aio_reqprio</code> 필드가 0보다 작거나 <code>sysconf(_SC_AIO_PRIO_DELTA_MAX)</code> 호출이 반환한 한계치보다 크다.</dd>
</dl>
<h2 id="versions">VERSIONS</h2>
<p>glibc 버전 2.1부터 POSIX AIO 인터페이스를 제공한다.</p>
<h2 id="conforming-to">CONFORMING TO</h2>
<p>POSIX.1-2001, POSIX.1-2008.</p>
<h2 id="notes">NOTES</h2>
<p>제어 블록 버퍼를 사용하기 전에 0으로 채우는 게 좋다. (<code>memset(3)</code> 참고.) I/O 동작이 진행 중인 동안 제어 블록 버퍼와 <code>aio_buf</code>가 가리키는 버퍼가 변경되어선 안 된다. I/O 동작이 완료될 때까지 그 버퍼들이 유효한 상태로 유지돼야 한다.</p>
<p>같은 <code>aiocb</code> 구조체를 사용해 동시에 비동기 읽기 동작과 쓰기 동작을 할 때 나오는 결과는 규정돼 있지 않다.</p>
<p>현재 리눅스의 POSIX AIO 구현은 사용자 공간에서 glibc가 제공한다. 그래서 여러 제약이 있는데, 가장 눈에 띄는 건 I/O 동작을 수행하기 위해 여러 스레드를 유지하는 게 비용이 크고 확장성이 떨어진다는 점이다. 얼마 전부터 커널에서 상태 머신 기반으로 비동기 I/O를 구현하는 작업이 진행 중이긴 한데 (<tt>[[io_submit(2)]]</tt>, <tt>[[io_setup(2)]]</tt>, <tt>[[io_cancel(2)]]</tt>, <tt>[[io_destroy(2)]]</tt>, <tt>[[io_getevents(2)]]</tt> 참고) 그 커널 시스템 호출들을 이용해 POSIX AIO 구현을 완전히 재구현할 수 있는 수준까지는 아직 오지 못했다.</p>
<h2 id="example">EXAMPLE</h2>
<p>아래 프로그램에서는 명령행 인자에 지명한 파일들 각각을 열어서 얻은 파일 디스크립터에 <tt>[[aio_read(3)]]</tt>로 요청을 넣는다. 그러고서 루프를 돌면서 아직 진행 중인 I/O 동작 각각을 <tt>[[aio_error(3)]]</tt>를 이용해 주기적으로 확인한다. I/O 요청 각각은 시그널 전달로 알림을 주도록 설정한다. 모든 I/O 요청이 완료된 후에 <tt>[[aio_return(3)]]</tt>으로 상태를 가져온다.</p>
<p><code>SIGQUIT</code> 시그널(Control-\ 입력으로 생성)을 주면 프로그램에서 <tt>[[aio_cancel(3)]]</tt>로 미처리 요청 각각의 취소를 요청한다.</p>
<p>다음은 이 프로그램을 실행한 결과 예시이다. 이 예에서는 표준 입력에 대한 요청을 두 개 하고, "abc"와 "x"를 담은 두 입력 행으로 그 요청을 충족시킨다.</p>
<pre><code class="text">$ ./a.out /dev/stdin /dev/stdin
opened /dev/stdin on descriptor 3
opened /dev/stdin on descriptor 4
aio_error():
    for request 0 (descriptor 3): In progress
    for request 1 (descriptor 4): In progress
abc
I/O completion signal received
aio_error():
    for request 0 (descriptor 3): I/O succeeded
    for request 1 (descriptor 4): In progress
aio_error():
    for request 1 (descriptor 4): In progress
x
I/O completion signal received
aio_error():
    for request 1 (descriptor 4): I/O succeeded
All I/O requests completed
aio_return():
    for request 0 (descriptor 3): 4
    for request 1 (descriptor 4): 2
</code></pre>

<h3 id="_1">프로그램 소스</h3>
<pre><code class="c">#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;aio.h&gt;
#include &lt;signal.h&gt;

#define BUF_SIZE 20     /* 읽기 동작을 위한 버퍼 크기 */

#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)

#define errMsg(msg)  do { perror(msg); } while (0)

struct ioRequest {      /* I/O 요청 추적을 위해 응용 자체에서
                           정의하는 구조체 */
    int           reqNum;
    int           status;
    struct aiocb *aiocbp;
};

static volatile sig_atomic_t gotSIGQUIT = 0;
                        /* SIGQUIT이 전달되면 미처리 I/O 요청을
                           모두 취소하려고 시도 */

static void             /* SIGQUIT 핸들러 */
quitHandler(int sig)
{
    gotSIGQUIT = 1;
}

#define IO_SIGNAL SIGUSR1   /* I/O 완료를 알리는 데 쓸 시그널 */

static void                 /* I/O 완료 시그널 핸들러 */
aioSigHandler(int sig, siginfo_t *si, void *ucontext)
{
    if (si-&gt;si_code == SI_ASYNCIO) {
        write(STDOUT_FILENO, &quot;I/O completion signal received\n&quot;, 31);

        /* 대응하는 ioRequest 구조체를 다음과 같이 얻을 수 있음:
               struct ioRequest *ioReq = si-&gt;si_value.sival_ptr;
           그리고 파일 디스크립터를 다음을 통해 얻을 수 있음:
               ioReq-&gt;aiocbp-&gt;aio_fildes */
    }
}

int
main(int argc, char *argv[])
{
    struct ioRequest *ioList;
    struct aiocb *aiocbList;
    struct sigaction sa;
    int s, j;
    int numReqs;        /* 큐에 넣은 I/O 요청 총 개수 */
    int openReqs;       /* 아직 진행 중인 I/O 요청 개수 */

    if (argc &lt; 2) {
        fprintf(stderr, &quot;Usage: %s &lt;pathname&gt; &lt;pathname&gt;...\n&quot;,
                argv[0]);
        exit(EXIT_FAILURE);
    }

    numReqs = argc - 1;

    /* 배열 할당 */

    ioList = calloc(numReqs, sizeof(struct ioRequest));
    if (ioList == NULL)
        errExit(&quot;calloc&quot;);

    aiocbList = calloc(numReqs, sizeof(struct aiocb));
    if (aiocbList == NULL)
        errExit(&quot;calloc&quot;);

    /* SIGQUIT 및 I/O 완료 시그널을 위한 핸들러 설정 */

    sa.sa_flags = SA_RESTART;
    sigemptyset(&amp;sa.sa_mask);

    sa.sa_handler = quitHandler;
    if (sigaction(SIGQUIT, &amp;sa, NULL) == -1)
        errExit(&quot;sigaction&quot;);

    sa.sa_flags = SA_RESTART | SA_SIGINFO;
    sa.sa_sigaction = aioSigHandler;
    if (sigaction(IO_SIGNAL, &amp;sa, NULL) == -1)
        errExit(&quot;sigaction&quot;);

    /* 명령행에 지정한 파일 각각을 열고, 그렇게 얻은 파일
       디스크립터에서 읽기 요청을 큐에 넣기 */

    for (j = 0; j &lt; numReqs; j++) {
        ioList[j].reqNum = j;
        ioList[j].status = EINPROGRESS;
        ioList[j].aiocbp = &amp;aiocbList[j];

        ioList[j].aiocbp-&gt;aio_fildes = open(argv[j + 1], O_RDONLY);
        if (ioList[j].aiocbp-&gt;aio_fildes == -1)
            errExit(&quot;open&quot;);
        printf(&quot;opened %s on descriptor %d\n&quot;, argv[j + 1],
                ioList[j].aiocbp-&gt;aio_fildes);

        ioList[j].aiocbp-&gt;aio_buf = malloc(BUF_SIZE);
        if (ioList[j].aiocbp-&gt;aio_buf == NULL)
            errExit(&quot;malloc&quot;);

        ioList[j].aiocbp-&gt;aio_nbytes = BUF_SIZE;
        ioList[j].aiocbp-&gt;aio_reqprio = 0;
        ioList[j].aiocbp-&gt;aio_offset = 0;
        ioList[j].aiocbp-&gt;aio_sigevent.sigev_notify = SIGEV_SIGNAL;
        ioList[j].aiocbp-&gt;aio_sigevent.sigev_signo = IO_SIGNAL;
        ioList[j].aiocbp-&gt;aio_sigevent.sigev_value.sival_ptr =
                                &amp;ioList[j];

        s = aio_read(ioList[j].aiocbp);
        if (s == -1)
            errExit(&quot;aio_read&quot;);
    }

    openReqs = numReqs;

    /* 루프 돌면서 I/O 요청 상태 확인 */

    while (openReqs &gt; 0) {
        sleep(3);       /* 확인 간격 */

        if (gotSIGQUIT) {

            /* SIGQUIT 수신 시 미처리 I/O 요청 각각을 취소 시도하고,
               취소 요청에서 반환 받은 상태를 표시 */

            printf(&quot;got SIGQUIT; canceling I/O requests: \n&quot;);

            for (j = 0; j &lt; numReqs; j++) {
                if (ioList[j].status == EINPROGRESS) {
                    printf(&quot;    Request %d on descriptor %d:&quot;, j,
                            ioList[j].aiocbp-&gt;aio_fildes);
                    s = aio_cancel(ioList[j].aiocbp-&gt;aio_fildes,
                            ioList[j].aiocbp);
                    if (s == AIO_CANCELED)
                        printf(&quot;I/O canceled\n&quot;);
                    else if (s == AIO_NOTCANCELED)
                        printf(&quot;I/O not canceled\n&quot;);
                    else if (s == AIO_ALLDONE)
                        printf(&quot;I/O all done\n&quot;);
                    else
                        errMsg(&quot;aio_cancel&quot;);
                }
            }

            gotSIGQUIT = 0;
        }

        /* 아직 진행 중인 I/O 요청 각각의 상태 확인 */

        printf(&quot;aio_error():\n&quot;);
        for (j = 0; j &lt; numReqs; j++) {
            if (ioList[j].status == EINPROGRESS) {
                printf(&quot;    for request %d (descriptor %d): &quot;,
                        j, ioList[j].aiocbp-&gt;aio_fildes);
                ioList[j].status = aio_error(ioList[j].aiocbp);

                switch (ioList[j].status) {
                case 0:
                    printf(&quot;I/O succeeded\n&quot;);
                    break;
                case EINPROGRESS:
                    printf(&quot;In progress\n&quot;);
                    break;
                case ECANCELED:
                    printf(&quot;Canceled\n&quot;);
                    break;
                default:
                    errMsg(&quot;aio_error&quot;);
                    break;
                }

                if (ioList[j].status != EINPROGRESS)
                    openReqs--;
            }
        }
    }

    printf(&quot;All I/O requests completed\n&quot;);

    /* 모든 I/O 요청의 상태 반환 값 확인 */

    printf(&quot;aio_return():\n&quot;);
    for (j = 0; j &lt; numReqs; j++) {
        ssize_t s;

        s = aio_return(ioList[j].aiocbp);
        printf(&quot;    for request %d (descriptor %d): %zd\n&quot;,
                j, ioList[j].aiocbp-&gt;aio_fildes, s);
    }

    exit(EXIT_SUCCESS);
}
</code></pre>

<h2 id="see-also">SEE ALSO</h2>
<p><tt>[[io_cancel(2)]]</tt>, <tt>[[io_destroy(2)]]</tt>, <tt>[[io_getevents(2)]]</tt>, <tt>[[io_setup(2)]]</tt>, <tt>[[io_submit(2)]]</tt>, <tt>[[aio_cancel(3)]]</tt>, <tt>[[aio_error(3)]]</tt>, <tt>[[aio_init(3)]]</tt>, <tt>[[aio_read(3)]]</tt>, <tt>[[aio_return(3)]]</tt>, <tt>[[aio_write(3)]]</tt>, <tt>[[lio_listio(3)]]</tt></p>
<p>"Asynchronous I/O Support in Linux 2.5", Bhattacharya, Pratt, Pulavarty, and Morgan, Proceedings of the Linux SYmposium, 2003, <a href="https://www.kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf">https://www.kernel.org/doc/ols/2003/ols2003-pages-351-366.pdf</a></p>
<hr />
<p>2019-03-06</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
