diff --git a/docs/fanotify(7).md b/docs/fanotify(7).md
index 2833f502..71c237c4 100644
--- a/docs/fanotify(7).md
+++ b/docs/fanotify(7).md
@@ -84,13 +84,13 @@ struct fanotify_event_info_fid {
 :   이 필드는 사용하지 않는다.
 
 `metadata_len`
-:   구조체의 길이이다. 이 필드는 이벤트 유형에 따른 선택적 헤더를 구현할 수 있도록 도입된 것이다. 현재 구현에서는 그런 선택적 헤더가 없다.
+:   구조체의 길이다. 이 필드는 이벤트 유형에 따른 선택적 헤더를 구현할 수 있도록 도입된 것이다. 현재 구현에서는 그런 선택적 헤더가 없다.
 
 `mask`
-:   이벤트를 기술하는 비트 마스크이다. (아래 참고.)
+:   이벤트를 기술하는 비트 마스크다. (아래 참고.)
 
 `fd`
-:   접근이 이뤄지고 있는 객체에 대한 열린 파일 디스크립터이다. 큐 넘침이 일어난 경우에는 `FAN_NOFD`이다. 파일 핸들로 파일 시스템 객체를 식별하는 fanotify 그룹에서는 수신하는 이벤트마다 이 값이 `FAN_NOFD`로 설정돼 있게 된다. 이 파일 디스크립터를 사용해 감시하는 파일 내지 디렉터리의 내용에 접근할 수 있다. 읽는 쪽 응용에서 파일 디스크립터를 닫을 책임이 있다.
+:   접근이 이뤄지고 있는 객체에 대한 열린 파일 디스크립터다. 큐 넘침이 일어난 경우에는 `FAN_NOFD`이다. 파일 핸들로 파일 시스템 객체를 식별하는 fanotify 그룹에서는 수신하는 이벤트마다 이 값이 `FAN_NOFD`로 설정돼 있게 된다. 이 파일 디스크립터를 사용해 감시하는 파일 내지 디렉터리의 내용에 접근할 수 있다. 읽는 쪽 응용에서 파일 디스크립터를 닫을 책임이 있다.
 
     <tt>[[fanotify_init(2)]]</tt> 호출 시에 (`event_f_flags` 인자를 통해) 이 파일 디스크립터에 대응하는 열린 파일 기술 항목에 설정할 다양한 파일 상태 플래그들을 지정할 수 있다. 더불어 그 열린 파일 기술 항목에는 (커널 내부용인) `FMODE_NONOTIFY` 파일 상태 플래그가 설정된다. 이 플래그는 fanotify 이벤트 생성을 막는다. 그래서 fanotify 이벤트 수신자가 이 파일 디스크립터를 이용해 알림 대상 파일 내지 디렉터리에 접근할 때 이벤트가 추가로 생기지 않게 된다.
 
@@ -215,7 +215,7 @@ struct fanotify_response {
 이 구조체의 필드들은 다음과 같다.
 
 `fd`
-:   `fanotify_event_metadata` 구조체에서 온 파일 디스크립터이다.
+:   `fanotify_event_metadata` 구조체에서 온 파일 디스크립터다.
 
 `response`
 :   이 필드는 동작을 인가할지 여부를 나타낸다. 파일 동작을 허용하는 `FAN_ALLOW`거나 파일 동작을 거부하는 `FAN_DENY`여야 한다.
diff --git a/docs/fanotify_mark(2).md b/docs/fanotify_mark(2).md
index 8ecdbc47..0206d02d 100644
--- a/docs/fanotify_mark(2).md
+++ b/docs/fanotify_mark(2).md
@@ -17,7 +17,7 @@ fanotify API에 대한 소개는 <tt>[[fanotify(7)]]</tt>를 보라.
 
 `fanotify_mark()`는 파일 시스템 객체에 fanotify 표시를 추가하거나 제거하거나 변경한다. 표시를 하는 파일 시스템 객체에 대해 호출자가 읽기 권한을 가지고 있어야 한다.
 
-`fanotify_fd` 인자는 <tt>[[fanotify_init(2)]]</tt>이 반환한 파일 디스크립터이다.
+`fanotify_fd` 인자는 <tt>[[fanotify_init(2)]]</tt>이 반환한 파일 디스크립터다.
 
 `flags`는 수행할 변경 동작을 기술하는 비트 마스크이다. 다음 값들 중 정확히 하나를 포함해야 한다.
 
@@ -122,7 +122,7 @@ fanotify API에 대한 소개는 <tt>[[fanotify(7)]]</tt>를 보라.
 
 * `pathname`이 NULL이고 `dirfd`가 특수 값 `AT_FDCWD`이면 현재 작업 디렉터리에 표시를 한다.
 
-* `pathname`이 절대 경로이면 표시할 파일 시스템 객체를 결정하며, `dirfd`는 무시된다.
+* `pathname`이 절대 경로면 표시할 파일 시스템 객체를 결정하며, `dirfd`는 무시된다.
 
 * `pathname`이 상대 경로이고 `dirfd`의 값이 `AT_FDCWD`가 아니면 `dirfd`가 가리키는 디렉터리를 기준으로 `pathname`을 해석해서 표시할 파일 시스템 객체를 결정한다.
 
diff --git a/docs/fpathconf(3).md b/docs/fpathconf(3).md
index 4f3fffae..d772a877 100644
--- a/docs/fpathconf(3).md
+++ b/docs/fpathconf(3).md
@@ -83,10 +83,10 @@ long pathconf(const char *path, int name);
 :   (`pathconf()`) `path`가 너무 길다.
 
 `ENOENT`
-:   (`pathconf()`) `path`의 어느 요소가 존재하지 않거나 `path`가 빈 문자열이다.
+:   (`pathconf()`) `path`의 어느 부분이 존재하지 않거나 `path`가 빈 문자열이다.
 
 `ENOTDIR`
-:   (`pathconf()`) `path`에 디렉터리로 쓰인 어느 요소가 실제로는 디렉터리가 아니다.
+:   (`pathconf()`) `path`에 디렉터리로 쓰인 어느 부분이 실제로는 디렉터리가 아니다.
 
 ## ATTRIBUTES
 
diff --git a/docs/futimesat(2).md b/docs/futimesat(2).md
index 428f5e35..39090e46 100644
--- a/docs/futimesat(2).md
+++ b/docs/futimesat(2).md
@@ -41,7 +41,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   `dirfd`가 유효한 파일 디스크립터가 아니다.
 
 `ENOTDIR`
-:   `pathname`이 상대적인데 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터이다.
+:   `pathname`이 상대적인데 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터다.
 
 ## VERSIONS
 
diff --git a/docs/inotify_add_watch(2).md b/docs/inotify_add_watch(2).md
index 2e5165c2..82567bb5 100644
--- a/docs/inotify_add_watch(2).md
+++ b/docs/inotify_add_watch(2).md
@@ -12,7 +12,7 @@ int inotify_add_watch(int fd, const char *pathname, uint32_t mask);
 
 ## DESCRIPTION
 
-`inotify_add_watch()`는 `pathname`에 지정한 위치의 파일에 대해 새 감시 항목을 추가하거나 기존 감시 항목을 변경한다. 호출자가 그 파일에 대해 읽기 권한을 가지고 있어야 한다. `fd` 인자는 감시 목록을 변경할 inotify 인스턴스를 가리키는 파일 디스크립터이다. `pathname`에 대해 감시할 이벤트들을 비트 마스크 인자 `mask`에 지정한다. `mask`에 설정할 수 있는 비트들에 대한 설명은 <tt>[[inotify(7)]]</tt>를 보라.
+`inotify_add_watch()`는 `pathname`에 지정한 위치의 파일에 대해 새 감시 항목을 추가하거나 기존 감시 항목을 변경한다. 호출자가 그 파일에 대해 읽기 권한을 가지고 있어야 한다. `fd` 인자는 감시 목록을 변경할 inotify 인스턴스를 가리키는 파일 디스크립터다. `pathname`에 대해 감시할 이벤트들을 비트 마스크 인자 `mask`에 지정한다. `mask`에 설정할 수 있는 비트들에 대한 설명은 <tt>[[inotify(7)]]</tt>를 보라.
 
 `inotify_add_watch()` 호출이 성공하면 `pathname`에 해당하는 파일 시스템 객체(아이노드)에 대한, 이 inotify 인스턴스에서 유일한 감시 디스크립터를 반환한다. 그 파일 시스템 객체를 이 inotify 인스턴스로 이전부터 감시하고 있던 게 아니면 감시 디스크립터를 새로 할당한다. 그 파일 시스템 객체가 (어쩌면 동일 객체에 대한 다른 링크를 통해서) 이미 감시 중이었으면 기존 감시 항목에 대한 디스크립터를 반환한다.
 
@@ -43,7 +43,7 @@ int inotify_add_watch(int fd, const char *pathname, uint32_t mask);
 :   `pathname`이 너무 길다.
 
 `ENOENT`
-:   `pathname`의 어느 디렉터리 요소가 존재하지 않거나 깨진 심볼릭 링크이다.
+:   `pathname`의 어느 디렉터리 부분이 존재하지 않거나 깨진 심볼릭 링크다.
 
 `ENOMEM`
 :   사용 가능한 커널 메모리가 충분하지 않다.
diff --git a/docs/insque(3).md b/docs/insque(3).md
index 3aca700e..cf03d48c 100644
--- a/docs/insque(3).md
+++ b/docs/insque(3).md
@@ -20,7 +20,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 
 ## DESCRIPTION
 
-`insque()` 및 `remque()` 함수는 이중 연결 리스트를 조작한다. 리스트의 각 항목은 처음 두 요소가 순방향 및 역방향 포인터인 구조체이다. 연결 리스트는 선형(즉 리스트 끝에서 순방향 포인터가 NULL이고 리스트 처음에서 역방향 포인터가 NULL)일 수도 있고 원형일 수도 있다.
+`insque()` 및 `remque()` 함수는 이중 연결 리스트를 조작한다. 리스트의 각 항목은 처음 두 구성 요소가 순방향 및 역방향 포인터인 구조체이다. 연결 리스트는 선형(즉 리스트 끝에서 순방향 포인터가 NULL이고 리스트 처음에서 역방향 포인터가 NULL)일 수도 있고 원형일 수도 있다.
 
 `insque()` 함수는 `elem`이 가리키는 항목을 `prev`가 가리키는 항목 바로 다음에 삽입한다.
 
diff --git a/docs/io_submit(2).md b/docs/io_submit(2).md
index 845c5b1d..d3a9f27a 100644
--- a/docs/io_submit(2).md
+++ b/docs/io_submit(2).md
@@ -82,13 +82,13 @@ struct iocb {
 :   요청 우선순위를 나타낸다.
 
 `aio_fildes`
-:   I/O 동작을 수행할 파일 디스크립터이다.
+:   I/O 동작을 수행할 파일 디스크립터다.
 
 `aio_buf`
-:   읽기 또는 쓰기 동작에서 데이터 이동에 사용할 버퍼이다.
+:   읽기 또는 쓰기 동작에서 데이터 이동에 사용할 버퍼다.
 
 `aio_nbytes`
-:   `aio_buf`가 가리키는 버퍼의 크기이다.
+:   `aio_buf`가 가리키는 버퍼의 크기다.
 
 `aio_offset`
 :   I/O 동작을 수행할 파일 오프셋이다.
@@ -103,7 +103,7 @@ struct iocb {
     :   `aio_reqprio` 필드를 `linux/ioprio.h`에 정의된 `IOPRIO_VALUE`로 해석한다.
 
 `aio_resfd`
-:   비동기 I/O 완료 시에 알림을 보낼 파일 디스크립터이다.
+:   비동기 I/O 완료 시에 알림을 보낼 파일 디스크립터다.
 
 ## RETURN VALUE
 
diff --git a/docs/libc(7).md b/docs/libc(7).md
index 5928a0c4..829a4636 100644
--- a/docs/libc(7).md
+++ b/docs/libc(7).md
@@ -10,7 +10,7 @@ libc - 리눅스의 표준 C 라이브러리들 소개
 
 리눅스에서 단연 가장 널리 쓰이는 C 라이브러리는 GNU C 라이브러리(http://www.gnu.org/software/libc/)이며 *glibc*라고 많이 부른다. 요즘 모든 주요 리눅스 배포판에서 쓰는 C 라이브러리이며, 그 세부 내용들이 *man-pages* 프로젝트의 관련 페이지들에 (주로 매뉴얼의 섹션 3에) 기록돼 있는 C 라이브러리이기도 하다. glibc 매뉴얼을 통해서도 glibc의 문서를 볼 수 있는데, `info libc` 명령으로 가능하다. glibc 1.0이 1992년 9월에 출시되었다. (그 전에 0.x 출시가 있었다.) glibc의 다음 큰 버전인 2.0이 1997년 초에 출시되었다.
 
-보통은 경로명 `/lib/libc.so.6`이 (또는 비슷한 뭔가가) glibc 라이브러리 위치를 가리키는 심볼릭 링크이다. 그 경로명을 실행하면 glibc가 시스템에 설치된 버전에 대한 여러 정보를 표시하게 된다.
+보통은 경로명 `/lib/libc.so.6`이 (또는 비슷한 뭔가가) glibc 라이브러리 위치를 가리키는 심볼릭 링크다. 그 경로명을 실행하면 glibc가 시스템에 설치된 버전에 대한 여러 정보를 표시하게 된다.
 
 ### Linux libc
 
diff --git a/docs/open(2).md b/docs/open(2).md
index fc182dc8..6e5b91b0 100644
--- a/docs/open(2).md
+++ b/docs/open(2).md
@@ -35,7 +35,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 
 `open()` 시스템 호출은 `pathname`에 지정한 파일을 연다. 지정한 파일이 존재하지 않는 경우 선택적으로 (`flags`에 `O_CREAT`을 지정한 경우) `open()`에서 생성할 수도 있다.
 
-`open()`의 반환 값은 파일 디스크립터이다. 이는 작은 음수 아닌 정수이며 이후의 시스템 호출들(`read(2)`, `write(2)`, <tt>[[lseek(2)]]</tt>, <tt>[[fcntl(2)]]</tt> 등)에서 그 열린 파일을 가리키는 데 쓴다. 호출이 성공하면 프로세스에서 현재 열려 있지 않은 가장 낮은 번호의 파일 디스크립터를 반환하게 된다.
+`open()`의 반환 값은 파일 디스크립터다. 이는 작은 음수 아닌 정수이며 이후의 시스템 호출들(`read(2)`, `write(2)`, <tt>[[lseek(2)]]</tt>, <tt>[[fcntl(2)]]</tt> 등)에서 그 열린 파일을 가리키는 데 쓴다. 호출이 성공하면 프로세스에서 현재 열려 있지 않은 가장 낮은 번호의 파일 디스크립터를 반환하게 된다.
 
 기본적으로 새 파일 디스크립터는 <tt>[[execve(2)]]</tt>를 거칠 때 계속 열려 있도록 설정돼 있다. (즉 <tt>[[fcntl(2)]]</tt>에서 설명하는 파일 디스크립터 플래그 `FD_CLOEXEC`가 처음에는 비활성화돼 있다.) 아래에서 설명하는 `O_CLOEXEC` 플래그를 써서 이 기본 설정을 바꿀 수 있다. 파일 오프셋은 파일 시작점으로 설정돼 있다. (<tt>[[lseek(2)]]</tt> 참고.)
 
@@ -69,7 +69,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 
     `mode` 인자는 새 파일 생성 시 적용할 파일 모드 비트를 나타낸다. `flags`에 `O_CREAT`과 `O_TMPFILE` 어느 쪽도 지정하지 않은 경우에는 `mode`가 무시된다. (따라서 0으로 지정할 수도 있고, 그냥 생략할 수도 있다.) `flags`에 `O_CREAT`이나 `O_TMPFILE`를 지정할 때는 `mode` 인자를 **반드시** 제공해야 한다. 주지 않으면 스택에 있는 임의의 바이트들이 파일 모드로 적용된다.
 
-    실제 적용되는 모드는 프로세스의 `umask`를 일반적 방식으로 써서 변경한 값이다. 즉 기본 ACL이 없는 경우 생성 파일의 모드는 `(mode & ~umask)`이다.
+    실제 적용되는 모드는 프로세스의 `umask`를 일반적 방식으로 써서 변경한 값이다. 즉 기본 ACL이 없는 경우 생성 파일의 모드는 `(mode & ~umask)`다.
 
     참고로 `mode`는 새로 생성되는 파일의 향후 접근에만 적용된다. 즉 읽기 전용 파일을 생성하게 돼 있는 `open()` 호출이 읽기/쓰기 가능한 파일 디스크립터를 반환하는 것도 충분히 가능하다.
 
@@ -244,11 +244,11 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 
 `openat()` 시스템 호출은 여기 설명하는 차이점을 빼면 `open()`과 똑같이 동작한다.
 
-`pathname`에 준 경로명이 상대 경로이면 (상대 경로명에 대해 `open()`에서 하듯 호출 프로세스의 현재 작업 디렉터리를 기준으로 하는 게 아니라) 파일 디스크립터 `dirfd`가 가리키는 디렉터리를 기준으로 경로명을 해석한다.
+`pathname`에 준 경로명이 상대 경로면 (`open()`에서 하듯 호출 프로세스의 현재 작업 디렉터리를 기준으로 하는 게 아니라) 파일 디스크립터 `dirfd`가 가리키는 디렉터리를 기준으로 경로명을 해석한다.
 
 `pathname`이 상대 경로이고 `dirfd`가 특수 값 `AT_FDCWD`이면 (`open()`처럼) 호출 프로세스의 현재 작업 디렉터리를 기준으로 `pathname`을 해석한다.
 
-`pathname`이 절대 경로이면 `dirfd`를 무시한다.
+`pathname`이 절대 경로면 `dirfd`를 무시한다.
 
 ### <tt>[[openat2(2)]]</tt>
 
@@ -272,7 +272,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   `flags`에 `O_EXCL`을 지정했는데 `pathname`이 시스템에서 사용 중인 (가령 마운트 되어 있는) 블록 장치를 가리킨다.
 
 `EDQUOT`
-:   `O_CREAT`를 지정한 경우에서 파일이 존재하지 않으며 그 파일 시스템 상에서 사용자의 디스크 블록 내지 아이노드 쿼터가 고갈되었다.
+:   `O_CREAT`를 지정한 경우에서 파일이 존재하지 않으며 파일 시스템에서 사용자의 디스크 블록 내지 아이노드 쿼터가 고갈되었다.
 
 `EEXIST`
 :   `pathname`이 이미 존재하는데 `O_CREAT`와 `O_EXCL`을 썼다.
@@ -329,7 +329,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   `O_CREAT`을 설정하지 않았고 지명한 파일이 존재하지 않는다.
 
 `ENOENT`
-:   `pathname`의 어느 디렉터리 요소가 존재하지 않거나 깨진 심볼릭 링크이다.
+:   `pathname`의 어느 디렉터리 부분이 존재하지 않거나 깨진 심볼릭 링크다.
 
 `ENOENT`
 :   `pathname`이 존재하지 않는 디렉터리를 가리키며, `flags`에 `O_TMPFILE`을 `O_WRONLY`나 `O_RDWR`와 함께 지정했는데 이 커널 버전에서 `O_TMPFILE` 기능을 제공하지 않는다.
@@ -344,7 +344,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   `pathname`을 생성해야 하는데 `pathname`을 담은 장치에 새 파일을 위한 공간이 없다.
 
 `ENOTDIR`
-:   `pathname`에서 디렉터리로 쓰인 요소가 실제로는 디렉터리가 아니거나, `O_DIRECTORY`를 지정했는데 `pathname`이 디렉터리가 아니다.
+:   `pathname`에서 디렉터리로 쓰인 부분이 실제로는 디렉터리가 아니거나, `O_DIRECTORY`를 지정했는데 `pathname`이 디렉터리가 아니다.
 
 `ENXIO`
 :   `O_NONBLOCK | O_WRONLY`를 설정했고 지명한 파일이 FIFO인데 그 FIFO를 읽기용으로 열고 있는 프로세스가 없다.
@@ -388,7 +388,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   `dirfd`가 유효한 파일 디스크립터가 아니다.
 
 `ENOTDIR`
-:   `pathname`이 상대 경로명이고 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터이다.
+:   `pathname`이 상대 경로명이고 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터다.
 
 ## VERSIONS
 
@@ -452,7 +452,7 @@ POSIX.1-2008 "synchronized I/O" 옵션에서는 다양한 동기 I/O 형태를 
 
 ### NFS
 
-NFS의 기반이 되는 프로토콜에 여러 부적절한 부분이 있어서 특히 `O_SYNC`와 `O_NDELAY`에 영향을 준다.
+NFS의 기반 프로토콜에 여러 부적합한 점이 있어서 특히 `O_SYNC`와 `O_NDELAY`에 영향을 끼친다.
 
 UID 매핑을 켠 NFS 파일 시스템에서 `open()`이 파일 디스크립터를 반환하고서도 가령 `read(2)` 요청이 `EACCES`로 거부될 수도 있다. 이는 클라이언트에서 `open()`을 수행할 때 권한 검사는 하지만 UID 매핑은 읽기 및 쓰기 요청 때 서버에서 수행하기 때문이다.
 
@@ -470,7 +470,7 @@ FIFO의 읽기 쪽 내지 쓰기 쪽을 여는 동작은 (다른 프로세스나
 
 `openat()`과 디렉터리 파일 디스크립터 인자를 받는 여타 시스템 호출 및 라이브러리 함수들(즉 <tt>[[fexecveat(2)]]</tt>, <tt>[[faccessat(2)]]</tt>, <tt>[[fanotify_mark(2)]]</tt>, <tt>[[fchmodat(2)]]</tt>, <tt>[[fchownat(2)]]</tt>, <tt>[[fspick(2)]]</tt>, <tt>[[fstatat(2)]]</tt>, <tt>[[futimesat(2)]]</tt>, <tt>[[linkat(2)]]</tt>, <tt>[[mkdirat(2)]]</tt>, <tt>[[move_mount(2)]]</tt>, <tt>[[mknodat(2)]]</tt>, <tt>[[name_to_handle_at(2)]]</tt>, <tt>[[open_tree(2)]]</tt>, <tt>[[openat2(2)]]</tt>, <tt>[[readlinkat(2)]]</tt>, <tt>[[renameat(2)]]</tt>, <tt>[[statx(2)]]</tt>, <tt>[[symlinkat(2)]]</tt>, <tt>[[unlinkat(2)]]</tt>, <tt>[[utimensat(2)]]</tt>, <tt>[[mkfifoat(3)]]</tt>, <tt>[[scandirat(3)]]</tt>)은 선행 인터페이스에 있는 두 가지 문제를 다룬다. 여기선 `openat()` 호출을 가지고 설명하지만 다른 인터페이스들의 근거도 비슷하다.
 
-첫째로, 응용에서 `openat()`을 쓰면 현재 작업 디렉터리 아닌 디렉터리의 파일을 `open()`으로 열 때 발생할 수 있는 경쟁 조건을 피할 수 있다. 그 경쟁 조건은 `open()`에 준 디렉터리 선두부의 어느 구성 요소가 `open()` 호출과 동시에 바뀔 수도 있다는 사실에서 온다. 예를 들어 `dir1/dir2/xxx`라는 파일이 존재한다면 `dir1/dir2/xxx.dep`라는 파일을 만들고 싶다고 해 보자. 문제는 존재 여부 검사 단계와 파일 생성 단계 사이에 (심볼릭 링크일 수도 있을) `dir1`이나 `dir2`가 다른 위치를 가리키게 변경될 수도 있다는 것이다. 대상 디렉터리에 대한 파일 디스크립터를 연 다음 그 파일 디스크립터를 (가령) <tt>[[fstatat(2)]]</tt>과 `openat()`의 `dirfd` 인자로 지정한다면 그런 경쟁을 피할 수 있다. `dirfd` 파일 디스크립터 사용에는 다른 이득도 있다.
+첫째로, 응용에서 `openat()`을 쓰면 현재 작업 디렉터리 아닌 디렉터리의 파일을 `open()`으로 열 때 발생할 수 있는 경쟁 조건을 피할 수 있다. 그 경쟁 조건은 `open()`에 준 디렉터리 선두부의 어느 부분이 `open()` 호출과 동시에 바뀔 수도 있다는 사실에서 온다. 예를 들어 `dir1/dir2/xxx`라는 파일이 존재한다면 `dir1/dir2/xxx.dep`라는 파일을 만들고 싶다고 해 보자. 문제는 존재 여부 검사 단계와 파일 생성 단계 사이에 (심볼릭 링크일 수도 있을) `dir1`이나 `dir2`가 다른 위치를 가리키게 변경될 수도 있다는 것이다. 대상 디렉터리에 대한 파일 디스크립터를 연 다음 그 파일 디스크립터를 (가령) <tt>[[fstatat(2)]]</tt>과 `openat()`의 `dirfd` 인자로 지정한다면 그런 경쟁을 피할 수 있다. `dirfd` 파일 디스크립터 사용에는 다른 이득도 있다.
 
 * 디렉터리 이름이 바뀌더라도 파일 디스크립터가 그 디렉터리를 안정적으로 참조한다.
 
@@ -480,7 +480,7 @@ FIFO의 읽기 쪽 내지 쓰기 쪽을 여는 동작은 (다른 프로세스나
 
 이 API들에 쓸 `dirfd` 인자는 `open()`이나 `openat()`으로 (`O_RDONLY` 또는 `O_PATH` 플래그를 써서) 디렉터리를 열어서 얻을 수 있다. 또는 <tt>[[opendir(3)]]</tt>로 만든 디렉터리 스트림에 <tt>[[dirfd(3)]]</tt>를 적용해서 얻을 수도 있다.
 
-이 API들에 `dirfd` 인자로 `AT_FDCWD`를 주거나 경로명이 절대 경로이면 대응하는 전통적 API와 같은 방식으로 경로명 인자를 다룬다. 하지만 이 경우에도 여러 API에는 `flags` 인자가 있어서 대응하는 전통적 API에서 이용할 수 없는 기능들에 접근할 수 있다.
+이 API들에 `dirfd` 인자로 `AT_FDCWD`를 주거나 경로명이 절대 경로면 대응하는 전통적 API와 같은 방식으로 경로명 인자를 다룬다. 하지만 이 경우에도 여러 API에는 `flags` 인자가 있어서 대응하는 전통적 API에서 이용할 수 없는 기능들에 접근할 수 있다.
 
 ### `O_DIRECT`
 
diff --git a/docs/open_by_handle_at(2).md b/docs/open_by_handle_at(2).md
index 0012f7d6..57bfcae3 100644
--- a/docs/open_by_handle_at(2).md
+++ b/docs/open_by_handle_at(2).md
@@ -55,13 +55,13 @@ struct file_handle {
 
 기본적으로 `name_to_handle_at()`에서는 `pathname`이 심볼릭 링크인 경우 따라가지 않고 그 링크 자체에 대한 핸들을 반환한다. `flags`에 `AT_SYMLINK_FOLLOW`를 지정하면 `pathname`이 심볼릭 링크면 따라간다. (그래서 그 링크가 가리키는 파일에 대한 핸들을 반환한다.)
 
-경로명의 마지막 구성 요소가 automount 지점일 때는 `name_to_handle_at()`이 마운트를 유발하지 않는다. 파일 시스템에서 파일 핸들과 automount 지점 모두를 지원할 때 automount 지점에 대한 `name_to_handle_at()` 호출은 `handle_bytes`를 올리지 않은 채 `EOVERFLOW` 오류를 반환하게 된다. 리눅스 4.13 이상에서 NFS를 쓸 때 서버 상의 별도 파일 시스템에 있는 디렉터리에 접근 시 이런 상황이 생길 수 있다. 이 경우에 경로명 끝에 "/"를 덧붙이면 automount를 일으킬 수 있다.
+경로명의 마지막 부분이 automount 지점일 때는 `name_to_handle_at()`이 마운트를 유발하지 않는다. 파일 시스템에서 파일 핸들과 automount 지점 모두를 지원할 때 automount 지점에 대한 `name_to_handle_at()` 호출은 `handle_bytes`를 올리지 않은 채 `EOVERFLOW` 오류를 반환하게 된다. 리눅스 4.13 이상에서 NFS를 쓸 때 서버 상의 별도 파일 시스템에 있는 디렉터리에 접근 시 이런 상황이 생길 수 있다. 이 경우에 경로명 끝에 "/"를 덧붙이면 automount를 일으킬 수 있다.
 
 ### `open_by_handle_at()`
 
 `open_by_handle_at()` 시스템 호출은 앞선 `name_to_handle_at()` 호출이 반환한 파일 핸들인 `handle`이 가리키는 파일을 연다.
 
-`mount_fd` 인자는 `handle`을 해석할 기준이 돼야 하는 마운트 된 파일 시스템 내의 임의 객체(파일, 디렉터리 등)에 대한 파일 디스크립터이다. 호출자의 현재 작업 디렉터리를 뜻하는 특수 값 `AT_FDCWD`를 지정할 수 있다.
+`mount_fd` 인자는 `handle`을 해석할 기준이 돼야 하는 마운트 된 파일 시스템 내의 임의 객체(파일, 디렉터리 등)에 대한 파일 디스크립터다. 호출자의 현재 작업 디렉터리를 뜻하는 특수 값 `AT_FDCWD`를 지정할 수 있다.
 
 `flags` 인자는 <tt>[[open(2)]]</tt>에서와 같다. `handle`이 심볼릭 링크를 가리키는 경우 호출자가 `O_PATH` 플래그를 지정해야 하며, 그 심볼릭 링크를 따라가지 않는다. `O_NOFOLLOW` 플래그는 지정 시 무시한다.
 
diff --git a/docs/ptrace(2).md b/docs/ptrace(2).md
index e08ecefa..99903b5c 100644
--- a/docs/ptrace(2).md
+++ b/docs/ptrace(2).md
@@ -724,7 +724,7 @@ Yama 리눅스 보안 모듈(LSM)이 설치된 (즉 `CONFIG_SECURITY_YAMA`로 
 
     `PTRACE_TRACEME` 사용에 변화가 없다.
 
-1 ("제약된 ptrace") [기본값]
+1 ("제한된 ptrace") [기본값]
 :   `PTRACE_MODE_ATTACH` 검사가 필요한 동작을 수행할 때 호출 프로세스가 대상 프로세스의 사용자 네임스페이스에서 `CAP_SYS_PTRACE` 역능을 가지고 있거나 대상 프로세스와 기정 관계를 가지고 있어야 한다. 기본적으로 기정 관계란 대상 프로세스가 호출자의 자손이어야 한다는 것이다.
 
     대상 프로세스에서 <tt>[[prctl(2)]]</tt> `PR_SET_PTRACER` 동작을 사용해서 그 대상에 `PTRACE_MODE_ATTACH` 동작을 수행할 수 있게 허용할 추가 PID를 선언할 수 있다. 자세한 내용은 커널 소스 파일 `Documentation/admin-guide/LSM/Yama.rst`를 (리눅스 4.13 전에선 `Documentation/security/Yama.txt`를) 보라.
diff --git a/docs/readahead(2).md b/docs/readahead(2).md
index e855449d..a8b900ff 100644
--- a/docs/readahead(2).md
+++ b/docs/readahead(2).md
@@ -15,7 +15,7 @@ ssize_t readahead(int fd, off64_t offset, size_t count);
 
 `readahead()`는 파일에서 미리 읽기를 개시해서 이후의 파일 읽기가 캐시에서 처리되어 디스크 I/O에서 블록 되지 않게 한다. (미리 읽기가 충분히 일찍 개시되었으며 중간에 시스템의 다른 활동이 캐시에서 그 페이지들을 내려 보내지 않았다고 가정한다.)
 
-`fd` 인자는 읽을 파일을 나타내는 파일 디스크립터이다. `offset` 인자는 데이터를 읽기 시작할 지점을 나타내며 `count`는 읽을 바이트 수를 나타낸다. I/O가 페이지 단위로 수행되므로 실질적으로는 `offset`을 페이지 경계로 내림 하고 `(offset+count)` 이상 되는 위치에 있는 다음 페이지 경계까지의 바이트들을 읽는다. `readahead()`는 파일 끝 너머까지 읽지 않는다. 파일 디스크립터 `fd`가 가리키는 열린 파일 기술 항목의 파일 오프셋이 바뀌지 않는다.
+`fd` 인자는 읽을 파일을 나타내는 파일 디스크립터다. `offset` 인자는 데이터를 읽기 시작할 지점을 나타내며 `count`는 읽을 바이트 수를 나타낸다. I/O가 페이지 단위로 수행되므로 실질적으로는 `offset`을 페이지 경계로 내림 하고 `(offset+count)` 이상 되는 위치에 있는 다음 페이지 경계까지의 바이트들을 읽는다. `readahead()`는 파일 끝 너머까지 읽지 않는다. 파일 디스크립터 `fd`가 가리키는 열린 파일 기술 항목의 파일 오프셋이 바뀌지 않는다.
 
 ## RETURN VALUE
 
diff --git a/docs/realpath(3).md b/docs/realpath(3).md
index ee2afeaa..5f29f988 100644
--- a/docs/realpath(3).md
+++ b/docs/realpath(3).md
@@ -21,7 +21,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 
 ## DESCRIPTION
 
-`realpath()`는 널 종료 문자열 `path`에서 심볼릭 링크를 모두 확장하고 `/./`, `/../`, 중복 '`/`' 문자를 풀어서 정규화 된 절대 경로명을 만들어 낸다. 결과로 나온 경로명을 `resolved_path`가 가리키는 버퍼에 최대 `PATH_MAX` 바이트까지의 널 종료 문자열로 저장한다. 결과 경로에는 심볼릭 링크나 `/./`, `/../` 요소가 없게 된다.
+`realpath()`는 널 종료 문자열 `path`에서 심볼릭 링크를 모두 확장하고 `/./`, `/../`, 중복 '`/`' 문자를 풀어서 정규화 된 절대 경로명을 만들어 낸다. 결과로 나온 경로명을 `resolved_path`가 가리키는 버퍼에 최대 `PATH_MAX` 바이트까지의 널 종료 문자열로 저장한다. 결과 경로에는 심볼릭 링크나 `/./`, `/../` 부분이 없게 된다.
 
 `resolved_path`를 NULL로 지정하면 `realpath()`에서 <tt>[[malloc(3)]]</tt>을 사용해 풀린 경로명을 담을 최대 `PATH_MAX` 바이트 버퍼를 할당하고 그 버퍼의 포인터를 반환한다. 호출자가 <tt>[[free(3)]]</tt>를 써서 그 버퍼를 해제해야 한다.
 
@@ -34,7 +34,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 ## ERRORS
 
 `EACCES`
-:   경로 선두부의 어느 요소에 대해 읽기 내지 탐색 권한이 거부되었다.
+:   경로 선두부의 어느 부분에 대해 읽기 내지 탐색 권한이 거부되었다.
 
 `EINVAL`
 :   `path`가 NULL이다. (glibc 버전 2.3 전에서는 `resolved_path`가 NULL인 경우에도 이 오류를 반환한다.)
@@ -46,7 +46,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   경로명을 변환하는 동안 너무 많은 심볼릭 링크를 만났다.
 
 `ENAMETOOLONG`
-:   경로명의 어느 요소가 `NAME_MAX` 글자를 넘었다. 또는 전체 경로명이 `PATH_MAX` 글자를 넘었다.
+:   경로명의 어느 부분이 `NAME_MAX` 글자를 넘었다. 또는 전체 경로명이 `PATH_MAX` 글자를 넘었다.
 
 `ENOENT`
 :   해당 파일이 존재하지 않는다.
@@ -55,7 +55,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   메모리 부족.
 
 `ENOTDIR`
-:   경로 선두부의 한 요소가 디렉터리가 아니다.
+:   경로 선두부의 한 부분이 디렉터리가 아니다.
 
 ## ATTRIBUTES
 
diff --git a/docs/recv(2).md b/docs/recv(2).md
index d092da97..fa1ec3d0 100644
--- a/docs/recv(2).md
+++ b/docs/recv(2).md
@@ -183,7 +183,7 @@ struct cmsghdr {
 :   소켓이 논블로킹으로 표시돼 있는데 수신 동작이 블록 되려 했거나, 수신 타임아웃이 설정돼 있는데 데이터 수신 전에 타임아웃이 만료됐다. POSIX.1에서는 이 경우에 어느 쪽 오류도 반환할 수 있다고 허용한다. 따라서 이식성이 있어야 하는 응용에서는 두 가능성을 모두 확인해야 한다.
 
 `EBADF`
-:   인자 `sockfd`가 유효하지 않은 파일 디스크립터이다.
+:   인자 `sockfd`가 유효하지 않은 파일 디스크립터다.
 
 `ECONNREFUSED`
 :   원격 호스트가 네트워크 연결 허용을 거부했다. (보통은 요청한 서비스가 동작 중이지 않기 때문이다.)
diff --git a/docs/recvmmsg(2).md b/docs/recvmmsg(2).md
index d2092dce..4c611433 100644
--- a/docs/recvmmsg(2).md
+++ b/docs/recvmmsg(2).md
@@ -16,7 +16,7 @@ int recvmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen,
 
 `recvmmsg()` 시스템 호출은 <tt>[[recvmsg(2)]]</tt>를 확장한 것이다. 호출자가 시스템 호출 한 번으로 소켓에서 여러 메시지를 수신할 수 있게 해 준다. (일부 응용에서 성능상 이점이 있다.) 또 <tt>[[recvmsg(2)]]</tt>를 확장해서 수신 동작의 타임아웃을 지원한다.
 
-`sockfd` 인자는 데이터를 수신할 소켓의 파일 디스크립터이다.
+`sockfd` 인자는 데이터를 수신할 소켓의 파일 디스크립터다.
 
 `msgvec` 인자는 `mmsghdr` 구조체 배열의 포인터이다. 이 배열의 크기를 `vlen`에 지정한다.
 
diff --git a/docs/seccomp(2).md b/docs/seccomp(2).md
index 90afc4ad..69781516 100644
--- a/docs/seccomp(2).md
+++ b/docs/seccomp(2).md
@@ -269,7 +269,7 @@ seccomp 필터가 반환할 수 있는 행위 값들을 우선도 역순으로 
 
 ### seccomp BPF 아키텍처 지원
 
-다음 아키텍처들에서 seccomp BPF 필터링 아키텍처 지원이 사용 가능하다.
+다음 아키텍처들에서 seccomp BPF 필터링 아키텍처 지원을 이용 가능하다.
 
 * x86-64, i386, x32 (리눅스 3.5부터)
 * ARM (리눅스 3.8부터)
diff --git a/docs/send(2).md b/docs/send(2).md
index 3b0d7304..e8fcbe4f 100644
--- a/docs/send(2).md
+++ b/docs/send(2).md
@@ -29,7 +29,7 @@ send(sockfd, buf, len, flags);
 sendto(sockfd, buf, len, flags, NULL, 0);
 ```
 
-`sockfd` 인자는 송신 소켓의 파일 디스크립터이다.
+`sockfd` 인자는 송신 소켓의 파일 디스크립터다.
 
 `sendto()`를 연결 모드 (`SOCK_STREAM`, `SOCK_SEQPACKET`) 소켓에 쓰면 `dest_addr` 및 `addrlen` 인자를 무시하며 (두 인자가 NULL과 0이 아니면 `EISCONN`을 반환할 수도 있음), 소켓이 실제로 연결돼 있지 않은 경우 `ENOTCONN` 오류를 반환한다. 그 외 경우에는 `dest_addr`이 대상의 주소이고 `addrlen`이 그 크기를 나타낸다. `sendmsg()`에서는 `msg.msg_name`이 대상의 주소이고 `msg.msg_namelen`이 그 크기를 나타낸다.
 
diff --git a/docs/sendmmsg(2).md b/docs/sendmmsg(2).md
index 45498009..0529dc30 100644
--- a/docs/sendmmsg(2).md
+++ b/docs/sendmmsg(2).md
@@ -16,7 +16,7 @@ int sendmmsg(int sockfd, struct mmsghdr *msgvec, unsigned int vlen,
 
 `sendmmsg()` 시스템 호출은 <tt>[[sendmsg(2)]]</tt>를 확장한 것이다. 호출자가 시스템 호출 한 번으로 소켓에서 여러 메시지를 전송할 수 있게 해 준다. (일부 응용에서 성능상 이점이 있다.)
 
-`sockfd` 인자는 데이터를 송신할 소켓의 파일 디스크립터이다.
+`sockfd` 인자는 데이터를 송신할 소켓의 파일 디스크립터다.
 
 `msgvec` 인자는 `mmsghdr` 구조체 배열의 포인터이다. 이 배열의 크기를 `vlen`에 지정한다.
 
diff --git a/docs/stat(2).md b/docs/stat(2).md
index a30e2cdc..0ab268e9 100644
--- a/docs/stat(2).md
+++ b/docs/stat(2).md
@@ -128,11 +128,11 @@ struct stat {
 
 `fstatat()` 시스템 호출은 파일 정보에 접근하기 위한 범용적 인터페이스로 `stat()`, `lstat()`, `fstat()` 각각의 동작 방식까지 정확하게 제공할 수 있다.
 
-`pathname`에 준 경로명이 상대 경로이면 (상대 경로명에 대해 `stat()` 및 `lstat()`에서 하듯 호출 프로세스의 현재 작업 디렉터리를 기준으로 하는 게 아니라) 파일 디스크립터 `dirfd`가 가리키는 디렉터리를 기준으로 경로명을 해석한다.
+`pathname`에 준 경로명이 상대 경로면 (`stat()` 및 `lstat()`에서 하듯 호출 프로세스의 현재 작업 디렉터리를 기준으로 하는 게 아니라) 파일 디스크립터 `dirfd`가 가리키는 디렉터리를 기준으로 경로명을 해석한다.
 
 `pathname`이 상대 경로이고 `dirfd`가 특수 값 `AT_FDCWD`이면 (`stat()` 및 `lstat()`처럼) 호출 프로세스의 현재 작업 디렉터리를 기준으로 `pathname`을 해석한다.
 
-`pathname`이 절대 경로이면 `dirfd`를 무시한다.
+`pathname`이 절대 경로면 `dirfd`를 무시한다.
 
 `flags`는 0일 수도 있고 다음 플래그를 1개 이상 OR 해서 담을 수도 있다.
 
@@ -140,7 +140,7 @@ struct stat {
 :   `pathname`이 빈 문자열이면 (<tt>[[open(2)]]</tt> `O_PATH` 플래그로 얻은 것일 수도 있는) `dirfd`가 가리키는 파일에 대해 동작한다. 이 경우에 `dirfd`는 디렉터리만이 아니라 임의 종류의 파일을 가리킬 수 있으며 `fstatat()`의 동작 방식은 `fstat()`과 비슷하다. `dirfd`가 `AT_FDCWD`이면 현재 작업 디렉터리에 대해 호출이 동작한다. 이 플래그는 리눅스 전용이다. 이 정의를 얻으려면 `_GNU_SOURCE`를 정의해야 한다.
 
 `AT_NO_AUTOMOUNT` (리눅스 2.6.38부터)
-:   `pathname`의 마지막 요소("basename")가 자동 마운트 지점인 디렉터리인 경우에 자동 마운트를 하지 않는다. 이를 통해 (마운트 될 위치가 아니라) 자동 마운트 지점의 속성들을 호출자가 얻을 수 있다. 또한 리눅스 4.14부터는 automounter 간접 맵 등에 쓰이는 on-demand 디렉터리에 실재하지 않는 이름을 만들어 내지 않는다. 마운트 지점에 이미 마운트가 됐으면 이 플래그가 아무 효력이 없다.
+:   `pathname`의 마지막 부분("basename")이 자동 마운트 지점인 디렉터리인 경우에 자동 마운트를 하지 않는다. 이를 통해 (마운트 될 위치가 아니라) 자동 마운트 지점의 속성들을 호출자가 얻을 수 있다. 또한 리눅스 4.14부터는 automounter 간접 맵 등에 쓰이는 on-demand 디렉터리에 실재하지 않는 이름을 만들어 내지 않는다. 마운트 지점에 이미 마운트가 됐으면 이 플래그가 아무 효력이 없다.
 
     `stat()`과 `lstat()` 모두 `AT_NO_AUTOMOUNT`가 설정된 것처럼 동작한다.
 
@@ -175,7 +175,7 @@ struct stat {
 :   `pathname`이 너무 길다.
 
 `ENOENT`
-:   `pathname`의 어느 요소가 존재하지 않거나 깨진 심볼릭 링크이다.
+:   `pathname`의 어느 부분이 존재하지 않거나 깨진 심볼릭 링크다.
 
 `ENOENT`
 :   `pathname`이 빈 문자열인데 `flags`에 `AT_EMPTY_PATH`를 지정하지 않았다.
@@ -184,7 +184,7 @@ struct stat {
 :   메모리 (즉 커널 메모리) 부족.
 
 `ENOTDIR`
-:   `pathname`의 경로 선두부의 어느 요소가 디렉터리가 아니다.
+:   `pathname`의 경로 선두부의 어느 부분이 디렉터리가 아니다.
 
 `EOVERFLOW`
 :   `pathname`이나 `fd`가 그 크기, 아이노드 번호, 블록 수를 각기 `off_t`, `ino_t`, `blkcnt_t` 타입으로 표현할 수 없는 파일을 가리키고 있다. 예를 들어 32비트 플랫폼에서 `-D_FILE_OFFSET_BITS=64` 없이 컴파일 한 응용이 크기가 `(1<<31)-1` 바이트를 넘는 파일을 열려고 하는 경우에 이 오류가 발생할 수 있다.
@@ -198,7 +198,7 @@ struct stat {
 :   `flags`에 유효하지 않은 플래그를 지정했다.
 
 `ENOTDIR`
-:   `pathname`이 상대 경로인데 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터이다.
+:   `pathname`이 상대 경로인데 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터다.
 
 ## VERSIONS
 
diff --git a/docs/statfs(2).md b/docs/statfs(2).md
index 96c88668..93debc5d 100644
--- a/docs/statfs(2).md
+++ b/docs/statfs(2).md
@@ -131,19 +131,19 @@ _XIAFS_SUPER_MAGIC    0x012fd16d /* 리눅스 2.0 및 이전 */
 `f_flags` 필드는 파일 시스템 마운트 옵션을 나타내는 비트 마스크이다. 다음 비트를 0개 이상 담는다.
 
 `ST_MANDLOCK`
-:   파일 시스템 상에서 강제적 락킹을 허용한다. (<tt>[[fcntl(2)]]</tt> 참고.)
+:   파일 시스템에서 강제적 락킹을 허용한다. (<tt>[[fcntl(2)]]</tt> 참고.)
 
 `ST_NOATIME`
 :   접근 시간을 갱신하지 않는다. <tt>[[mount(2)]]</tt> 참고.
 
 `ST_NODEV`
-:   파일 시스템 상에서 장치 특수 파일에 대한 접근을 불허한다.
+:   파일 시스템에서 장치 특수 파일에 대한 접근을 불허한다.
 
 `ST_NODIRATIME`
 :   디렉터리 접근 시간을 갱신하지 않는다. <tt>[[mount(2)]]</tt> 참고.
 
 `ST_NOEXEC`
-:   파일 시스템 상에서 프로그램 실행을 불허한다.
+:   파일 시스템에서 프로그램 실행을 불허한다.
 
 `ST_NOSUID`
 :   파일 시스템 상의 실행 파일에 대해 <tt>[[exec(3)]]</tt>에서 set-user-ID 및 set-group-ID 비트를 무시한다.
@@ -173,7 +173,7 @@ _XIAFS_SUPER_MAGIC    0x012fd16d /* 리눅스 2.0 및 이전 */
 ## ERRORS
 
 `EACCES`
-:   (`statfs()`) `path`의 경로 선두부의 어느 요소에 대해 탐색 권한이 거부되었다. (<tt>[[path_resolution(7)]]</tt>도 참고.)
+:   (`statfs()`) `path`의 경로 선두부의 어느 부분에 대해 탐색 권한이 거부되었다. (<tt>[[path_resolution(7)]]</tt>도 참고.)
 
 `EBADF`
 :   (`fstatfs()`) `fd`가 유효한 열린 파일 디스크립터가 아니다.
@@ -203,7 +203,7 @@ _XIAFS_SUPER_MAGIC    0x012fd16d /* 리눅스 2.0 및 이전 */
 :   파일 시스템에서 이 호출을 지원하지 않는다.
 
 `ENOTDIR`
-:   (`statfs()`) `path`의 경로 선두부의 한 요소가 디렉터리가 아니다.
+:   (`statfs()`) `path`의 경로 선두부의 한 부분이 디렉터리가 아니다.
 
 `EOVERFLOW`
 :   일부 값이 너무 커서 반환 구조체로 표현할 수 없다.
diff --git a/docs/statvfs(3).md b/docs/statvfs(3).md
index 8dccc5a4..b2bdcf21 100644
--- a/docs/statvfs(3).md
+++ b/docs/statvfs(3).md
@@ -38,19 +38,19 @@ struct statvfs {
 `f_flag` 필드는 이 파일 시스템을 마운트 할 때 사용한 여러 옵션들을 나타내는 비트 마스크이다. 다음 비트를 0개 이상 담는다.
 
 `ST_MANDLOCK`
-:   파일 시스템 상에서 강제적 락킹을 허용한다. (<tt>[[fcntl(2)]]</tt> 참고.)
+:   파일 시스템에서 강제적 락킹을 허용한다. (<tt>[[fcntl(2)]]</tt> 참고.)
 
 `ST_NOATIME`
 :   접근 시간을 갱신하지 않는다. <tt>[[mount(2)]]</tt> 참고.
 
 `ST_NODEV`
-:   파일 시스템 상에서 장치 특수 파일에 대한 접근을 불허한다.
+:   파일 시스템에서 장치 특수 파일에 대한 접근을 불허한다.
 
 `ST_NODIRATIME`
 :   디렉터리 접근 시간을 갱신하지 않는다. <tt>[[mount(2)]]</tt> 참고.
 
 `ST_NOEXEC`
-:   파일 시스템 상에서 프로그램 실행을 불허한다.
+:   파일 시스템에서 프로그램 실행을 불허한다.
 
 `ST_NOSUID`
 :   파일 시스템 상의 실행 파일에 대해 <tt>[[exec(3)]]</tt>에서 set-user-ID 및 set-group-ID 비트를 무시한다.
@@ -75,7 +75,7 @@ struct statvfs {
 ## ERRORS
 
 `EACCES`
-:   (`statvfs()`) `path`의 경로 선두부의 어느 요소에 대해 탐색 권한이 거부되었다. (<tt>[[path_resolution(7)]]</tt>도 참고.)
+:   (`statvfs()`) `path`의 경로 선두부의 어느 부분에 대해 탐색 권한이 거부되었다. (<tt>[[path_resolution(7)]]</tt>도 참고.)
 
 `EBADF`
 :   (`fstatvfs()`) `fd`가 유효한 열린 파일 디스크립터가 아니다.
@@ -105,7 +105,7 @@ struct statvfs {
 :   파일 시스템에서 이 호출을 지원하지 않는다.
 
 `ENOTDIR`
-:   (`statvfs()`) `path`의 경로 선두부의 한 요소가 디렉터리가 아니다.
+:   (`statvfs()`) `path`의 경로 선두부의 한 부분이 디렉터리가 아니다.
 
 `EOVERFLOW`
 :   일부 값이 너무 커서 반환 구조체로 표현할 수 없다.
diff --git a/docs/statx(2).md b/docs/statx(2).md
index 2cfb5eb4..cf886b65 100644
--- a/docs/statx(2).md
+++ b/docs/statx(2).md
@@ -91,7 +91,7 @@ struct statx_timestamp {
     이 플래그는 리눅스 전용이다. 이 정의를 얻으려면 `_GNU_SOURCE`를 정의해야 한다.
 
 `AT_NO_AUTOMOUNT`
-:   `pathname`의 마지막 요소("basename")가 자동 마운트 지점인 디렉터리인 경우에 자동 마운트를 하지 않는다. 이를 통해 (마운트 될 위치가 아니라) 자동 마운트 지점의 속성들을 호출자가 얻을 수 있다. 디렉터리들을 훑는 도구들에서 이 플래그를 사용해서 자동 마운트 지점인 디렉터리를 잔뜩 자동 마운트 하는 걸 방지할 수 있다. 마운트 지점에 이미 마운트가 됐으면 `AT_NO_AUTOMOUNT` 플래그에 아무 효력이 없다. 이 플래그는 리눅스 전용이다. 이 정의를 얻으려면 `_GNU_SOURCE`를 정의해야 한다.
+:   `pathname`의 마지막 부분("basename")이 자동 마운트 지점인 디렉터리인 경우에 자동 마운트를 하지 않는다. 이를 통해 (마운트 될 위치가 아니라) 자동 마운트 지점의 속성들을 호출자가 얻을 수 있다. 디렉터리들을 훑는 도구들에서 이 플래그를 사용해서 자동 마운트 지점인 디렉터리를 잔뜩 자동 마운트 하는 걸 방지할 수 있다. 마운트 지점에 이미 마운트가 됐으면 `AT_NO_AUTOMOUNT` 플래그에 아무 효력이 없다. 이 플래그는 리눅스 전용이다. 이 정의를 얻으려면 `_GNU_SOURCE`를 정의해야 한다.
 
 `AT_SYMLINK_NOFOLLOW`
 :   `pathname`이 심볼릭 링크인 경우 따라가지 않는다. 대신 `lstat()`처럼 링크 자체에 대한 정보를 반환한다.
@@ -255,13 +255,13 @@ struct statx_timestamp {
 :   `pathname`이 너무 길다.
 
 `ENOENT`
-:   `pathname`의 어느 요소가 존재하지 않거나, `pathname`이 빈 문자열인데 `flags`에 `AT_EMPTY_PATH`를 지정하지 않았다.
+:   `pathname`의 어느 부분이 존재하지 않거나, `pathname`이 빈 문자열인데 `flags`에 `AT_EMPTY_PATH`를 지정하지 않았다.
 
 `ENOMEM`
 :   메모리 (즉 커널 메모리) 부족.
 
 `ENOTDIR`
-:   `pathname`의 경로 선두부의 어느 요소가 디렉터리가 아니거나, `pathname`이 상대 경로인데 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터이다.
+:   `pathname`의 경로 선두부의 어느 부분이 디렉터리가 아니거나, `pathname`이 상대 경로인데 `dirfd`가 디렉터리 아닌 파일을 가리키는 파일 디스크립터다.
 
 ## VERSIONS
 
diff --git a/docs/tc-bpf(8).md b/docs/tc-bpf(8).md
index e7414030..55752f57 100644
--- a/docs/tc-bpf(8).md
+++ b/docs/tc-bpf(8).md
@@ -84,7 +84,7 @@ eBPF 에이전트 코드를 포함한 제대로 된 예를 iproute2  소스 패
 echo 1 > /proc/sys/net/core/bpf_jit_enable
 ```
 
-LLVM을 통해 제약된 C 파일을 컴파일 할 수 있다.
+LLVM을 통해 제한된 C 파일을 컴파일 할 수 있다.
 
 ```sh
 clang -O2 -emit-llvm -c bpf.c -o - | llc -march=bpf -filetype=obj -o bpf.o
@@ -120,7 +120,7 @@ char __license[] __section("license") = "GPL";
 
 아래 **eBPF 프로그래밍** 부절에서 더 많은 예를 볼 수 있다. 여기선 도구에 집중한다.
 
-행위 등을 위한 다양한 섹션들이 더 있을 수 있다. 그래서 eBPF로 된 오브젝트 파일에 여러 진입점이 있을 수 있다. 하지만 tc로 설정할 때는 구체적 진입점을 명시해야 한다. 그리고 제약된 C 코드에 라이선스가 포함되어야 하며 라이선스 문자열 문법은 리눅스 커널 모듈에서와 같다. 커널은 일부 eBPF 함수들을 GPL 호환 라이선스로만 제약할 권한을 가지며, 그래서 그런 라이선스 불일치 발생 시 프로그램을 커널로 적재하는 것을 거절할 수도 있다.
+행위 등을 위한 다양한 섹션들이 더 있을 수 있다. 그래서 eBPF로 된 오브젝트 파일에 여러 진입점이 있을 수 있다. 하지만 tc로 설정할 때는 구체적 진입점을 명시해야 한다. 그리고 제한된 C 코드에 라이선스가 포함되어야 하며 라이선스 문자열 문법은 리눅스 커널 모듈에서와 같다. 커널은 일부 eBPF 함수들을 GPL 호환 라이선스로만 제약할 권한을 가지며, 그래서 그런 라이선스 불일치 발생 시 프로그램을 커널로 적재하는 것을 거절할 수도 있다.
 
 컴파일 해서 나오는 오브젝트 파일은 일반 오브젝트 파일에 사용하는 평범한 도구들로 살펴볼 수 있다. 가령 <tt>[[objdump(1)]]</tt>로 ELF 섹션 헤더들을 살펴볼 수 있다.
 
@@ -225,7 +225,7 @@ eBPF 에이전트를 이용하면 사용자 공간에서 eBPF 맵을 미리 채
 
 ### eBPF 프로그래밍
 
-eBPF 분류자와 행위는 제약된 C 문법으로 구현한다. (향후 새로운 언어 프론트엔드가 추가로 지원될 수도 있다.)
+eBPF 분류자와 행위는 제한된 C 문법으로 구현한다. (향후 새로운 언어 프론트엔드가 추가로 지원될 수도 있다.)
 
 헤더 파일 `linux/bpf.h`에 eBPF 프로그램에서 호출할 수 있는 eBPF 헬퍼 함수들이 있다. 이 맨 페이지에서는 최소한의 단독 예시 두 가지만 제공한다. eBPF의 가능성을 더 잘 보여 주는 제대로 된 흐름 분석 프로그램을 보려면 iproute2 소스 패키지의 `examples/bpf`를 살펴보면 된다.
 
@@ -244,7 +244,7 @@ eBPF 분류자와 행위는 제약된 C 문법으로 구현한다. (향후 새
 
 분류자 반환 코드와 행위 반환 코드 모두를 eBPF 및 eBPF 프로그램에서 사용할 수 있다.
 
-조그만 분류기 예시를 통해 제약된 C 문법을 살펴보자. 여기선 가령 컨테이너에서 출발한 출력 패킷들에 [0, 255] 범위로 이미 표시가 되어 있다고 가정한다. 이 프로그램은 사용자 공간을 위해 표시 값에 대한 통계를 내며 표시 값 자체를 부 핸들로 해서 루트 qdisc로 classid를 매핑 한다.
+조그만 분류기 예시를 통해 제한된 C 문법을 살펴보자. 여기선 가령 컨테이너에서 출발한 출력 패킷들에 [0, 255] 범위로 이미 표시가 되어 있다고 가정한다. 이 프로그램은 사용자 공간을 위해 표시 값에 대한 통계를 내며 표시 값 자체를 부 핸들로 해서 루트 qdisc로 classid를 매핑 한다.
 
 ```c
 #include <stdint.h>
@@ -428,7 +428,7 @@ modprobe test_bpf
 
 마찬가지로 앞서 언급한 것처럼 `bpf_jit_enable` 스위치를 켤 수 있다. `bpf_jit_disasm` 같은 도구도 eBPF와 cBPF 어느 쪽 코드를 적재하려는지와 무관하다.
 
-eBPF에서처럼 분류자와 행위를 제약된 C로 구현하지 않고 단순한 어셈블리 비슷한 언어로, 또는 다른 도구의 도움으로 구현한다.
+eBPF에서처럼 분류자와 행위를 제한된 C로 구현하지 않고 단순한 어셈블리 비슷한 언어로, 또는 다른 도구의 도움으로 구현한다.
 
 tc의 저수준 인터페이스는 명령 코드를 직접 받는다. 예를 들어 모든 패킷에 걸려서 기본 classid 1:1을 반환하는 가장 단순한 분류자는 다음과 같다.
 
diff --git a/docs/truncate(2).md b/docs/truncate(2).md
index ed169e9a..bd13f2df 100644
--- a/docs/truncate(2).md
+++ b/docs/truncate(2).md
@@ -45,7 +45,7 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 `truncate()`:
 
 `EACCES`
-:   경로 선두부의 어느 요소에 대해 탐색 권한이 거부되었다. 또는 지정한 파일이 사용자에게 쓰기 가능하지 않다. (<tt>[[path_resolution(7)]]</tt>도 참고.)
+:   경로 선두부의 어느 부분에 대해 탐색 권한이 거부되었다. 또는 지정한 파일이 사용자에게 쓰기 가능하지 않다. (<tt>[[path_resolution(7)]]</tt>도 참고.)
 
 `EFAULT`
 :   `path` 인자가 프로세스에 할당된 주소 공간 밖을 가리키고 있다.
@@ -69,13 +69,13 @@ glibc 기능 확인 매크로 요건 (<tt>[[feature_test_macros(7)]]</tt> 참고
 :   경로명을 변환하는 동안 너무 많은 심볼릭 링크를 만났다.
 
 `ENAMETOOLONG`
-:   경로명의 어느 요소가 255글자를 넘었다. 또는 전체 경로명이 1023글자를 넘었다.
+:   경로명의 어느 부분이 255글자를 넘었다. 또는 전체 경로명이 1023글자를 넘었다.
 
 `ENOENT`
 :   지정한 파일이 존재하지 않는다.
 
 `ENOTDIR`
-:   경로 선두부의 한 요소가 디렉터리가 아니다.
+:   경로 선두부의 한 부분이 디렉터리가 아니다.
 
 `EPERM`
 :   하위 파일 시스템에서 현재 크기 넘게 파일을 확장하는 걸 지원하지 않는다.
diff --git a/docs/utimensat(2).md b/docs/utimensat(2).md
index 114841dd..8571b2eb 100644
--- a/docs/utimensat(2).md
+++ b/docs/utimensat(2).md
@@ -109,10 +109,10 @@ struct timespec {
 :   (`utimensat()`) `pathname`이 너무 길다.
 
 `ENOENT`
-:   (`utimensat()`) `pathname`의 어느 요소가 존재하는 디렉터리나 파일을 가리키지 않거나, `pathname`이 빈 문자열이다.
+:   (`utimensat()`) `pathname`의 어느 부분이 존재하는 디렉터리나 파일을 가리키지 않거나, `pathname`이 빈 문자열이다.
 
 `ENOTDIR`
-:   (`utimensat()`) `pathname`이 상대 경로인데 `dirfd`가 `AT_FDCWD`도 아니고 디렉터리를 가리키는 파일 디스크립터도 아니다. 또는 `pathname`의 한 선두 요소가 디렉터리가 아니다.
+:   (`utimensat()`) `pathname`이 상대 경로인데 `dirfd`가 `AT_FDCWD`도 아니고 디렉터리를 가리키는 파일 디스크립터도 아니다. 또는 `pathname`의 한 선두 부분이 디렉터리가 아니다.
 
 `EPERM`
 :   호출자가 타임스탬프들 중 하나 또는 모두를 현재 시간 아닌 값으로 바꾸려 했거나, 타임스탬프 하나를 현재 시간으로 바꾸고 나머지 타임스탬프는 그대로 두려 했으며, 다음 중 하나이다.
@@ -125,7 +125,7 @@ struct timespec {
 :   파일이 읽기 전용 파일 시스템 상에 있다.
 
 `ESRCH`
-:   (`utimensat()`) `pathname`의 한 선두 요소에 대해 탐색 권한이 거부되었다.
+:   (`utimensat()`) `pathname`의 한 선두 부분에 대해 탐색 권한이 거부되었다.
 
 ## VERSIONS
 
