<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="리눅스 매뉴얼 페이지 일부 한글 번역">
    
    <link rel="canonical" href="https://wariua.github.io/man-pages-ko/mmap(2)/">
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>Mmap(2) - man-pages-ko</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/idea.min.css">
        
    
    <link href="../css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">man-pages-ko</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../section_file/">File</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_ipc/">IPC</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_memory/">Memory</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_network/">Network</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_process/">Process</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_thread/">Thread</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_trouble_shooting/">Trouble Shooting</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_others/">Others</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#name">NAME</a></li>
        <li class="first-level "><a href="#synopsis">SYNOPSIS</a></li>
        <li class="first-level "><a href="#description">DESCRIPTION</a></li>
            <li class="second-level"><a href="#munmap">munmap()</a></li>
                
        <li class="first-level "><a href="#return-value">RETURN VALUE</a></li>
        <li class="first-level "><a href="#errors">ERRORS</a></li>
        <li class="first-level "><a href="#attributes">ATTRIBUTES</a></li>
        <li class="first-level "><a href="#conforming-to">CONFORMING TO</a></li>
        <li class="first-level "><a href="#availability">AVAILABILITY</a></li>
        <li class="first-level "><a href="#notes">NOTES</a></li>
            <li class="second-level"><a href="#map_fixed">MAP_FIXED 안전하게 사용하기</a></li>
                
            <li class="second-level"><a href="#_1">파일 기반 매핑에서의 타임스탬프 변경</a></li>
                
            <li class="second-level"><a href="#huge-tlb">거대 페이지 (Huge TLB) 매핑</a></li>
                
            <li class="second-level"><a href="#c">C 라이브러리/커널 차이</a></li>
                
        <li class="first-level "><a href="#bugs">BUGS</a></li>
        <li class="first-level "><a href="#example">EXAMPLE</a></li>
            <li class="second-level"><a href="#_2">프로그램 소스</a></li>
                
        <li class="first-level "><a href="#see-also">SEE ALSO</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h2 id="name">NAME</h2>
<p>mmap, munmap - 파일이나 장치를 메모리로 맵 하거나 해제하기</p>
<h2 id="synopsis">SYNOPSIS</h2>
<pre><code class="c">#include &lt;sys/mman.h&gt;

void *mmap(void *addr, size_t length, int prot, int flags,
           int fd, off_t offset);
int munmap(void *addr, size_t length);
</code></pre>

<p>기능 확인 매크로 요건에 대한 정보는 NOTES를 보라.</p>
<h2 id="description">DESCRIPTION</h2>
<p><code>mmap()</code>은 호출 프로세스의 가상 주소 공간 안에 새 매핑을 만든다. <code>addr</code>에는 새 매핑의 시작 주소를 지정한다. <code>length</code> 인자는 매핑의 길이(0보다 커야 함)를 나타낸다.</p>
<p><code>addr</code>이 NULL이면 매핑을 생성할 (페이지에 정렬된) 주소를 커널에서 선택한다. 이게 새 매핑을 만드는 가장 이식성 좋은 방식이다. <code>addr</code>이 NULL이 아니면 커널에서 이를 매핑을 둘 위치에 대한 힌트로 받아들인다. 리눅스 커널에선 가까운 페이지 경계로 (하지만 항상 <code>/proc/sys/vm/mmap_min_addr</code>에 지정한 값 이상으로) 정한다. 새 매핑의 주소를 호출 결과로 반환한다.</p>
<p>파일 매핑의 내용은 (익명 매핑과 달리, 아래 <code>MAP_ANONYMOUS</code> 참고) 파일 디스크립터 <code>fd</code>가 가리키는 파일의 (또는 다른 객체의) 오프셋 <code>offset</code>의 <code>length</code> 개 바이트로 채워진다. <code>offset</code>은 <code>sysconf(_SC_PAGE_SIZE)</code>가 반환하는 페이지 크기의 배수여야 한다.</p>
<p><code>mmap()</code> 호출 반환 후에 즉시 <code>fd</code>를 닫을 수 있다. 그렇게 해도 매핑이 무효화되지 않는다.</p>
<p><code>prot</code> 인자는 매핑에 원하는 메모리 보호 방식을 기술한다. (파일의 열기 모드와 충돌하지 않아야 한다.) <code>PROT_NONE</code>이거나 다음 플래그들 중 하나 이상을 비트 OR 한 것이다.</p>
<dl>
<dt><code>PROT_EXEC</code></dt>
<dd>페이지를 실행할 수 있다.</dd>
<dt><code>PROT_READ</code></dt>
<dd>페이지를 읽을 수 있다.</dd>
<dt><code>PROT_WRITE</code></dt>
<dd>페이지에 쓸 수 있다.</dd>
<dt><code>PROT_NONE</code></dt>
<dd>페이지에 접근할 수 없다.</dd>
</dl>
<p><code>flags</code> 인자는 매핑에 대한 갱신 내용이 같은 영역을 맵 하고 있는 다른 프로세스에게 보이는지 여부를, 그리고 그 갱신 내용이 기반 파일까지 가게 되는지 여부를 결정한다. 다음 중 정확히 한 개 값을 <code>flags</code>에 집어넣어서 동작 방식을 정한다.</p>
<dl>
<dt><code>MAP_SHARED</code></dt>
<dd>매핑을 공유한다. 매핑에 대한 갱신 내용이 같은 영역을 맵 하고 있는 다른 프로세스에게 보이며 (파일 기반 매핑인 경우) 그 갱신 내용이 기반 파일까지 간다. (갱신 내용이 기반 파일로 가는 시점을 정확히 제어하려면 <tt>[[msync(2)]]</tt>를 사용해야 한다.)</dd>
<dt><code>MAP_SHARED_VALIDATE</code> (리눅스 4.15부터)</dt>
<dd>이 플래그의 동작 방식은 <code>MAP_SHARED</code>와 같되, <code>MAP_SHARED</code> 매핑에서는 <code>flags</code>에 모르는 플래그가 있으면 무시한다는 점이 다르다. 반면 <code>MAP_SHARED_VALIDATE</code>로 매핑을 만들 때는 전달된 플래그들이 모두 알려진 것인지 커널에서 검사해서 모르는 플래그가 있으면 <code>EOPNOTSUPP</code> 오류로 매핑이 실패한다. 또 일부 매핑 플래그(가령 <code>MAP_SYNC</code>)를 사용하려면 이 매핑 유형이 필요하다.</dd>
<dt><code>MAP_PRIVATE</code></dt>
<dd>비공유 copy-on-write 매핑을 만든다. 매핑에 대한 갱신 내용이 같은 파일을 맵 하고 있는 다른 프로세스에게 보이지 않으며 기반 파일까지 가지 않는다. <code>mmap()</code> 호출 후에 파일에서 일어난 변경 내용이 맵 된 영역에 보이는지 여부는 명세되어 있지 않다.</dd>
</dl>
<p><code>MAP_SHARED</code>와 <code>MAP_PRIVATE</code> 모두 POSIX.1-2001 및 POSIX.1-2008에 기술돼 있다. <code>MAP_SHARED_VALIDATE</code>는 리눅스 확장이다.</p>
<p>더불어 <code>flags</code>에 다음 값들을 0개 이상 OR 할 수 있다.</p>
<dl>
<dt><code>MAP_32BIT</code> (리눅스 2.4.20, 2.6부터)</dt>
<dd>매핑을 프로세스 주소 공간의 처음 2기가바이트 안에 넣는다. x86-64 상에서 64비트 프로그램에만 이 플래그를 지원한다. 스레드 스택을 메모리의 처음 2GB 내의 어딘가에 할당해서 일부 초기 64비트 프로세서들에서 문맥 전환 성능을 개선할 수 있도록 추가된 것이다. 요즘의 x86-64 프로세서에는 이런 성능 문제가 없기 때문에 이 플래그를 쓸 필요가 없다. <code>MAP_FIXED</code>가 설정돼 있는 경우 <code>MAP_32BIT</code> 플래그를 무시한다.</dd>
<dt><code>MAP_ANON</code></dt>
<dd><code>MAP_ANONYMOUS</code>의 동의어. 제거 예정.</dd>
<dt><code>MAP_ANONYMOUS</code></dt>
<dd>매핑이 파일을 기반으로 하지 않으며 내용물이 0으로 채워진다. <code>fd</code> 인자를 무시한다. 하지만 일부 구현에서는 <code>MAP_ANONYMOUS</code> (또는 <code>MAP_ANON</code>) 지정 시 <code>fd</code>가 -1이기를 요구하므로 이식 가능한 응용에서는 그렇게 하는 게 좋다. <code>offset</code> 인자는 0이어야 할 것이다. <code>MAP_ANONYMOUS</code>를 <code>MAP_SHARED</code>와 결합해 쓰는 것은 리눅스 커널 2.4부터 지원한다.</dd>
<dt><code>MAP_DENYWRITE</code></dt>
<dd>이 플래그는 무시한다. (예전에는 (리눅스 2.0 및 그 전에서는) 기반 파일에 대한 쓰기가 <code>ETXTBUSY</code>로 실패해야 한다는 뜻이었다. 하지만 서비스 거부 공격의 원인이 됐다.)</dd>
<dt><code>MAP_EXECUTABLE</code></dt>
<dd>이 플래그는 무시한다.</dd>
<dt><code>MAP_FILE</code></dt>
<dd>호환용 플래그. 무시한다.</dd>
<dt><code>MAP_FIXED</code></dt>
<dd>
<p><code>addr</code>을 힌트로 해석하지 않는다. 즉 정확히 그 주소에 매핑을 위치시킨다. <code>addr</code>이 적절히 정렬돼 있어야 한다. 대부분의 아키텍처에서는 페이지 크기의 배수이면 충분하지만 어떤 아키텍처에서는 추가 제약이 있을 수 있다. <code>addr</code>과 <code>len</code>으로 지정한 메모리 영역이 기존 매핑(들)의 페이지와 겹치는 경우에는 기존 매핑의 겹치는 부분을 버리게 된다. 지정한 주소를 사용할 수 없으면 <code>mmap()</code>이 실패하게 된다.</p>
<p>이식성이 있기를 바라는 소프트웨어에서는 <code>MAP_FIXED</code> 플래그를 조심해서 사용해야 한다. 프로세스 메모리 매핑들의 정확한 배치가 커널 버전, C 라이브러리 버전, 운영 체제 릴리스에 따라 크게 다를 수 있다는 점에 유념해야 한다. <em>NOTES에 있는 이 플래그에 대한 내용을 주의해서 읽어 보라!</em></p>
</dd>
<dt><code>MAP_FIXED_NOREPLACE</code> (리눅스 4.17부터)</dt>
<dd>
<p>이 플래그의 동작 방식은 <code>addr</code> 강제라는 점에서 <code>MAP_FIXED</code>와 비슷한데, <code>MAP_FIXED_NOREPLACE</code>는 절대 기존 매핑 범위를 손상시키지 않는다는 점이 다르다. 요청 범위가 기존 매핑과 충돌하려는 경우에 이 호출은 <code>EEXIST</code> 오류로 실패한다. 따라서 이 플래그를 사용하면 (다른 스레드들에 대해) 원자적으로 주소 범위 매핑을 시도할 수 있다. 한 스레드만 성공하고 나머지는 실패를 보고하게 된다.</p>
<p>참고로 <code>MAP_FIXED_NOREPLACE</code> 플래그를 인식하지 못하는 구식 커널들은 (기존 매핑과의 충돌을 탐지했을 때) 보통 "비-<code>MAP_FIXED</code>" 동작 방식으로 후퇴하게 된다. 즉 요청한 주소와 다른 주소를 반환하게 된다. 따라서 하위 호환성 있는 소프트웨어에서는 반환 주소가 요청 주소와 같은지 확인할 필요가 있다.</p>
</dd>
<dt><code>MAP_GROWSDOWN</code></dt>
<dd>스택에 쓰는 플래그다. 매핑이 메모리에서 아래 방향으로 늘어나야 한다고 커널 가상 메모리 시스템에게 알린다. 반환 주소는 프로세스 가상 주소 공간에 실제 생성한 메모리 영역보다 한 페이지 아래의 주소이다. 매핑 아래의 그 "방호 구역" 페이지 내의 주소를 건드리면 매핑이 한 페이지만큼 성장하게 된다. 그 성장이 반복될 수 있으며, 매핑이 아래쪽 다음 매핑의 최상단 페이지로 성장해야 하는 시점에 "방호 구역" 페이지를 건드리면 <code>SIGSEGV</code> 시그널이 발생하게 된다.</dd>
<dt><code>MAP_HUGETLB</code> (리눅스 2.6.32부터)</dt>
<dd>"거대 페이지"로 매핑을 할당한다. 자세한 내용은 리눅스 커널 소스 파일 <code>Documentation/admin-guide/mm/hugetlbpage.rst</code>를 보라. 아래 NOTES도 참고.</dd>
<dt><code>MAP_HUGE_2MB</code>, <code>MAP_HUGE_1GB</code> (리눅스 4.8부터)</dt>
<dd>
<p>여러 가지 hugetlb 페이지 크기를 지원하는 시스템에서 <code>MAP_HUGETLB</code>와 조합해 사용해서 다른 hugetlb 페이지 크기(각각 2MB와 1GB)를 선택한다.</p>
<p>더 일반적으로는 오프셋 <code>MAP_HUGE_SHIFT</code>의 여섯 비트에 원하는 페이지 크기의 밑수 2 로그를 인코딩 해서 원하는 거대 페이지 크기를 설정할 수 있다. (이 비트 필드에서 0 값은 기본 거대 페이지 크기이다. 기본 거대 페이지 크기는 <code>/proc/meminfo</code>에 나오는 <code>Hugepagesize</code> 필드를 통해 알 수 있다.) 따라서 위 두 상수는 다음과 같이 정의돼 있다.</p>
<pre><code>#define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)
#define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)
</code></pre>
<p><code>/sys/kernel/mm/hugepages</code>의 하위 디렉터리를 확인하면 시스템에서 지원하는 거대 페이지 크기들을 알 수 있다.</p>
</dd>
<dt><code>MAP_LOCKED</code> (리눅스 2.5.37부터)</dt>
<dd>맵 한 영역을 <tt>[[mlock(2)]]</tt>과 같은 방식으로 고정하게 표시한다. 여기선 전체 범위를 채우려고 (미리 폴트) 시도는 하지만 실패한 경우에 <code>mmap()</code> 호출이 실패하지 않는다. 따라서 이후에 메이저 폴트가 발생할 수도 있다. 즉 <tt>[[mlock(2)]]</tt>만큼 의미론이 강력하지 않다. 매핑 초기화 후의 메이저 폴트를 허용할 수 없다면 <code>mmap()</code>에 <tt>[[mlock(2)]]</tt>을 더해서 쓰는 게 좋다. 구식 커널에서는 <code>MAP_LOCKED</code> 플래그를 무시한다.</dd>
<dt><code>MAP_NONBLOCK</code> (리눅스 2.5.46부터)</dt>
<dd>이 플래그는 <code>MAP_POPULATE</code>와 함께 쓸 때만 의미가 있다. 미리 읽기를 수행하지 않는다. 즉 이미 램 내에 있는 페이지에만 페이지 테이블 항목을 만든다. 리눅스 2.6.23부터는 이 플래그를 쓰면 <code>MAP_POPULATE</code>가 아무것도 하지 않게 된다. 언젠가 <code>MAP_POPULATE</code>와 <code>MAP_NONBLOCK</code>의 조합이 재구현될 수도 있다.</dd>
<dt><code>MAP_NORESERVE</code></dt>
<dd>이 매핑을 위한 스왑 공간을 예비해 두지 않는다. 스왑 공간이 예비돼 있을 때는 매핑을 변경하는 게 가능하다고 보장된다. 스왑 공간이 예비돼 있지 않을 때는 사용 가능한 물리적 메모리가 없으면 쓰기 시 <code>SIGSEGV</code>를 받을 수도 있다. <tt>[[proc(5)]]</tt>의 <code>/proc/sys/vm/overcommit_memory</code> 파일 논의도 참고하라. 2.6 전의 커널에서는 비공유 쓰기 가능 매핑에만 이 플래그가 효과가 있었다.</dd>
<dt><code>MAP_POPULATE</code> (리눅스 2.5.46부터)</dt>
<dd>매핑에 대한 페이지 테이블을 채운다 (미리 폴트). 파일 매핑인 경우 파일에서 미리 읽기를 하게 한다. 이후 페이지 폴트에서 막히는 걸 줄이는 데 도움이 될 것이다. 비공유 매핑에는 리눅스 2.6.23부터 <code>MAP_POPULATE</code>를 지원한다.</dd>
<dt><code>MAP_STACK</code> (리눅스 2.6.27부터)</dt>
<dd>프로세스나 스레드 스택에 적합한 주소에 매핑을 할당한다. 이 플래그는 현재 no-op지만 glibc 스레딩 구현에서 사용하는데, 일부 아키텍처에서 스택 할당에 특별한 처리를 요하는 경우 나중에 투명하게 지원을 구현할 수 있기 위해서다.</dd>
<dt><code>MAP_SYNC</code> (리눅스 4.15부터)</dt>
<dd>
<p>이 플래그는 <code>MAP_SHARED_VALIDATE</code> 매핑 유형에만 사용 가능하다. <code>MAP_SHARED</code> 유형 매핑에서는 이 플래그를 조용히 무시한다. DAX(영속 메모리 직접 매핑) 지원 파일에서만 이 플래그를 지원한다. 그렇지 않은 파일에서 이 플래그로 매핑을 만들려고 하면 <code>EOPNOTSUPP</code> 오류가 발생한다.</p>
<p>이 플래그를 쓴 공유 파일 매핑에서는 프로세스 주소 공간에 어떤 메모리가 쓰기 가능하게 맵 되어 있는 동안에 시스템이 죽거나 재부팅 된 후에도 동일 파일의 동일 오프셋에서 그 내용을 볼 수 있다고 보장된다. 적절한 CPU 인스트럭션과 함께 사용하면 더 효율적인 방식으로 데이터 변경을 영속시키는 매핑이 가능해진다.</p>
</dd>
<dt><code>MAP_UNINITIALIZED</code> (리눅스 2.6.33부터)</dt>
<dd>익명 페이지 내용을 비우지 않는다. 이 플래그는 임베디드 장치에서 성능을 개선하기 위한 것이다. 커널이 <code>CONFIG_MMAP_ALLOW_UNINITIALIZED</code> 옵션으로 구성된 경우에만 이 플래그를 따른다. 보안적 함의 때문에 보통 임베디드 장치에서만 (즉 사용자 메모리 내용물에 완전한 통제가 이뤄지는 장치에서만) 이 옵션을 켠다.</dd>
</dl>
<p>위 플래그들 중 <code>MAP_FIXED</code>만 POSIX.1-2001 및 POSIX.1-2008에 명세되어 있다. 하지만 많은 시스템에서 <code>MAP_ANONYMOUS</code>도 (또는 동의어인 <code>MAP_ANON</code>을) 지원한다.</p>
<p><code>mmap()</code>으로 맵 한 메모리는 <tt>[[fork(2)]]</tt>를 거치며 같은 속성으로 유지된다.</p>
<p>파일은 페이지 크기의 배수로 맵 된다. 파일 크기가 페이지 크기의 배수가 아닌 경우 맵 할 때 나머지 메모리를 0으로 채우며 그 영역에 쓴 것이 파일에 기록되지 않는다. 매핑 기반 파일의 크기가 바뀔 때 파일에 추가되거나 제거되는 영역에 대응하는 페이지들에 어떤 영향을 주는지는 명세되어 있지 않다.</p>
<h3 id="munmap"><code>munmap()</code></h3>
<p><code>munmap()</code> 시스템 호출은 지정한 주소 범위에 대한 매핑을 삭제하고 그 범위 내 주소에 대한 이후 참조가 비유효 메모리 참조를 일으키도록 한다. 프로세스가 종료할 때도 자동으로 해제한다. 반면 파일 디스크립터를 닫는 것으로는 맵을 해제하지 않는다.</p>
<p>주소 <code>addr</code>은 페이지 크기의 배수여야 한다. (<code>length</code>는 그럴 필요가 없다.) 지정한 범위의 일부라도 담은 모든 페이지들이 해제되며 이후 그 페이지들에 대한 참조가 <code>SIGSEGV</code>를 일으키게 된다. 지정한 범위 안에 맵 된 페이지가 없더라도 오류가 아니다.</p>
<h2 id="return-value">RETURN VALUE</h2>
<p>성공 시 <code>mmap()</code>은 맵 한 영역에 대한 포인터를 반환한다. 오류 시 <code>MAP_FAILED</code> 값(즉 <code>(void *) -1</code>)을 반환하며 오류 원인을 나타내도록 <code>errno</code>를 설정한다.</p>
<p>성공 시 <code>munmap()</code>은 0을 반환한다. 실패 시 -1을 반환하며 오류 원인(아마 <code>EINVAL</code>)을 나타내도록 <code>errno</code>를 설정한다.</p>
<h2 id="errors">ERRORS</h2>
<dl>
<dt><code>EACCES</code></dt>
<dd>파일 디스크립터가 비정규 파일을 가리키고 있다. 또는 파일 매핑을 요청했는데 <code>fd</code>가 읽기 가능하게 열려 있지 않다. 또는 <code>MAP_SHARED</code>를 요청했고 <code>PROT_WRITE</code>가 설정돼 있는데 <code>fd</code>가 읽기/쓰기 모드(<code>O_RDWR</code>)로 열려 있지 않다. 또는 <code>PROT_WRITE</code>가 설정돼 있는데 파일이 덧붙임 전용이다.</dd>
<dt><code>EAGAIN</code></dt>
<dd>파일이 잠겨 있거나 너무 많은 메모리가 고정돼 있다. (<tt>[[setrlimit(2)]]</tt> 참고.)</dd>
<dt><code>EBADF</code></dt>
<dd><code>fd</code>가 유효한 파일 디스크립터가 아니다. (그리고 <code>MAP_ANONYMOUS</code>를 설정하지 않았다.)</dd>
<dt><code>EEXIST</code></dt>
<dd><code>flags</code>에 <code>MAP_FIXED_NOREPLACE</code>를 지정했으며 <code>addr</code>과 <code>length</code>가 나타내는 범위가 기존 매핑과 충돌한다.</dd>
<dt><code>EINVAL</code></dt>
<dd><code>addr</code>, <code>length</code>, <code>offset</code>이 마음에 들지 않는다. (가령 너무 크거나 페이지 경계에 정렬돼 있지 않다.)</dd>
<dt><code>EINVAL</code></dt>
<dd>(리눅스 2.6.12부터) <code>length</code>가 0이다.</dd>
<dt><code>EINVAL</code></dt>
<dd><code>flags</code>에 <code>MAP_PRIVATE</code>과 <code>MAP_SHARED</code> 어느 쪽도 없거나 둘 다 포함돼 있다.</dd>
<dt><code>ENFILE</code></dt>
<dd>열린 파일 총개수에 대한 시스템 전역 제한에 도달했다.</dd>
<dt><code>ENODEV</code></dt>
<dd>지정한 파일의 기반 파일 시스템이 메모리 매핑을 지원하지 않는다.</dd>
<dt><code>ENOMEM</code></dt>
<dd>사용 가능한 메모리가 없다.</dd>
<dt><code>ENOMEM</code></dt>
<dd>프로세스의 매핑 최대 개수를 초과하려 했다. <code>munmap()</code>에서도 이 오류가 발생할 수 있는데, 기존 매핑의 중간 부분을 맵 해제하면 그 양쪽으로 작은 매핑 두 개가 생기기 때문이다.</dd>
<dt><code>ENOMEM</code></dt>
<dd>(리눅스 4.7부터) 프로세스의 <code>RLIMIT_DATA</code> 제한(<tt>[[getrlimit(2)]]</tt>에서 설명함)을 초과하려 했다.</dd>
<dt><code>EOVERFLOW</code></dt>
<dd>32비트 아키텍처에 큰 파일 확장(즉 64비트 <code>off_t</code>)을 쓰는 경우: <code>length</code>를 위한 페이지 개수에 <code>offset</code>을 위한 페이지 개수를 더하면 <code>unsigned long</code>(32비트)을 넘게 된다.</dd>
<dt><code>EPERM</code></dt>
<dd><code>prot</code> 인자에서 <code>PROT_EXEC</code>를 요청하는데 맵 영역이 실행 불가능하게 마운트 된 파일 시스템 상의 파일에 속해 있다.</dd>
<dt><code>EPERM</code></dt>
<dd>파일 봉인 때문에 동작이 막혔다. <tt>[[fcntl(2)]]</tt> 참고.</dd>
<dt><code>ETXTBSY</code></dt>
<dd><code>MAP_DENYWRITE</code>가 설정돼 있지만 <code>fd</code>로 지정한 객체가 쓰기 가능하게 열려 있다.</dd>
</dl>
<p>맵 한 영역을 사용할 때 다음 시그널이 발생할 수 있다.</p>
<dl>
<dt><code>SIGSEGV</code></dt>
<dd>읽기 전용으로 맵 한 영역에 쓰기를 시도했다.</dd>
<dt><code>SIGBUG</code></dt>
<dd>파일에 대응하지 않는 버퍼 부분에 접근을 시도했다. (예를 들어 파일 끝 너머에 접근하기. 다른 프로세스가 파일을 잘라내는 경우 포함.)</dd>
</dl>
<h2 id="attributes">ATTRIBUTES</h2>
<p>이 절에서 사용하는 용어들에 대한 설명은 <tt>[[attributes(7)]]</tt>를 보라.</p>
<table>
<thead>
<tr>
<th>인터페이스</th>
<th>속성</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mmap()</code>, <code>munmap()</code></td>
<td>스레드 안전성</td>
<td>MT-Safe</td>
</tr>
</tbody>
</table>
<h2 id="conforming-to">CONFORMING TO</h2>
<p>POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD.</p>
<h2 id="availability">AVAILABILITY</h2>
<p><code>mmap()</code>, <tt>[[msync(2)]]</tt>, <code>munmap()</code>이 사용 가능한 POSIX 시스템에는 <code>&lt;unistd.h&gt;</code>에 <code>_POSIX_MAPPED_FILES</code>가 0보다 큰 값으로 정의되어 있다. (<tt>[[sysconf(3)]]</tt>도 참고.)</p>
<h2 id="notes">NOTES</h2>
<p>일부 하드웨어 아키텍처(가령 i386)에서는 <code>PROT_WRITE</code>가 <code>PROT_READ</code>를 함의한다. 아키텍처에 따라 <code>PROT_READ</code>가 <code>PROT_EXEC</code>를 함의하는지 여부가 다르다. 이식 가능한 프로그램에서는 새 매핑 내의 코드를 실행할 예정이면 항상 <code>PROT_EXEC</code>를 설정하는 게 좋다.</p>
<p>매핑을 만드는 이식성 있는 방법은 <code>addr</code>을 0(NULL)으로 지정하고 <code>flags</code>에서 <code>MAP_FIXED</code>를 빼는 것이다. 이렇게 하는 경우 매핑에 쓸 주소를 시스템이 선택한다. 기존 매핑과 충돌하지 않으며 0이 아니게 주소를 선택한다. <code>MAP_FIXED</code> 플래그를 지정하는 경우 <code>addr</code>이 0(NULL)이면 맵 한 주소가 0(NULL)이 된다.</p>
<p>어떤 <code>flags</code> 상수들은 적절한 기능 확인 매크로가 (때론 기본으로) 정의돼 있는 경우에만 정의돼 있다. glibc 2.19 및 이후에서는 <code>_DEFAULT_SOURCE</code>, glibc 2.19 및 이전에서는 <code>_BSD_SOURCE</code>나 <code>_SVID_SOURCE</code>이다. (<code>_GNU_SOURCE</code> 사용으로도 충분하며, 명확히 이 매크로를 요건으로 하는 게 더 논리적일 수도 있는 것이, 그 플래그들 모두 리눅스 전용이다.) 해당하는 플래그는 <code>MAP_32BIT</code>, <code>MAP_ANONYMOUS</code> (및 동의어인 <code>MAP_ANON</code>), <code>MAP_DENYWRITE</code>, <code>MAP_EXECUTABLE</code>, <code>MAP_FILE</code>, <code>MAP_GROWSDOWN</code>, <code>MAP_HUGETLB</code>, <code>MAP_LOCKED</code>, <code>MAP_NONBLOCK</code>, <code>MAP_NORESERVE</code>, <code>MAP_POPULATE</code>, <code>MAP_STACK</code>이다.</p>
<p>응용에서 <tt>[[mincore(2)]]</tt>를 사용하면 매핑의 어떤 페이지가 현재 버퍼/페이지 캐시에 상주 중인지 알아낼 수 있다.</p>
<h3 id="map_fixed"><code>MAP_FIXED</code> 안전하게 사용하기</h3>
<p><code>MAP_FIXED</code>를 안전하게 쓸 수 있는 유일한 경우는 <code>addr</code>과 <code>length</code>로 지정한 주소 범위가 이미 다른 매핑을 통해 잡혀 있을 때이다. 그 외 경우에서는 <code>MAP_FIXED</code> 사용이 극히 위험한데, 기존에 있던 매핑을 강제로 없애므로 다중 스레드 프로세스에서 자기 주소 공간을 오염시키기 쉽게 되기 때문이다.</p>
<p>예를 들어 스레드 A가 <code>/proc/&lt;pid&gt;/maps</code>를 살펴봐서 <code>MAP_FIXED</code>로 맵 할 수 있는 안 쓰는 주소 범위를 찾는 동안 스레드 B가 동시에 같은 주소 범위의 일부 내지 전체를 획득할 수 있다. 그러고서 스레드 A가 <code>mmap(MAP_FIXED)</code>를 사용하면 스레드 B가 만든 매핑을 실질적으로 손상시키게 된다. 이 경우에서 스레드 B가 꼭 매핑을 직접 생성해야 하는 건 아니다. 내부적으로 <tt>[[dlopen(3)]]</tt>을 써서 어떤 다른 공유 라이브러리를 적재하는 라이브러리 호출을 하는 것만으로 충분하다. 그 <tt>[[dlopen(3)]]</tt> 호출이 라이브러리를 프로세스의 주소 공간으로 맵 하게 된다. 뿐만 아니라 거의 모든 라이브러리 호출이 이 기법이나 단순 메모리 할당을 통해 주소 공간에 메모리 매핑을 추가하도록 구현되어 있을 수 있다. <tt>[[brk(2)]]</tt>, <tt>[[malloc(3)]]</tt>, <tt>[[pthread_create(3)]]</tt>, PAM 라이브러리(http://www.linux-pam.org) 등이 그 예이다.</p>
<p>리눅스 4.17부터는 다중 스레드 프로그램에서 <code>MAP_FIXED_NOREPLACE</code> 플래그를 사용해서 기존 매핑으로 예약돼 있지 않은 고정 주소에 매핑을 만들려 할 때 위에서 설명한 위험을 피할 수 있다.</p>
<h3 id="_1">파일 기반 매핑에서의 타임스탬프 변경</h3>
<p>파일 기반 매핑에서는 <code>mmap()</code>과 대응하는 맵 해제 사이의 어느 시점에도 맵 된 파일의 <code>st_atime</code> 필드가 갱신될 수 있다. 맵 된 페이지에 처음 참조할 때 그 필드가 아직 갱신되지 않았으면 갱신하게 된다.</p>
<p><code>PROT_WRITE</code> 및 <code>MAP_SHARED</code>로 맵 한 파일의 <code>st_ctime</code> 및 <code>st_mtime</code> 필드는 맵 영역에 대한 쓰기 후에, 그리고 이후 <code>MS_SYNC</code> 내지 <code>MS_ASYNC</code> 플래그로 <tt>[[msync(2)]]</tt> 하는 경우 그 전에 갱신된다.</p>
<h3 id="huge-tlb">거대 페이지 (Huge TLB) 매핑</h3>
<p>거대 페이지를 이용하는 매핑에서는 <code>mmap()</code>과 <code>munmap()</code> 인자에 대한 요건이 시스템 기본 페이지 크기를 쓰는 매핑에 대한 요건과 좀 다르다.</p>
<p><code>mmap()</code>에서는 <code>offset</code>이 기반 거대 페이지 크기의 배수여야 한다. 시스템에서 <code>length</code>를 기반 거대 페이지 크기의 배수로 자동으로 맞춘다.</p>
<p><code>munmap()</code>에서는 <code>addr</code>과 <code>length</code>가 모두 기반 거대 페이지 크기의 배수여야 한다.</p>
<h3 id="c">C 라이브러리/커널 차이</h3>
<p>이 페이지에서는 glibc의 <code>mmap()</code> 래퍼 함수가 제공하는 인터페이스를 기술한다. 원래는 그 함수에서 이름이 같은 시스템 호출을 불렀다. 커널 2.4부터 그 시스템 호출이 <tt>[[mmap2(2)]]</tt>로 대체됐고, 그래서 요즘에는 glibc의 <code>mmap()</code> 래퍼 함수에서 적절히 조정한 <code>offset</code> 값으로 <tt>[[mmap2(2)]]</tt>를 부른다.</p>
<h2 id="bugs">BUGS</h2>
<p>리눅스에서는 위의 <code>MAP_NORESERVE</code>에서 언급하는 것들을 보장하지 않는다. 기본적으로 시스템에 메모리가 부족할 때는 언제 어느 프로세스든 죽을 수 있다.</p>
<p>커널 2.6.7 전에서는 <code>prot</code>를 <code>PROT_NONE</code>으로 지정한 경우에만 <code>MAP_POPULATE</code> 플래그에 효력이 있다.</p>
<p>SUSv3에서는 <code>length</code>가 0이면 <code>mmap()</code>이 실패하는 게 좋다고 명세한다. 하지만 커널 2.6.12 전에서는 이 경우에 <code>mmap()</code>이 성공했다. 아무 매핑도 만들지 않고 호출이 <code>addr</code>을 반환했다. 커널 2.6.12부터는 이 경우에 <code>mmap()</code>이 <code>EINVAL</code> 오류로 실패한다.</p>
<p>POSIX에서는 객체 끝의 부분 페이지를 항상 시스템에서 0으로 채워야 하며 객체 끝 너머에서의 변경 내용을 시스템이 절대 기록하지 않는다고 명세한다. 리눅스에서 그런 객체 끝 다음의 부분 페이지에 데이터를 쓰는 경우 파일이 닫히고 맵이 해제된 후에 절대 파일에는 기록되지 않지만 데이터가 페이지 캐시 내에 남아서 이후 매핑에서 그 변경된 내용을 볼 수도 있다. 어떤 경우에는 맵 해제 전에 <tt>[[msync(2)]]</tt>를 호출해서 고칠 수도 있지만 <tt>[[tmpfs(5)]]</tt>에서는 (예를 들어 <tt>[[shm_overview(7)]]</tt>에 기록된 POSIX 공유 메모리 인터페이스를 쓸 때는) 통하지 않는다.</p>
<h2 id="example">EXAMPLE</h2>
<p>다음 프로그램은 첫 번째 명령행 인자에 지정한 파일의 일부를 표준 출력으로 찍는다. 두 번째와 세 번째 명령행 인자의 오프셋 및 길이 값을 통해 찍을 범위를 지정한다. 프로그램에서 파일의 필요한 페이지들로 메모리 매핑을 만든 다음 <code>write(2)</code>를 써서 원하는 바이트들을 출력한다.</p>
<h3 id="_2">프로그램 소스</h3>
<pre><code class="c">#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
    char *addr;
    int fd;
    struct stat sb;
    off_t offset, pa_offset;
    size_t length;
    ssize_t s;

    if (argc &lt; 3 || argc &gt; 4) {
        fprintf(stderr, &quot;%s file offset [length]\n&quot;, argv[0]);
        exit(EXIT_FAILURE);
    }

    fd = open(argv[1], O_RDONLY);
    if (Fd == -1)
        handle_error(&quot;open&quot;);

    if (fstat(fd, &amp;sb) == -1)           /* 파일 크기 얻기 */
        handle_error(&quot;fstat&quot;);

    offset = atoi(argv[2]);
    pa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - 1);
        /* mmap() 오프셋이 페이지에 정렬돼 있어야 함 */

    if (offset &gt;= sb.st_size) {
        fprintf(stderr, &quot;offset is past end of file\n&quot;);
        exit(EXIT_FAILURE);
    }

    if (argc == 4) {
        length = atoi(argv[3]);
        if (offset + length &gt; sb.st_size)
            length = sb.st_size - offset;
                /* 파일 끝 너머의 바이트는 표시할 수 없음 */

    } else {    /* length 인자 없음 ==&gt; 파일 끝까지 표시 */
        length = sb.st_size - offset;
    }

    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,
                MAP_PRIVATE, fd, pa_offset);
    if (addr == MAP_FAILED)
        handle_error(&quot;mmap&quot;);

    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);
    if (s != length) {
        if (s == -1)
            handle_error(&quot;write&quot;);

        fprintf(stderr, &quot;partial write&quot;);
        exit(EXIT_FAILURE);
    }

    munmap(addr, length + offset - pa_offset);
    close(fd);

    exit(EXIT_SUCCESS);
}
</code></pre>

<h2 id="see-also">SEE ALSO</h2>
<p><tt>[[ftruncate(2)]]</tt>, <tt>[[getpagesize(2)]]</tt>, <tt>[[memfd_create(2)]]</tt>, <tt>[[mincore(2)]]</tt>, <tt>[[mlock(2)]]</tt>, <tt>[[mmap2(2)]]</tt>, <tt>[[mprotect(2)]]</tt>, <tt>[[mremap(2)]]</tt>, <tt>[[msync(2)]]</tt>, <tt>[[remap_file_pages(2)]]</tt>, <tt>[[setrlimit(2)]]</tt>, <tt>[[shmat(2)]]</tt>, <tt>[[userfaultfd(2)]]</tt>, <tt>[[shm_open(3)]]</tt>, <tt>[[shm_overview(7)]]</tt></p>
<p><tt>[[proc(5)]]</tt> 내의 <code>/proc/[pid]/maps</code>, <code>/proc/[pid]/map_files</code>, <code>/proc/[pid]/smaps</code> 파일에 대한 설명.</p>
<p>B.O. Gallmeister, POSIX.4, O'Reilly, 128-129쪽 및 389-391쪽.</p>
<hr />
<p>2019-02-27</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
