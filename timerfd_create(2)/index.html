<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="리눅스 매뉴얼 페이지 일부 한글 번역">
    
    <link rel="canonical" href="https://wariua.github.io/man-pages-ko/timerfd_create(2)/">
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>Timerfd create(2) - man-pages-ko</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/idea.min.css">
        
    
    <link href="../css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">man-pages-ko</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../section_file/">File</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_ipc/">IPC</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_memory/">Memory</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_network/">Network</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_process/">Process</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_thread/">Thread</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_trouble_shooting/">Trouble Shooting</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_others/">Others</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#name">NAME</a></li>
        <li class="first-level "><a href="#synopsis">SYNOPSIS</a></li>
        <li class="first-level "><a href="#description">DESCRIPTION</a></li>
            <li class="second-level"><a href="#timerfd_create">timerfd_create()</a></li>
                
            <li class="second-level"><a href="#timerfd_settime">timerfd_settime()</a></li>
                
            <li class="second-level"><a href="#timerfd_gettime">timerfd_gettime()</a></li>
                
            <li class="second-level"><a href="#_1">타이머 파일 디스크립터 조작</a></li>
                
            <li class="second-level"><a href="#fork2">[[fork(2)]] 동작 방식</a></li>
                
            <li class="second-level"><a href="#execve2">[[execve(2)]] 동작 방식</a></li>
                
        <li class="first-level "><a href="#return-value">RETURN VALUE</a></li>
        <li class="first-level "><a href="#errors">ERRORS</a></li>
        <li class="first-level "><a href="#versions">VERSIONS</a></li>
        <li class="first-level "><a href="#conforming-to">CONFORMING TO</a></li>
        <li class="first-level "><a href="#bugs">BUGS</a></li>
        <li class="first-level "><a href="#example">EXAMPLE</a></li>
            <li class="second-level"><a href="#_2">프로그램 소스</a></li>
                
        <li class="first-level "><a href="#see-also">SEE ALSO</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h2 id="name">NAME</h2>
<p>timerfd_create, timerfd_settime, timerfd_gettime - 파일 디스크립터를 통해 알려 주는 타이머</p>
<h2 id="synopsis">SYNOPSIS</h2>
<pre><code class="c">#include &lt;sys/timerfd.h&gt;

int timerfd_create(int clockid, int flags);

int timerfd_settime(int fd, int flags,
                    const struct itimerspec *new_value,
                    struct itimerspec *old_value);

int timerfd_gettime(int fd, struct itimerspec *curr_value);
</code></pre>

<h2 id="description">DESCRIPTION</h2>
<p>이 시스템 호출들은 파일 디스크립터를 통해 타이머 만료 알림을 전달하는 타이머를 생성하고 조작한다. <tt>[[setitimer(2)]]</tt>나 <tt>[[timer_create(2)]]</tt>의 대안이 되어 주는데 <tt>[[select(2)]]</tt>, <tt>[[poll(2)]]</tt>, <tt>[[epoll(7)]]</tt>로 그 파일 디스크립터를 감시할 수 있다는 장점이 있다.</p>
<p>이 세 가지 시스템 호출 사용법은 <tt>[[timer_create(2)]]</tt>, <tt>[[timer_settime(2)]]</tt>, <tt>[[timer_gettime(2)]]</tt>과 비슷하다. (<tt>[[timer_getoverrun(2)]]</tt>에 대응하는 것은 없다. 아래에서 설명하듯 <code>read(2)</code>로 그 기능성을 제공하기 때문이다.)</p>
<h3 id="timerfd_create"><code>timerfd_create()</code></h3>
<p><code>timerfd_create()</code>는 새 타이머 객체를 생성하고 그 타이머를 가리키는 파일 디스크립터를 반환한다. <code>clockid</code> 인자는 타이머 진행을 특징 짓는 클럭을 나타내며 다음 중 한 가지여야 한다.</p>
<dl>
<dt><code>CLOCK_REALTIME</code></dt>
<dd>설정 가능하며 시스템 전역인 실제 시간 클럭.</dd>
<dt><code>CLOCK_MONOTONIC</code></dt>
<dd>설정 불가능하며 시스템 구동 후 바뀌지 않는 과거 불특정 시점으로부터의 시간을 측정하는 단조 증가 클럭.</dd>
<dt><code>CLOCK_BOOTTIME</code> (리눅스 3.15부터)</dt>
<dd><code>CLOCK_MONOTONIC</code>처럼 단조 증가하는 클럭이다. 하지만 <code>CLOCK_MONOTONIC</code> 클럭에서 시스템이 절전 대기 상태인 시간을 측정하지 않는 반면 <code>CLOCK_BOOTTIME</code> 클럭에서는 시스템이 절전 대기 상태인 시간을 포함한다. 절전 대기를 인식할 필요가 있는 응용들에 유용하다. 그런 응용들에 <code>CLOCK_REALTIME</code>은 적합하지 않은데, 그 클럭은 시스템 클럭의 불연속적 변화에 영향을 받기 때문이다.</dd>
<dt><code>CLOCK_REALTIME_ALARM</code> (리눅스 3.11부터)</dt>
<dd>이 클럭은 <code>CLOCK_REALTIME</code>과 비슷하되 시스템이 절전 대기 상태이면 깨우게 된다. 이 클럭에 대해 타이머를 설정하기 위해선 호출자가 <code>CAP_WAKE_ALARM</code> 역능을 가지고 있어야 한다.</dd>
<dt><code>CLOCK_BOOTTIME_ALARM</code> (리눅스 3.11부터)</dt>
<dd>이 클럭은 <code>CLOCK_BOOTTIME</code>과 비슷하되 시스템이 절전 대기 상태이면 깨우게 된다. 이 클럭에 대해 타이머를 설정하기 위해선 호출자가 <code>CAP_WAKE_ALARM</code> 역능을 가지고 있어야 한다.</dd>
</dl>
<p>이 클럭들 각각의 현재 값은 <tt>[[clock_gettime(2)]]</tt>을 이용해 얻어 올 수 있다.</p>
<p>리눅스 2.6.27부터 <code>flags</code>에 다음 값들을 비트 OR 해서 <code>timerfd_create()</code>의 동작 방식을 바꿀 수 있다.</p>
<dl>
<dt><code>TFD_NONBLOCK</code></dt>
<dd>새 파일 디스크립터가 가리키는 열린 파일 기술 항목(<tt>[[open(2)]]</tt> 참고)에 <code>O_NONBLOCK</code> 파일 상태 플래그를 설정한다. 이 플래그를 사용하면 같은 결과를 얻기 위해 <tt>[[fcntl(2)]]</tt>을 추가로 호출하지 않아도 된다.</dd>
<dt><code>TFD_CLOEXEC</code></dt>
<dd>새 파일 디스크립터에 'exec에서 닫기'(<code>FD_CLOEXEC</code>) 플래그를 설정한다. 이게 유용할 수 있는 이유에 대해선 <tt>[[open(2)]]</tt>의 <code>O_CLOEXEC</code> 플래그 설명을 보라.</dd>
</dl>
<p>리눅스 버전 2.6.26까지에서는 <code>flags</code>를 0으로 지정해야 한다.</p>
<h3 id="timerfd_settime"><code>timerfd_settime()</code></h3>
<p><code>timerfd_settime()</code>은 파일 디스크립터 <code>fd</code>가 가리키는 타이머를 장전(시작)하거나 해제(정지)한다.</p>
<p><code>new_value</code> 인자는 타이머의 최초 만료 시간과 간격을 지정한다. 이 인자에 쓰는 <code>itimerspec</code> 구조체에는 두 필드가 있고 각각이 다시 <code>timespec</code> 타입 구조체이다.</p>
<pre><code class="c">struct timespec {
    time_t tv_sec;                /* 초 */
    long   tv_nsec;               /* 나노초 */
};

struct itimerspec {
    struct timespec it_interval;  /* 주기 타이머의 간격 */
    struct timespec it_value;     /* 최초 만료 */
};
</code></pre>

<p><code>new_value.it_value</code>는 타이머의 최초 만료 시간을 초와 나노초로 지정한다. <code>new_value.it_value</code>의 한 필드라도 0 아닌 값으로 설정하면 타이머가 장전된다. <code>new_value.it_value</code>의 두 필드를 모두 0으로 설정하면 타이머를 해제한다.</p>
<p><code>new_value.it_interval</code>의 필드 한 개나 두 개를 0 아닌 값으로 설정하면 최초 만료 후 타이머의 반복 만료 주기를 초와 나노초로 지정한다. <code>new_value.it_interval</code>의 두 필드가 모두 0이면 <code>new_value.it_value</code>로 지정한 시간에 한 번만 타이머가 만료된다.</p>
<p>기본적으로 <code>new_value</code>로 지정하는 최초 만료 시간은 호출 시점에 타이머 클럭의 현재 시간을 기준으로 상대적으로 해석한다. (즉, <code>new_value.it_value</code>가 지정하는 것이 <code>clockid</code>로 지정한 클럭의 현재 값에 대한 상대적 시간이다.) <code>flags</code> 인자를 통해 절대 시간 타임아웃을 선택할 수 있다.</p>
<p><code>flags</code> 인자는 비트 마스크이며 다음 같들을 포함할 수 있다.</p>
<dl>
<dt><code>TFD_TIMER_ABSTIME</code></dt>
<dd><code>new_value.it_value</code>를 타이머 클럭에서의 절댓값으로 해석한다. 타이머의 클럭이 <code>new_value.it_value</code>로 지정한 값에 도달할 때 타이머가 만료된다.</dd>
<dt><code>TFD_TIMER_CANCEL_ON_SET</code></dt>
<dd><code>TFD_TIMER_ABSTIME</code>과 함께 이 플래그를 지정하고 이 타이머의 클럭이 <code>CLOCK_REALTIME</code>이나 <code>CLOCK_REALTIME_ALARM</code>이면 실제 시간 클럭이 불연속적 변경(<tt>[[settimeofday(2)]]</tt>나 <tt>[[clock_settime(2)]]</tt> 같은 것)을 겪을 때 이 타이머를 취소할 수 있다고 표시한다. 그런 변경이 일어날 때 파일 디스크립터에 대한 현재나 미래의 <code>read(2)</code>가 <code>ECANCELED</code> 오류로 실패하게 된다.</dd>
</dl>
<p><code>old_value</code> 인자가 NULL이 아니면 가리키는 <code>itimerspec</code> 구조체를 이용해 호출 시점에 적용 중이던 타이머 설정을 반환한다. 이어지는 <code>timerfd_gettime()</code> 설명을 참고하라.</p>
<h3 id="timerfd_gettime"><code>timerfd_gettime()</code></h3>
<p><code>timerfd_gettime()</code>은 파일 디스크립터 <code>fd</code>가 가리키는 타이머의 현재 설정을 담은 <code>itimerspec</code> 구조체를 <code>curr_value</code>로 반환한다.</p>
<p><code>it_value</code> 필드는 타이머가 다음 만료될 때까지 남은 시간을 반환한다. 이 구조체의 두 필드가 모두 0이라면 타이머가 현재 해제되어 있는 것이다. 타이머를 설정할 때 <code>TFD_TIMER_ABSTIME</code> 플래그를 지정했는지와 무관하게 이 필드는 항상 상댓값을 담고 있다.</p>
<p><code>it_interval</code> 필드는 타이머의 간격을 반환한다. 이 구조체의 두 필드가 모두 0이라면 <code>curr_value.it_value</code>로 지정한 시간에 한 번만 만료되도록 타이머가 설정되어 있는 것이다.</p>
<h3 id="_1">타이머 파일 디스크립터 조작</h3>
<p><code>timerfd_create()</code>가 반환하는 파일 디스크립터는 다음 작업을 지원한다.</p>
<dl>
<dt><code>read(2)</code></dt>
<dd>
<p><code>timerfd_settime()</code>을 이용해 마지막으로 설정을 변경한 이후로, 또는 마지막 <code>read(2)</code> 성공 이후로 타이머가 한 번 이상 만료되었으면 발생한 만료 횟수를 담은 부호 없는 8바이트 정수(<code>uint64_t</code>)를 <code>read(2)</code>에 준 버퍼로 반환한다. (반환되는 값은 호스트 바이트 순서, 즉 호스트 머신 자체의 정수 바이트 순서로 되어 있다.)</p>
<p><code>read(2)</code> 시점까지 타이머 만료가 발생하지 않았으면 다음 타이머 만료까지 호출이 블록 한다. 또는 (<tt>[[fcntl(2)]]</tt> <code>F_SETFL</code> 동작으로 <code>O_NONBLOCK</code> 플래그를 설정해서) 파일 디스크립터를 비블로킹으로 만들었다면 <code>EAGAIN</code> 오류로 실패한다.</p>
<p>제공한 버퍼의 크기가 8바이트보다 작으면 <code>read(2)</code>가 <code>EINVAL</code> 오류로 실패한다.</p>
<p>연계된 클럭이 <code>CLOCK_REALTIME</code>이나 <code>CLOCK_REALTIME_ALARM</code>이고, 타이머가 절대이고 (<code>TFD_TIMER_ABSTIME</code>), <code>timerfd_settime()</code> 호출 때 <code>TFD_TIMER_CANCEL_ON_SET</code> 플래그를 지정했다면 실제 시간 클럭이 불연속적 변경을 거치는 경우 <code>read(2)</code>가 <code>ECANCELED</code> 오류로 실패한다. (이를 통해 읽기를 하는 응용에서 클럭에 불연속적 변경이 일어났음을 알아챌 수 있다.)</p>
</dd>
<dt><tt>[[poll(2)]]</tt>, <tt>[[select(2)]]</tt> (기타 유사 함수)</dt>
<dd>
<p>타이머 만료가 한 번 이상 일어났을 때 파일 디스크립터가 읽기 가능하다. (<tt>[[select(2)]]</tt> <code>readfds</code> 인자, <tt>[[poll(2)]]</tt> <code>POLLIN</code> 플래그.)</p>
<p>파일 디스크립터가 <tt>[[pselect(2)]]</tt>, <tt>[[ppoll(2)]]</tt>, <tt>[[epoll(7)]]</tt> 같은 다른 파일 디스크립터 다중화 API도 지원한다.</p>
</dd>
<dt><code>ioctl(2)</code></dt>
<dd>
<p>다음의 timerfd 한정 명령을 지원한다.</p>
<dl>
<dt><code>TFD_IOC_SET_TICKS</code> (리눅스 3.17부터)</dt>
<dd>발생한 타이머 만료 횟수를 조정한다. 인자는 새 만료 횟수를 담은 0 아닌 8바이트 정수에 대한 포인터(<code>uint64_t*</code>)이다. 횟수를 설정하고 나서 그 타이머에 대기 중인 프로세스가 있으면 모두 깨운다. 이 명령의 유일한 용도는 체크포인트/복원 목적으로 만료 횟수를 복원하는 것이다. 커널을 <code>CONFIG_CHECKPOINT_RESTORE</code> 옵션으로 구성한 경우에만 이 동작이 사용 가능하다.</dd>
</dl>
</dd>
<dt><tt>[[close(2)]]</tt></dt>
<dd>파일 디스크립터가 더 이상 필요하지 않으면 닫아야 한다. 동일 타이머 객체에 연계된 모든 파일 디스크립터가 닫혔을 때 커널이 타이머를 해제하고 그 자원을 해제한다.</dd>
</dl>
<h3 id="fork2"><tt>[[fork(2)]]</tt> 동작 방식</h3>
<p><code>timerfd_create()</code>으로 생성한 파일 디스크립터의 사본을 <tt>[[fork(2)]]</tt> 후에 자식이 물려받는다. 그 파일 디스크립터는 부모에서의 대응하는 파일 디스크립터와 같은 기반 타이머 객체를 가리키며, 자식에서 <code>read(2)</code> 하면 그 타이머의 만료에 대한 정보를 반환하게 된다.</p>
<h3 id="execve2"><tt>[[execve(2)]]</tt> 동작 방식</h3>
<p><code>timerfd_create()</code>으로 생성한 파일 디스크립터가 <tt>[[execve(2)]]</tt>를 거치면서 보존되며, 타이머가 장전되어 있었다면 계속 타이머 만료가 발생한다.</p>
<h2 id="return-value">RETURN VALUE</h2>
<p>성공 시 <code>timerfd_create()</code>은 새 파일 디스크립터를 반환한다. 오류 시 -1을 반환하며 오류를 나타내도록 <code>errno</code>를 설정한다.</p>
<p><code>timerfd_settime()</code>과 <code>timerfd_gettime()</code>은 성공 시 0을 반환한다. 오류 시 -1을 반환하며 오류를 나타내도록 <code>errno</code>를 설정한다.</p>
<h2 id="errors">ERRORS</h2>
<p><code>timerfd_create()</code>이 다음 오류로 실패할 수 있다.</p>
<dl>
<dt><code>EINVAL</code></dt>
<dd><code>clockid</code> 인자가 <code>CLOCK_MONOTONIC</code>이나 <code>CLOCK_REALTIME</code>이 아니다.</dd>
<dt><code>EINVAL</code></dt>
<dd><code>flags</code>가 유효하지 않다. 또는 리눅스 2.6.26 또는 이전에서 <code>flags</code>가 0이 아니다.</dd>
<dt><code>EMFILE</code></dt>
<dd>열린 파일 디스크립터 개수에 대한 프로세스별 제한에 도달했다.</dd>
<dt><code>ENFILE</code></dt>
<dd>열린 파일 총개수에 대한 시스템 전역 제한에 도달했다.</dd>
<dt><code>ENODEV</code></dt>
<dd>(내부적으로 쓰는) 익명 아이노드 장치를 마운트 할 수 없었다.</dd>
<dt><code>ENOMEM</code></dt>
<dd>타이머를 생성하기에 커널 메모리가 충분하지 않았다.</dd>
</dl>
<p><code>timerfd_settime()</code>과 <code>timerfd_gettime()</code>이 다음 오류로 실패할 수 있다.</p>
<dl>
<dt><code>EBADF</code></dt>
<dd><code>fd</code>가 유효한 파일 디스크립터가 아니다.</dd>
<dt><code>EFAULT</code></dt>
<dd><code>new_value</code>나 <code>old_value</code>, <code>curr_value</code>가 유효한 포인터가 아니다.</dd>
<dt><code>EINVAL</code></dt>
<dd><code>fd</code>가 유효한 timerfd 파일 디스크립터가 아니다.</dd>
</dl>
<p><code>timerfd_settime()</code>이 다음 오류로 실패할 수도 있다.</p>
<dl>
<dt><code>EINVAL</code></dt>
<dd><code>new_value</code>가 올바로 초기화 되어 있지 않다. (한 <code>tv_nsec</code> 필드가 0에서 999,999,999까지 범위 밖에 있다.)</dd>
<dt><code>EINVAL</code></dt>
<dd><code>flags</code>가 유효하지 않다.</dd>
</dl>
<h2 id="versions">VERSIONS</h2>
<p>리눅스 커널 2.6.25부터 이 시스템 호출들이 사용 가능하다. glibc 버전 2.8부터 라이브러리 지원을 제공한다.</p>
<h2 id="conforming-to">CONFORMING TO</h2>
<p>이 시스템 호출들은 리눅스 전용이다.</p>
<h2 id="bugs">BUGS</h2>
<p>현재 <code>timerfd_create()</code>가 지원하는 클럭 ID 종류가 <tt>[[timer_create(2)]]</tt>보다 적다.</p>
<h2 id="example">EXAMPLE</h2>
<p>다음 프로그램은 타이머를 생성하고서 그 진행을 지켜본다. 프로그램은 세 개까지의 명령행 인자를 받는다. 첫 번째 인자는 타이머의 최초 만료까지의 초 수를 나타낸다. 두 번째 인자는 타이머의 초 단위 간격을 나타낸다. 세 번째 인자는 종료 전까지 프로그램에서 허용해야 하는 타이머 만료 횟수를 나타낸다. 두 번째와 세 번째 명령행 인자는 선택적이다.</p>
<pre><code class="text">$ a.out 3 1 100
0.000: timer started
3.000: read: 1; total=1
4.000: read: 1; total=2
^Z                  # control+Z 입력해서 프로그램 정지
[1]+  Stopped                 ./timerfd3_demo 3 1 100
$ fg                # 몇 초 후에 실행 재개
a.out 3 1 100
9.660: read: 5; total=7
10.000: read: 1; total=8
11.000: read: 1; total=9
^C                  # control+C 입력해서 프로그램 중단
</code></pre>

<h3 id="_2">프로그램 소스</h3>
<pre><code class="c">#include &lt;sys/timerfd.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;        /* uint64_t 정의 */

#define handle_error(msg) \
        do { perror(msg); exit(EXIT_FAILURE); } while (0)

static void
print_elapsed_time(void)
{
    static struct timespec start;
    struct timespec curr;
    static int first_call = 1;
    int secs, nsecs;

    if (first_call) {
        first_call = 0;
        if (clock_gettime(CLOCK_MONOTONIC, &amp;start) == -1)
            handle_error(&quot;clock_gettime&quot;);
    }

    if (clock_gettime(CLOCK_MONOTONIC, &amp;curr) == -1)
        handle_error(&quot;clock_gettime&quot;);

    secs = curr.tv_sec - start.tv_sec;
    nsecs = curr.tv_nsec - start.tv_nsec;
    if (nsecs &lt; 0) {
        secs--;
        nsecs += 1000000000;
    }
    printf(&quot;%d.%03d: &quot;, secs, (nsecs + 500000) / 1000000);
}

int
main(int argc, char *argv[])
{
    struct itimerspec new_value;
    int max_exp, fd;
    struct timespec now;
    uint64_t exp, tot_exp;
    ssize_t s;

    if ((argc != 2) &amp;&amp; (argc != 4)) {
        fprintf(stderr, &quot;%s init-secs [interval-secs max-exp]\n&quot;,
                argv[0]);
        exit(EXIT_FAILURE);
    }

    if (clock_gettime(CLOCK_REALTIME, &amp;now) == -1)
        handle_error(&quot;clock_gettime&quot;);

    /* 명령행에서 지정한 최초 만료 시간와 간격으로
       CLOCK_REALTIME 절대 시간 타이머 생성 */

    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);
    new_value.it_value.tv_nsec = now.tv_nsec;
    if (argc == 2) {
        new_value.it_interval.tv_sec = 0;
        max_exp = 1;
    } else {
        new_value.it_interval.tv_sec = atoi(argv[2]);
        max_exp = atoi(argv[3]);
    }
    new_value.it_interval.tv_nsec = 0;

    fd = timerfd_create(CLOCK_REALTIME, 0);
    if (fd == -1)
        handle_error(&quot;timerfd_create&quot;);

    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &amp;new_value, NULL) == -1)
        handle_error(&quot;timerfd_settime&quot;);

    print_elapsed_time();
    printf(&quot;timer started\n&quot;);

    for (tot_exp = 0; tot_exp &lt; max_exp;) {
        s = read(fd, &amp;exp, sizeof(uint64_t));
        if (s != sizeof(uint64_t))
            handle_error(&quot;read&quot;);

        tot_exp += exp;
        print_elapsed_time();
        printf(&quot;read: %llu; total=%llu\n&quot;,
                (unsigned long long) exp,
                (unsigned long long) tot_exp);
    }

    exit(EXIT_SUCCESS);
}
</code></pre>

<h2 id="see-also">SEE ALSO</h2>
<p><tt>[[eventfd(2)]]</tt>, <tt>[[poll(2)]]</tt>, <code>read(2)</code>, <tt>[[select(2)]]</tt>, <tt>[[setitimer(2)]]</tt>, <tt>[[signalfd(2)]]</tt>, <tt>[[timer_create(2)]]</tt>, <tt>[[timer_gettime(2)]]</tt>, <tt>[[timer_settime(2)]]</tt>, <tt>[[epoll(7)]]</tt>, <tt>[[time(7)]]</tt></p>
<hr />
<p>2019-03-06</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
