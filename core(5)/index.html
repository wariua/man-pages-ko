<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="리눅스 매뉴얼 페이지 일부 한글 번역">
    
    <link rel="canonical" href="https://wariua.github.io/man-pages-ko/core%285%29/">
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>core(5) - man-pages-ko</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/idea.min.css">
        
    
    <link href="../css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">man-pages-ko</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../section_file/">File</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_ipc/">IPC</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_memory/">Memory</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_network/">Network</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_process/">Process</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_thread/">Thread</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_trouble_shooting/">Trouble Shooting</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_others/">Others</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#name">NAME</a></li>
        <li class="first-level "><a href="#description">DESCRIPTION</a></li>
            <li class="second-level"><a href="#_1">코어 덤프 파일 이름</a></li>
                
            <li class="second-level"><a href="#_2">코어 덤프를 프로그램으로 보내기</a></li>
                
            <li class="second-level"><a href="#procsyskernelcore_pipe_limit">/proc/sys/kernel/core_pipe_limit</a></li>
                
            <li class="second-level"><a href="#_3">코어 덤프에 기록할 매핑 제어</a></li>
                
            <li class="second-level"><a href="#systemd">코어 덤프와 systemd</a></li>
                
        <li class="first-level "><a href="#notes">NOTES</a></li>
        <li class="first-level "><a href="#examples">EXAMPLES</a></li>
            <li class="second-level"><a href="#_4">프로그램 소스</a></li>
                
        <li class="first-level "><a href="#see-also">SEE ALSO</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h2 id="name">NAME</h2>
<p>core - 코어 덤프 파일</p>
<h2 id="description">DESCRIPTION</h2>
<p>어떤 시그널들의 기본 동작은 프로세스를 종료시키고 <em>코어 덤프 파일</em>, 즉 종료 시점의 프로세스 메모리 이미지를 담은 파일을 만드는 것이다. 디버거(가령 <tt><a class="wikilink" href="/man-pages-ko/gdb(1)/">gdb(1)</a></tt>)에서 그 이미지를 이용해 종료 시점의 프로그램 상태를 조사할 수 있다. 프로세스 코어 덤프를 만들게 하는 시그널 목록은 <tt><a class="wikilink" href="/man-pages-ko/signal(7)/">signal(7)</a></tt>에서 볼 수 있다.</p>
<p>프로세스에서 연성 <code>RLIMIT_CORE</code> 자원 제한을 설정해서 "코어 덤프" 시그널 수신 시 만드는 코어 덤프 파일의 크기에 상한을 둘 수 있다. 자세한 내용은 <tt><a class="wikilink" href="/man-pages-ko/getrlimit(2)/">getrlimit(2)</a></tt>을 보라.</p>
<p>코어 덤프 파일이 생기지 않는 다양한 경우들이 있다.</p>
<ul>
<li>
<p>프로세스에게 코어 파일 쓰기를 할 권한이 없다. (기본적으로 코어 파일의 이름은 <code>core</code>나 <code>core.PID</code>이고 현재 작업 디렉터리에 생긴다. 이름에 대한 자세한 내용은 아래 참고.) 파일을 생성할 디렉터리에 쓰기가 가능하지 않거나, 같은 이름의 파일이 존재하는데 그 파일이 쓰기 가능하지 않거나 정규 파일이 아니면 (가령 디렉터리나 심볼릭 링크면) 코어 파일 쓰기가 실패한다.</p>
</li>
<li>
<p>코어 덤프에 사용할 이름의 (쓰기 가능한 정규) 파일이 이미 존재하는데 그 파일에 대한 하드 링크가 여러 개이다.</p>
</li>
<li>
<p>코어 덤프 파일을 생성할 파일 시스템이 가득 차 있거나, 아이노드가 남아 있지 않거나, 읽기 전용으로 마운트돼 있거나, 사용자별 할당 용량을 다 썼다.</p>
</li>
<li>
<p>코어 덤프 파일을 생성할 디렉터리가 존재하지 않는다.</p>
</li>
<li>
<p>프로세스의 <code>RLIMIT_CORE</code>(코어 파일 크기) 또는 <code>RLIMIT_FSIZE</code>(파일 크기) 자원 제한값이 0으로 설정돼 있다. <tt><a class="wikilink" href="/man-pages-ko/getrlimit(2)/">getrlimit(2)</a></tt> 및 셸의 <code>ulimit</code> 명령 (<code>csh(1)</code>에서는 <code>limit</code>) 설명 참고.</p>
</li>
<li>
<p>프로세스가 실행 중인 바이너리에 읽기 권한이 켜져 있지 않다. (실행 파일 내용물이 읽기 가능하지 않은데 그 실행 파일의 이미지를 담은 읽기 가능할 수 있는 코어 덤프를 만들어 내는 걸 막기 위한 보안적 조치다.)</p>
</li>
<li>
<p>프로세스가 set-user-ID(set-group-ID) 프로그램을 실행 중인데 프로그램 소유 사용자(그룹)가 프로세스의 실제 사용자(그룹) ID와 다르거나, 프로세스가 파일 역능(<tt><a class="wikilink" href="/man-pages-ko/capabilities(7)/">capabilities(7)</a></tt> 참고)을 가진 프로그램을 실행 중이다. (하지만 <tt><a class="wikilink" href="/man-pages-ko/prctl(2)/">prctl(2)</a></tt> <code>PR_SET_DUMPABLE</code> 동작 설명과 <tt><a class="wikilink" href="/man-pages-ko/proc(5)/">proc(5)</a></tt>의 <code>/proc/sys/fs/suid_dumpable</code> 설명도 볼 것.)</p>
</li>
<li>
<p><code>/proc/sys/kernel/core_pattern</code>이 비어 있고 <code>/proc/sys/kernel/core_uses_pid</code> 값이 0이다. (이 파일들은 아래에서 설명한다.) 참고로 <code>/proc/sys/kernel/core_pattern</code>이 비어 있고 <code>/proc/sys/kernel/core_uses_pid</code> 값이 1이면 코어 덤프 파일 이름이 <code>.PID</code> 형태가 되고, 그래서 <code>ls(1)</code> <code>-a</code> 옵션을 쓰지 않으면 보이지 않는다.</p>
</li>
<li>
<p>(리눅스 3.7부터) <code>CONFIG_COREDUMP</code>를 빼고 커널을 구성했다.</p>
</li>
</ul>
<p>그리고 <tt><a class="wikilink" href="/man-pages-ko/madvise(2)/">madvise(2)</a></tt>의 <code>MADV_DONTDUMP</code> 플래그를 사용했다면 프로세스 주소 공간 중 일부가 코어 덤프에서 제외될 수 있다.</p>
<p><code>init</code> 프레임워크로 <code>systemd(1)</code>를 쓰는 시스템에서는 코어 덤프 위치를 <code>systemd(1)</code>에서 정할 수 있다. 자세한 내용은 아래 참고.</p>
<h3 id="_1">코어 덤프 파일 이름</h3>
<p>기본적으로 코어 덤프 파일의 이름은 <code>core</code>지만 (리눅스 2.6 및 2.4.21부터는) <code>/proc/sys/kernel/core_pattern</code> 파일을 통해 코어 덤프 파일 이름의 템플릿을 지정할 수 있다. 템플릿에 % 지시자가 들어갈 수 있으며 코어 파일 생성 시 다음 값들로 바뀐다.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%%</code></td>
<td>% 문자</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>사고 프로세스의 코어 파일 크기 연성 자원 제한. (리눅스 2.6.24부터)</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>덤프 모드. <tt><a class="wikilink" href="/man-pages-ko/prctl(2)/">prctl(2)</a></tt> <code>PR_GET_DUMPABLE</code>이 반환하는 값과 같음. (리눅스 3.7부터)</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>프로세스 내지 스레드의 <code>comm</code> 값. 보통 (경로 선두부를 제외하고 최대 15글자로 자른) 실행 파일 이름과 같지만 다른 값으로 변경됐을 수도 있다. <tt><a class="wikilink" href="/man-pages-ko/proc(5)/">proc(5)</a></tt>의 <code>/proc/[pid]/comm</code> 및 <code>/proc/[pid]/task/[tid]/comm</code> 설명 참고.</td>
</tr>
<tr>
<td><code>%E</code></td>
<td>실행 파일 이름. 슬래시('/')를 느낌표('!')로 바꿔서. (리눅스 3.0부터)</td>
</tr>
<tr>
<td><code>%g</code></td>
<td>덤프 대상 프로세스의 숫자로 된 실제 GID</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>호스트명. <tt><a class="wikilink" href="/man-pages-ko/uname(2)/">uname(2)</a></tt>이 반환하는 <code>nodename</code>과 같음.</td>
</tr>
<tr>
<td><code>%i</code></td>
<td>코어 덤프를 유발한 스레드의 TID. 스레드가 위치한 PID 네임스페이스 기준. (리눅스 3.18부터)</td>
</tr>
<tr>
<td><code>%I</code></td>
<td>코어 덤프를 유발한 스레드의 TID. 최초 PID 네임스페이스 기준. (리눅스 3.18부터)</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>덤프 대상 프로세스의 PID. 프로세스가 위치한 PID 네임스페이스 기준.</td>
</tr>
<tr>
<td><code>%P</code></td>
<td>덤프 대상 프로세스의 PID. 최초 PID 네임스페이스 기준. (리눅스 3.12부터)</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>덤프를 일으킨 시그널의 번호.</td>
</tr>
<tr>
<td><code>%t</code></td>
<td>덤프 시간. 에포크, 즉 1970-01-01 00:00:00 +0000 (UTC) 이후 경과한 초의 수로 표현.</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>덤프 대상 프로세스의 숫자로 된 실제 UID</td>
</tr>
</tbody>
</table>
<p>템플릿 끝에 %가 한 개만 있으면 코어 파일 이름에서 빠진다. % 다음에 위에 나열된 것 외의 문자가 조합된 경우도 마찬가지다. 그 외의 다른 문자들은 모두 코어 파일 이름에 그대로 들어간다. 템플릿에 '/' 문자가 포함될 수 있으며 디렉터리 이름 구분자로 해석한다. 결과로 나오는 코어 파일 이름의 최대 길이는 128바이트다. (2.6.19 전 커널에서는 64바이트였다.) 이 파일의 기본값은 "core"다. 하위 호환성을 위해서 <code>/proc/sys/kernel/core_pattern</code>에 <code>%p</code>가 없고 <code>/proc/sys/kernel/core_uses_pid</code>(아래 참고)가 0이 아니면 코어 파일 이름에 .PID를 덧붙인다.</p>
<p>경로 해석은 사고 프로세스에서 활성인 구성에 따라 이뤄진다. 사고 프로세스의 마운트 네임스페이스(<tt><a class="wikilink" href="/man-pages-ko/mount_namespaces(7)/">mount_namespaces(7)</a></tt> 참고), (<code>getcwd(2)</code>로 얻을 수 있는) 현재 작업 디렉터리, 루트 디렉터리(<tt><a class="wikilink" href="/man-pages-ko/chroot(2)/">chroot(2)</a></tt> 참고) 말이다.</p>
<p>버전 2.4부터 리눅스에선 코어 덤프 파일 이름을 제어하는 더 단순한 방법을 함께 제공했다. <code>/proc/sys/kernel/core_uses_pid</code> 파일에 0 값이 들어 있으면 코어 덤프 파일의 이름이 그냥 <code>core</code>다. 그 파일에 0 아닌 값이 들어 있으면 코어 덤프 파일 이름에 프로세스 ID가 포함되어 <code>core.PID</code> 형태가 된다.</p>
<p>리눅스 3.6부터는 <code>/proc/sys/fs/suid_dumpable</code>을 2("suidsafe")로 설정하는 경우 패턴이 ('/' 문자로 시작하는) 절대 경로명이거나 아래 설명하는 파이프여야 한다.</p>
<h3 id="_2">코어 덤프를 프로그램으로 보내기</h3>
<p>리눅스 커널 2.6.19부터 <code>/proc/sys/kernel/core_pattern</code> 파일에서 또 다른 문법을 지원한다. 파일의 첫 번째 문자가 파이프 기호(|)이면 행 나머지 부분이 실행해야 할 사용자 공간 프로그램 (내지 스크립트) 명령행으로 해석된다.</p>
<p>커널 5.3.0부터는 파이프 템플릿을 공백으로 쪼개서 인자 목록으로 만든 <em>후에</em> 템플릿 매개변수들을 확장한다. 그 전 커널에서는 템플릿 매개변수들을 먼저 확장해서 나온 문자열을 공백으로 쪼개서 인자 목록으로 만든다. 즉, 이전 커널에선 템플릿 매개변수 <code>%e</code>나 <code>%E</code>로 추가된 실행 파일 이름이 여러 인자로 쪼개질 수도 있다. 그래서 코어 덤프 처리 프로그램에서 실행 파일 이름을 마지막 인자로 두고 실행 파일 조각들을 공백을 이용해 다시 붙여야 한다. 그런데 연속으로 공백이 여러 개 들어 있는 실행 파일 이름이 올바르게 표현되지 않으며, 따라서 코어 덤프 처리 프로그램에서 실행 파일 이름을 알아내는 메커니즘을 사용해야 한다.</p>
<p>코어 덤프가 디스크 파일에 기록되는 게 아니라 프로그램에 표준 입력으로 주어진다. 다음에 유의해야 한다.</p>
<ul>
<li>
<p>절대 경로명으로 (또는 루트 디렉터리 <code>/</code> 기준 경로명으로) 프로그램을 지정해야 하며 '|' 문자 바로 다음에 경로명이 와야 한다.</p>
</li>
<li>
<p>명령행 인자에 위에 나열한 % 지시자가 뭐든 들어갈 수 있다. 예를 들어 덤프 중인 프로세스의 PID를 전달하려면 인자에 <code>%p</code>를 지정하면 된다.</p>
</li>
<li>
<p>그 프로그램을 실행하기 위해 생성되는 프로세스는 사용자와 그룹을 <code>root</code>로 해서 돈다.</p>
</li>
<li>
<p><code>root</code>로 돈다고 해도 어떤 예외적인 보안 우회도 이뤄지지 않는다. 즉 LSM(가령 SELinux)이 여전히 효력이 있으며, 그래서 처리 프로그램에서 <code>/proc/[pid]</code>를 통해 사고 프로세스에 대한 자세한 정보에 접근하는 걸 막을 수도 있다.</p>
</li>
<li>
<p>항상 최초 마운트 네임스페이스에서 프로그램을 실행하기 때문에 거기를 기준으로 프로그램 경로명을 해석한다. 사고 프로세스의 구성(가령 루트 디렉터리, 마운트 네임스페이스, 현재 작업 디렉터리)에 영향을 받지 않는다.</p>
</li>
<li>
<p>사고 프로세스의 네임스페이스가 아니라 (PID, 마운트, 사용자 등의) 최초 네임스페이스에서 프로세스가 돈다. <code>%P</code> 같은 지시자를 이용하면 정확한 <code>/proc/[pid]</code> 디렉터리를 알아낼 수 있으므로 필요시 사고 프로세스의 네임스페이스에 진입하거나 조사할 수 있다.</p>
</li>
<li>
<p>루트 디렉터리를 현재 작업 디렉터리로 해서 프로세스가 시작한다. 원한다면 <code>%P</code> 지시자가 제공한 값을 이용해서 <code>/proc/[pid]/cwd</code>를 통해 덤프 프로세스의 작업 디렉터리로 바꾸는 게 가능하다.</p>
</li>
<li>
<p>(리눅스 2.6.24부터) 공백으로 구분된 명령행 인자들을 (행의 총 길이 128바이트까지) 프로그램에 줄 수 있다.</p>
</li>
<li>
<p>이 메커니즘을 통해 프로그램으로 전달되는 코어 덤프에는 <code>RLIMIT_CORE</code> 제한이 적용되지 않는다.</p>
</li>
</ul>
<h3 id="procsyskernelcore_pipe_limit"><code>/proc/sys/kernel/core_pipe_limit</code></h3>
<p>사용자 공간 프로그램으로 파이프를 연결해서 코어 덤프를 수집할 때 사고 프로세스의 <code>/proc/[pid]</code> 디렉터리에서 얻는 데이터가 수집 프로그램에게 유용할 수 있다. 안전하게 수집을 할 수 있으려면 코어 덤프 수집 프로그램이 끝날 때까지 커널이 기다리게 해서 사고 프로세스의 <code>/proc/[pid]</code> 파일들을 때 이르게 없애지 않도록 해야 한다. 그런데 이렇게 하면 오동작하는 수집 프로그램이 절대 끝나지 않아서 사고 프로세스 정리를 막게 될 가능성이 생긴다.</p>
<p>리눅스 2.6.32부터는 <code>/proc/sys/kernel/core_pipe_limit</code>을 써서 그런 가능성에 대비할 수 있다. 이 파일의 값은 동시에 얼마나 많은 사고 프로세스들이 병렬로 사용자 공간 프로그램으로 파이프 연결될 수 있는지를 규정한다. 이 값을 초과하게 되면 값을 넘은 사고 프로세스들을 커널 로그에만 기록하고 코어 덤프를 건너뛴다.</p>
<p>이 파일에서 0 값은 특별하다. 무제한의 프로세스들을 동시에 잡고 있을 수 있음을 나타내며, 또한 커널에서 기다려 주지 않음을 (즉 수집 프로그램에서 사고 프로세스의 <code>/proc/[pid]</code>에 접근하지 못할 수도 있음을) 나타낸다. 이 파일의 기본값은 0이다.</p>
<h3 id="_3">코어 덤프에 기록할 매핑 제어</h3>
<p>커널 2.6.23부터는 리눅스 전용인 <code>/proc/[pid]/coredump_filter</code> 파일을 사용해 해당 프로세스 ID를 가진 프로세스에 대해 코어 덤프를 수행하는 경우 코어 덤프 파일에 어떤 메모리 세그먼트들이 기록되게 할지를 제어할 수 있다.</p>
<p>파일의 값은 메모리 매핑 종류들(<tt><a class="wikilink" href="/man-pages-ko/mmap(2)/">mmap(2)</a></tt> 참고)의 비트 마스크다. 마스크의 어떤 비트가 설정돼 있으면 대응하는 종류의 메모리 매핑들을 덤프하고, 아니면 덤프하지 않는다. 비트들의 의미는 다음과 같다.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0번 비트</td>
<td>익명 비공유 매핑 덤프.</td>
</tr>
<tr>
<td>1번 비트</td>
<td>익명 공유 매핑 덤프.</td>
</tr>
<tr>
<td>2번 비트</td>
<td>파일 기반 비공유 매핑 덤프.</td>
</tr>
<tr>
<td>3번 비트</td>
<td>파일 기반 공유 매핑 덤프.</td>
</tr>
<tr>
<td>4번 비트</td>
<td>(리눅스 2.6.24부터) ELF 헤더 덤프.</td>
</tr>
<tr>
<td>5번 비트</td>
<td>(리눅스 2.6.28부터) 비공유 거대 페이지 덤프.</td>
</tr>
<tr>
<td>6번 비트</td>
<td>(리눅스 2.6.28부터) 공유 거대 페이지 덤프.</td>
</tr>
<tr>
<td>7번 비트</td>
<td>(리눅스 4.4부터) 비공유 DAX 페이지 덤프.</td>
</tr>
<tr>
<td>8번 비트</td>
<td>(리눅스 4.4부터) 공유 DAX 페이지 덤프.</td>
</tr>
</tbody>
</table>
<p>기본적으로 0번, 1번, 4번 (<code>CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS</code> 커널 구성 옵션이 켜진 경우), 5번 비트가 설정돼 있다. <code>coredump_filter</code> 부팅 옵션을 사용하면 부팅 때 이 기본값을 바꿀 수 있다.</p>
<p>이 파일의 값은 16진수로 표시된다. (따라서 기본값이 33으로 표시된다.)</p>
<p><code>coredump_filter</code> 값이 어떻든지 프레임 버퍼 같은 메모리 맵 I/O 페이지들은 절대 덤프하지 않으며 가상 DSO(<tt><a class="wikilink" href="/man-pages-ko/vdso(7)/">vdso(7)</a></tt>) 페이지들은 항상 덤프한다.</p>
<p><tt><a class="wikilink" href="/man-pages-ko/fork(2)/">fork(2)</a></tt>를 통해 생성된 자식 프로세스가 부모의 <code>coredump_filter</code> 값을 물려받는다. <tt><a class="wikilink" href="/man-pages-ko/execve(2)/">execve(2)</a></tt>를 거치면서 <code>coredump_filter</code> 값이 유지된다.</p>
<p>프로그램 실행 전에 부모 셸에서 <code>coredump_filter</code>를 설정하는 게 요긴할 수 있다.</p>
<pre><code class="language-text">$ echo 0x7 &gt; /proc/self/coredump_filter
$ ./some_program
</code></pre>
<p>커널을 <code>CONFIG_ELF_CORE</code> 구성 옵션으로 빌드한 경우에만 이 파일이 제공된다.</p>
<h3 id="systemd">코어 덤프와 systemd</h3>
<p><code>systemd(1)</code> <em>init</em> 프레임워크를 쓰는 시스템에서는 코어 덤프가 저장되는 위치를 <code>systemd(1)</code>에서 정할 수 있다. 이를 위해 <code>systemd(1)</code>에서는 코어 덤프를 파이프로 프로그램에 보낼 수 있는 <code>core_pattern</code> 기능을 이용한다. 코어 덤프가 파이프를 통해 <code>systemd-coredump(8)</code> 프로그램으로 가고 있는지 다음과 같이 확인해 볼 수 있다.</p>
<pre><code class="language-text">$ cat /proc/sys/kernel/core_pattern
|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %e
</code></pre>
<p>이 경우 코어 덤프는 <code>systemd-coredump(8)</code>에 설정된 위치로 가게 되는데, 보통 <code>/var/lib/systemd/coredump/</code> 디렉터리에 <code>lz4(1)</code> 압축 파일로 저장된다. <code>systemd-coredump(8)</code>가 기록해 둔 코어 덤프들의 목록을 <code>coredumpctl(1)</code>을 이용해 볼 수 있다.</p>
<pre><code class="language-text">$ coredumpctl list | tail -5
Wed 2017-10-11 22:25:30 CEST  2748 1000 1000 3 present  /usr/bin/sleep
Thu 2017-10-12 06:29:10 CEST  2716 1000 1000 3 present  /usr/bin/sleep
Thu 2017-10-12 06:30:50 CEST  2767 1000 1000 3 present  /usr/bin/sleep
Thu 2017-10-12 06:37:40 CEST  2918 1000 1000 3 present  /usr/bin/cat
Thu 2017-10-12 08:13:07 CEST  2955 1000 1000 3 present  /usr/bin/cat
</code></pre>
<p>코어 덤프마다 덤프 일시, 덤프 프로세스의 PID, UID, GID, 코어 덤프를 유발한 시그널 번호, 덤프된 프로세스가 실행하고 있던 실행 파일 경로명 등의 정보가 보인다. <code>coredumpctl(1)</code>의 여러 옵션들을 통해 지정한 코어 덤프 파일을 <code>systemd(1)</code>의 위치에서 원하는 파일로 가져올 수 있다. 예를 들어 위에 있는 PID 2955의 코어 덤프를 현재 디렉터리에 <code>core</code>라는 파일로 빼내려면 다음처럼 하면 된다.</p>
<pre><code class="language-text">$ coredumpctl dump 2955 -o core
</code></pre>
<p>더 자세한 내용은 <code>coredumpctl(1)</code> 매뉴얼 페이지를 참고하라.</p>
<p><code>systemd(1)</code>의 코어 덤프 기록 메커니즘을 (지속해서) 끄고 전통적인 리눅스 동작 방식을 복원하고 싶다면 다음처럼 <code>systemd(1)</code> 메커니즘을 무시하게 설정할 수 있다.</p>
<pre><code class="language-text"># echo &quot;kernel.core_pattern=core.%p&quot; &gt; \
               /etc/sysctl.d/50-coredump.conf
# /lib/systemd/systemd-sysctl
</code></pre>
<p>또 다음과 같은 명령을 써서 <code>core_pattern</code>을 일시적으로 (즉 다음 재부팅까지만) 바꾸는 것도 가능하다. (다음 명령은 코어 덤프 파일 이름에 실행 파일 이름뿐 아니라 코어 덤프를 유발한 시그널 번호도 포함시킨다.)</p>
<pre><code class="language-text"># sysctl -w kernel.core_pattern=&quot;%e-%s.core&quot;
</code></pre>
<h2 id="notes">NOTES</h2>
<p><tt><a class="wikilink" href="/man-pages-ko/gdb(1)/">gdb(1)</a></tt>의 <code>gcore</code> 명령을 이용하면 실행 중인 프로세스의 코어 덤프를 얻을 수 있다.</p>
<p>리눅스 2.6.27까지 버전에서는 다중 스레드 프로세스가 (더 정확히는 <tt><a class="wikilink" href="/man-pages-ko/clone(2)/">clone(2)</a></tt>의 <code>CLONE_VM</code> 플래그로 생성돼서 다른 프로세스와 메모리를 공유하는 프로세스가) 코어를 덤프하는 경우에 <code>/proc/sys/kernel/core_pattern</code>의 <code>%p</code> 지시자를 통해 파일명 어디에 프로세스 ID가 이미 포함돼 있지 않으면 항상 코어 파일명에 프로세스 ID를 덧붙인다. (프로세스의 스레드마다 PID가 다른 구식 LinuxThreads 구현을 쓸 때 주로 도움이 된다.)</p>
<h2 id="examples">EXAMPLES</h2>
<p>아래 프로그램을 통해 <code>/proc/sys/kernel/core_pattern</code> 파일의 파이프 문법 사용 방식을 볼 수 있다. 다음 셸 세션은 이 프로그램 사용례를 보여 준다. (<code>core_pattern_pipe_test</code>라는 실행 파일로 컴파일함.)</p>
<pre><code class="language-text">$ cc -o core_pattern_pipe_test core_pattern_pipe_test.c
$ su
Password:
# echo &quot;|$PWD/core_pattern_pipe_test %p UID=%u GID=%g sig=%s&quot; &gt; \
    /proc/sys/kernel/core_pattern
# exit
$ sleep 100
^\                     # Ctrl-\ 입력
Quit (core dumped)
$ cat core.info
argc=5
argc[0]=&lt;/home/mtk/core_pattern_pipe_test&gt;
argc[1]=&lt;20575&gt;
argc[2]=&lt;UID=1000&gt;
argc[3]=&lt;GID=100&gt;
argc[4]=&lt;sig=3&gt;
Total bytes in core dump: 282624
</code></pre>
<h3 id="_4">프로그램 소스</h3>
<pre><code class="language-c">/* core_pattern_pipe_test.c */

#define _GNU_SOURCE
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define BUF_SIZE 1024

int
main(int argc, char *argv[])
{
    ssize_t nread, tot;
    char buf[BUF_SIZE];
    FILE *fp;
    char cwd[PATH_MAX];

    /* 사고 프로세스의 현재 작업 디렉터리로 이동하기. */

    snprintf(cwd, PATH_MAX, &quot;/proc/%s/cwd&quot;, argv[1]);
    chdir(cwd);

    /* 그 디렉터리의 &quot;core.info&quot; 파일로 기록하기. */

    fp = fopen(&quot;core.info&quot;, &quot;w+&quot;);
    if (fp == NULL)
        exit(EXIT_FAILURE);

    /* core_pattern 파이프 프로그램이 받은 명령행 인자
       표시하기. */

    fprintf(fp, &quot;argc=%d\n&quot;, argc);
    for (int j = 0; j &lt; argc; j++)
        fprintf(fp, &quot;argc[%d]=&lt;%s&gt;\n&quot;, j, argv[j]);

    /* 표준 입력(코어 덤프)의 바이트 수 세기. */

    tot = 0;
    while ((nread = read(STDIN_FILENO, buf, BUF_SIZE)) &gt; 0)
        tot += nread;
    fprintf(fp, &quot;Total bytes in core dump: %zd\n&quot;, tot);

    fclose(fp);
    exit(EXIT_SUCCESS);
}
</code></pre>
<h2 id="see-also">SEE ALSO</h2>
<p><code>bash(1)</code>, <code>coredumpctl(1)</code>, <tt><a class="wikilink" href="/man-pages-ko/gdb(1)/">gdb(1)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/getrlimit(2)/">getrlimit(2)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/mmap(2)/">mmap(2)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/prctl(2)/">prctl(2)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/sigaction(2)/">sigaction(2)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/elf(5)/">elf(5)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/proc(5)/">proc(5)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/pthreads(7)/">pthreads(7)</a></tt>, <tt><a class="wikilink" href="/man-pages-ko/signal(7)/">signal(7)</a></tt>, <code>systemd-coredump(8)</code></p>
<hr />
<p>2021-03-22</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
