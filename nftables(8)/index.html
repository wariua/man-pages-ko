<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="리눅스 매뉴얼 페이지 일부 한글 번역">
    
    <link rel="canonical" href="https://wariua.github.io/man-pages-ko/nftables(8)/">
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>Nftables(8) - man-pages-ko</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/idea.min.css">
        
    
    <link href="../css/style.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">man-pages-ko</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../section_file/">File</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_ipc/">IPC</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_memory/">Memory</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_network/">Network</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_process/">Process</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_thread/">Thread</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_trouble_shooting/">Trouble Shooting</a>
                    </li>
                
                
                
                    <li >
                        <a href="../section_others/">Others</a>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#name">NAME</a></li>
        <li class="first-level "><a href="#synopsis">SYNOPSIS</a></li>
        <li class="first-level "><a href="#description">DESCRIPTION</a></li>
        <li class="first-level "><a href="#options">OPTIONS</a></li>
        <li class="first-level "><a href="#_1">입력 파일 형식</a></li>
            <li class="second-level"><a href="#_2">구문 규약</a></li>
                
            <li class="second-level"><a href="#_3">파일 포함하기</a></li>
                
            <li class="second-level"><a href="#_4">심볼 변수</a></li>
                
                <li class="third-level"><a href="#_5">심볼 변수 사용하기</a></li>
        <li class="first-level "><a href="#_6">주소 패밀리</a></li>
            <li class="second-level"><a href="#ipv4ipv6inet">IPv4/IPv6/Inet 주소 패밀리</a></li>
                
            <li class="second-level"><a href="#arp">ARP 주소 패밀리</a></li>
                
            <li class="second-level"><a href="#_7">브리지 주소 패밀리</a></li>
                
            <li class="second-level"><a href="#netdev">Netdev 주소 패밀리</a></li>
                
        <li class="first-level "><a href="#_8">룰셋</a></li>
        <li class="first-level "><a href="#_9">테이블</a></li>
            <li class="second-level"><a href="#_10">테이블 추가, 변경, 삭제</a></li>
                
        <li class="first-level "><a href="#_11">체인</a></li>
        <li class="first-level "><a href="#_12">규칙</a></li>
            <li class="second-level"><a href="#ip-input">ip 테이블 input 체인에 규칙 추가</a></li>
                
            <li class="second-level"><a href="#inet">inet 테이블에서 규칙 삭제</a></li>
                
        <li class="first-level "><a href="#_13">집합</a></li>
            <li class="second-level"><a href="#_14">익명 집합 이용해 특정 서브넷 및 포트 허용하기</a></li>
                
            <li class="second-level"><a href="#_15">기명 집합 이용해 주소 및 포트 허용하기</a></li>
                
        <li class="first-level "><a href="#_16">맵</a></li>
        <li class="first-level "><a href="#_17">플로테이블</a></li>
        <li class="first-level "><a href="#_18">상태 객체</a></li>
            <li class="second-level"><a href="#ct-helper">ct helper</a></li>
                
                <li class="third-level"><a href="#ftp">ftp 헬퍼 정의하고 할당하기</a></li>
            <li class="second-level"><a href="#ct-timeout">ct timeout</a></li>
                
                <li class="third-level"><a href="#ct">ct 타임아웃 정책 정의하고 할당하기</a></li>
                <li class="third-level"><a href="#_19">갱신된 타임아웃 정책 확인하기</a></li>
            <li class="second-level"><a href="#ct-expectation">ct expectation</a></li>
                
                <li class="third-level"><a href="#ct_1">ct 예상 정책 정의하고 할당하기</a></li>
            <li class="second-level"><a href="#counter">counter</a></li>
                
            <li class="second-level"><a href="#quota">quota</a></li>
                
        <li class="first-level "><a href="#_20">식</a></li>
            <li class="second-level"><a href="#describe">describe 명령</a></li>
                
                <li class="third-level"><a href="#describe_1">describe 명령</a></li>
        <li class="first-level "><a href="#_21">데이터 타입</a></li>
            <li class="second-level"><a href="#_22">정수 타입</a></li>
                
            <li class="second-level"><a href="#_23">비트마스크 타입</a></li>
                
            <li class="second-level"><a href="#_24">문자열 타입</a></li>
                
                <li class="third-level"><a href="#_25">문자열 표시</a></li>
            <li class="second-level"><a href="#_26">링크 계층 주소 타입</a></li>
                
                <li class="third-level"><a href="#_27">링크 계층 주소 표시</a></li>
            <li class="second-level"><a href="#ipv4">IPv4 주소 타입</a></li>
                
                <li class="third-level"><a href="#ipv4_1">IPv4 주소 표시</a></li>
            <li class="second-level"><a href="#ipv6">IPv6 주소 타입</a></li>
                
                <li class="third-level"><a href="#ipv6_1">IPv6 주소 표시</a></li>
                <li class="third-level"><a href="#ipv6_2">대괄호 표기법을 쓴 IPv6 주소 표시</a></li>
            <li class="second-level"><a href="#_28">불리언 타입</a></li>
                
                <li class="third-level"><a href="#_29">불리언 지정</a></li>
            <li class="second-level"><a href="#icmp">ICMP 타입 타입</a></li>
                
                <li class="third-level"><a href="#icmp_1">ICMP 타입 지정</a></li>
            <li class="second-level"><a href="#icmp_2">ICMP 코드 타입</a></li>
                
            <li class="second-level"><a href="#icmpv6">ICMPv6 타입 타입</a></li>
                
                <li class="third-level"><a href="#icmpv6_1">ICMPv6 타입 지정</a></li>
            <li class="second-level"><a href="#icmpv6_2">ICMPv6 코드 타입</a></li>
                
            <li class="second-level"><a href="#icmpvx">ICMPvX 코드 타입</a></li>
                
            <li class="second-level"><a href="#conntrack">conntrack 타입</a></li>
                
        <li class="first-level "><a href="#_30">기본 식</a></li>
            <li class="second-level"><a href="#meta">meta 식</a></li>
                
                <li class="third-level"><a href="#meta_1">meta 식 사용하기</a></li>
            <li class="second-level"><a href="#socket">socket 식</a></li>
                
                <li class="third-level"><a href="#_31">소켓 식 사용하기</a></li>
            <li class="second-level"><a href="#osf">osf 식</a></li>
                
                <li class="third-level"><a href="#ttl">사용 가능한 ttl 값</a></li>
                <li class="third-level"><a href="#osf_1">osf 식 사용하기</a></li>
            <li class="second-level"><a href="#fib">fib 식</a></li>
                
                <li class="third-level"><a href="#fib_1">fib 식 사용하기</a></li>
            <li class="second-level"><a href="#_32">라우팅 식</a></li>
                
                <li class="third-level"><a href="#_33">라우팅 식 사용하기</a></li>
            <li class="second-level"><a href="#ipsec">ipsec 식</a></li>
                
            <li class="second-level"><a href="#numgen">numgen 식</a></li>
                
                <li class="third-level"><a href="#numgen_1">numgen 식 사용하기</a></li>
        <li class="first-level "><a href="#_34">페이로드 식</a></li>
            <li class="second-level"><a href="#_35">이더넷 헤더 식</a></li>
                
            <li class="second-level"><a href="#vlan">VLAN 헤더 식</a></li>
                
            <li class="second-level"><a href="#arp_1">ARP 헤더 식</a></li>
                
            <li class="second-level"><a href="#ipv4_2">IPv4 헤더 식</a></li>
                
            <li class="second-level"><a href="#icmp_3">ICMP 헤더 식</a></li>
                
            <li class="second-level"><a href="#igmp">IGMP 헤더 식</a></li>
                
            <li class="second-level"><a href="#ipv6_3">IPv6 헤더 식</a></li>
                
                <li class="third-level"><a href="#ip6">ip6 헤더 식 사용하기</a></li>
            <li class="second-level"><a href="#icmpv6_3">ICMPv6 헤더 식</a></li>
                
            <li class="second-level"><a href="#tcp">TCP 헤더 식</a></li>
                
            <li class="second-level"><a href="#udp">UDP 헤더 식</a></li>
                
            <li class="second-level"><a href="#udp-lite">UDP-Lite 헤더 식</a></li>
                
            <li class="second-level"><a href="#sctp">SCTP 헤더 식</a></li>
                
            <li class="second-level"><a href="#dccp">DCCP 헤더 식</a></li>
                
            <li class="second-level"><a href="#_36">인증 헤더 식</a></li>
                
            <li class="second-level"><a href="#_37">보안 페이로드 캡슐화 헤더 식</a></li>
                
            <li class="second-level"><a href="#ipcomp">IPCOMP 헤더 식</a></li>
                
            <li class="second-level"><a href="#_38">비가공 페이로드 식</a></li>
                
                <li class="third-level"><a href="#udp-tcp">UDP와 TCP 모두의 목적 포트 확인하기</a></li>
                <li class="third-level"><a href="#arp_2">ARP 패킷 목적 프로토콜 주소가 지정 주소와 일치하면 대상 하드웨어 주소 다시 쓰기</a></li>
            <li class="second-level"><a href="#_39">확장 헤더 식</a></li>
                
                <li class="third-level"><a href="#tcp_1">TCP 옵션 찾기</a></li>
                <li class="third-level"><a href="#ipv6-exthdr">IPv6 exthdr 확인하기</a></li>
                <li class="third-level"><a href="#ip">IP 옵션 찾기</a></li>
            <li class="second-level"><a href="#conntrack_1">conntrack 식</a></li>
                
                <li class="third-level"><a href="#_40">서버로 동시에 향하는 연결 수 제한하기</a></li>
        <li class="first-level "><a href="#_41">문</a></li>
            <li class="second-level"><a href="#_42">판정 문</a></li>
                
            <li class="second-level"><a href="#_43">페이로드 문</a></li>
                
            <li class="second-level"><a href="#_44">확장 헤더 문</a></li>
                
            <li class="second-level"><a href="#_45">로그 문</a></li>
                
            <li class="second-level"><a href="#_46">거절 문</a></li>
                
            <li class="second-level"><a href="#_47">카운터 문</a></li>
                
            <li class="second-level"><a href="#conntrack_2">conntrack 문</a></li>
                
            <li class="second-level"><a href="#meta_2">meta 문</a></li>
                
            <li class="second-level"><a href="#_48">제한 문</a></li>
                
            <li class="second-level"><a href="#nat">NAT 문</a></li>
                
            <li class="second-level"><a href="#tproxy">TPROXY 문</a></li>
                
            <li class="second-level"><a href="#synproxy">SYNPROXY 문</a></li>
                
            <li class="second-level"><a href="#flow">flow 문</a></li>
                
            <li class="second-level"><a href="#queue">queue 문</a></li>
                
            <li class="second-level"><a href="#dup">dup 문</a></li>
                
            <li class="second-level"><a href="#fwd">fwd 문</a></li>
                
            <li class="second-level"><a href="#set">set 문</a></li>
                
            <li class="second-level"><a href="#map">map 문</a></li>
                
            <li class="second-level"><a href="#vmap">vmap 문</a></li>
                
        <li class="first-level "><a href="#_49">추가 명령</a></li>
            <li class="second-level"><a href="#monitor">monitor</a></li>
                
        <li class="first-level "><a href="#_50">오류 보고</a></li>
        <li class="first-level "><a href="#_51">종료 상태</a></li>
        <li class="first-level "><a href="#see-also">SEE ALSO</a></li>
        <li class="first-level "><a href="#authors">AUTHORS</a></li>
        <li class="first-level "><a href="#copyright">COPYRIGHT</a></li>
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h2 id="name">NAME</h2>
<p>nft - 패킷 필터링 및 분류를 위한 nftables 프레임워크의 관리 도구</p>
<h2 id="synopsis">SYNOPSIS</h2>
<pre>
<strong>nft</strong> [ <strong>-nNscaeSupyjt</strong> ] [ <strong>-I</strong> <em>directory</em> ] [ <strong>-f</strong> <em>filename</em> | <strong>-i</strong> | <em>cmd</em> ...]
<strong>nft -h</strong>
<strong>nft -v</strong>
</pre>

<h2 id="description">DESCRIPTION</h2>
<p>nft는 리눅스 커널 nftables 프레임워크의 패킷 필터링 및 분류 규칙을 설정하고 관리하고 조사하는 데 쓰는 명령행 도구다. 그 리눅스 커널 서브시스템을 nf_tables라고 하는데, 여기서 'nf'는 Netfilter를 나타낸다.</p>
<h2 id="options">OPTIONS</h2>
<p>옵션 요약 전체를 보려면 <code>nft --help</code>를 실행하면 된다.</p>
<dl>
<dt><code>-h</code>, <code>--help</code></dt>
<dd>도움말 메시지와 전체 옵션을 보여 준다.</dd>
<dt><code>-v</code>, <code>--version</code></dt>
<dd>버전을 보여 준다.</dd>
<dt><code>-n</code>, <code>--numeric</code></dt>
<dd>출력을 완전히 숫자로만 찍는다.</dd>
<dt><code>-s</code>, <code>--stateless</code></dt>
<dd>규칙과 상태 객체의 상태 정보를 생략한다.</dd>
<dt><code>-N</code>, <code>--reversedns</code></dt>
<dd>DNS 역질의를 통해 IP 주소를 이름으로 변환한다. 네트워크 트래픽을 발생시키므로 목록 표시가 느려질 수 있다.</dd>
<dt><code>-S</code>, <code>--service</code></dt>
<dd><code>/etc/services</code>에 정의된 대로 포트 번호를 서비스 이름으로 변환한다.</dd>
<dt><code>-u</code>, <code>--guid</code></dt>
<dd><code>/etc/passwd</code> 및 <code>/etc/group</code>에 정의된 대로 숫자로 된 UID/GID를 이름으로 변환한다.</dd>
<dt><code>-p</code>, <code>--numeric-protocol</code></dt>
<dd>제4계층 프로토콜을 숫자로 표시한다.</dd>
<dt><code>-y</code>, <code>--numeric-priority</code></dt>
<dd>기본 체인 우선순위를 숫자로 표시한다.</dd>
<dt><code>-c</code>, <code>--check</code></dt>
<dd>변경 사항을 실제 적용하지 않고 명령 유효성만 확인한다.</dd>
<dt><code>-a</code>, <code>--handle</code></dt>
<dd>출력 내용에서 객체 핸들을 보여 준다.</dd>
<dt><code>-e</code>, <code>--echo</code></dt>
<dd><code>add</code>나 <code>insert</code>, <code>replace</code> 명령으로 룰셋에 항목을 집어넣을 때 <code>nft monitor</code>처럼 알림을 찍는다.</dd>
<dt><code>-j</code>, <code>--json</code></dt>
<dd>JSON 형식으로 출력한다. 스키마 설명은 <code>libnftables-json(5)</code>을 보라.</dd>
<dt><code>-I</code>, <code>--includepath directory</code></dt>
<dd>포함 파일을 찾을 디렉터리 목록에 디렉터리 <code>directory</code>를 추가한다. 이 옵션은 여러 번 지정할 수 있다.</dd>
<dt><code>-f</code>, <code>--file filename</code></dt>
<dd><code>filename</code>에서 입력을 읽어 들인다. <code>filename</code>이 <code>-</code>이면 stdin에서 읽는다.</dd>
<dt><code>-i</code>, <code>--interactive</code></dt>
<dd>대화형 readline CLI에서 입력을 읽어 들인다. <code>quit</code>으로 빠져나갈 수 있다. EOF 표시를 쓸 수도 있는데, 보통 CTRL-D이다.</dd>
<dt><code>-T</code>, <code>--numeric-time</code></dt>
<dd>시각, 요일, 시간 값을 숫자로 보인다.</dd>
<dt><code>-t</code>, <code>--terse</code></dt>
<dd>출력에서 집합 내용물을 생략한다.</dd>
</dl>
<h2 id="_1">입력 파일 형식</h2>
<h3 id="_2">구문 규약</h3>
<p>행 단위로 입력을 파싱 한다. 개행 문자 바로 앞의 행 마지막 문자가 따옴표로 감싸지 않은 백슬래시(\)일 때는 다음 행을 계속 이어진 것처럼 처리한다. 한 행에서 여러 명령을 세미콜론(;)으로 구분할 수 있다.</p>
<p>해시 기호(#)로 주석이 시작된다. 그 행의 나머지 문자들을 모두 무시한다.</p>
<p>식별자는 알파벳 문자(a-z,A-Z)로 시작해서 0개 이상의 알파벳 문자(a-z,A-Z), 숫자(0-9), 슬래시(/), 백슬래시(\), 밑줄(_), 마침표(.) 문자가 온다. 다른 문자를 쓰거나 키워드와 충돌하는 식별자는 큰따옴표(")로 감싸 줘야 한다.</p>
<h3 id="_3">파일 포함하기</h3>
<pre>
<strong>include</strong> <em>filename</em>
</pre>

<p><code>include</code> 문을 써서 다른 파일을 포함할 수 있다. 포함 파일을 찾을 디렉터리들을 <code>-I</code>/<code>--includepath</code> 옵션으로 지정할 수 있다. 또한 경로 앞에 './'를 붙여서 현재 작업 디렉터리에 위치한 파일을 (즉 상대 경로로) 포함하도록 강제하거나 '/'를 써서 절대 경로로 파일 위치를 나타낼 수도 있다.</p>
<p><code>-I</code>/<code>--includepath</code>를 지정하지 않으면 nft는 컴파일 시점에 지정된 기본 디렉터리를 이용한다. <code>-h</code>/<code>--help</code> 옵션을 통해 그 기본 디렉터리를 알아낼 수 있다.</p>
<p>include 문은 일반적인 셸 와일드카드 기호(*,?,[])를 지원한다. include 문에 와일드카드 기호를 쓴 경우에는 include 문에 일치하는 파일이 없어도 오류가 아니다. 그래서 <code>include "/etc/firewall/rules/*"</code> 같은 문으로 포함한 디렉터리가 비어 있을 수도 있다. 와일드카드에 걸린 항목들은 알파벳 순서로 올라온다. 마침표(.)로 시작하는 파일은 include 문에 걸리지 않는다.</p>
<h3 id="_4">심볼 변수</h3>
<pre>
<strong>define</strong> <em>variable</em> = <em>expr</em>
<strong>$variable</strong>
</pre>

<p><code>define</code> 문을 써서 심볼 변수를 정의할 수 있다. 변수 참조는 식이며 이를 이용해 다른 변수를 초기화 할 수 있다. 정의 유효 범위는 현재 블록과 그 안에 포함된 모든 블록이다.</p>
<h4 id="_5">심볼 변수 사용하기</h4>
<pre><code class="text">define int_if1 = eth0
define int_if2 = eth1
define int_ifs = { $int_if1, $int_if2 }

filter input iif $int_ifs accept
</code></pre>

<h2 id="_6">주소 패밀리</h2>
<p>주소 패밀리에 따라 어떤 종류의 패킷이 처리되는지 정해진다. 각 주소 패밀리별로 커널 패킷 처리 경로의 특정 지점들에 소위 훅이 있어서 그 훅에 대한 규칙이 존재하면 nftables를 호출한다.</p>
<dl>
<dt><code>ip</code></dt>
<dd>IPv4 주소 패밀리</dd>
<dt><code>ip6</code></dt>
<dd>IPv6 주소 패밀리</dd>
<dt><code>inet</code></dt>
<dd>인터넷(IPv4/IPv6) 주소 패밀리</dd>
<dt><code>arp</code></dt>
<dd>ARP 주소 패밀리, IPv4 ARP 패킷 처리</dd>
<dt><code>bridge</code></dt>
<dd>브리지 주소 패밀리, 브리지 장치를 통과하는 패킷 처리</dd>
<dt><code>netdev</code></dt>
<dd>netdev 주소 패밀리, 진입점에서 패킷 처리</dd>
</dl>
<p>모든 nftables 객체는 주소 패밀리별 네임스페이스 안에 존재하며, 그래서 모든 식별자에는 주소 패밀리가 포함돼 있다. 주소 패밀리 없이 식별자를 지정하면 기본적으로 <code>ip</code> 패밀리를 쓴다.</p>
<h3 id="ipv4ipv6inet">IPv4/IPv6/Inet 주소 패밀리</h3>
<p>IPv4/IPv6/Inet 주소 패밀리는 IPv4 패킷, IPv6 패킷, 그리고 두 종류 모두를 다룬다. 네트워크 스택의 패킷 처리 단계 다섯 곳에 훅이 있다.</p>
<p>표 1: IPv4/IPv6/Inet 주소 패밀리 훅</p>
<table>
<thead>
<tr>
<th>훅</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>prerouting</td>
<td>시스템에 들어오는 모든 패킷이 prerouting 훅에서 처리된다. 라우팅 처리 전에 호출되며 이르게 필터링을 하거나 라우팅에 영향을 주는 패킷 속성을 바꾸는 데 쓰인다.</td>
</tr>
<tr>
<td>input</td>
<td>로컬 시스템으로 전달되는 패킷이 input 훅에서 처리된다.</td>
</tr>
<tr>
<td>forward</td>
<td>다른 호스트로 전달되는 패킷이 forward 훅에서 처리된다.</td>
</tr>
<tr>
<td>output</td>
<td>로컬 프로세스가 보내는 패킷이 output 훅에서 처리된다.</td>
</tr>
<tr>
<td>postrouting</td>
<td>시스템을 떠나는 모든 패킷이 postrouting 훅에서 처리된다.</td>
</tr>
</tbody>
</table>
<h3 id="arp">ARP 주소 패밀리</h3>
<p>ARP 주소 패밀리는 시스템이 받고 보내는 ARP 패킷들을 다룬다. 클러스터링을 위해 ARP 패킷을 조작하는 데 흔히 쓴다.</p>
<p>표 2: ARP 주소 패밀리 훅</p>
<table>
<thead>
<tr>
<th>훅</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>로컬 시스템으로 전달되는 패킷이 input 훅에서 처리된다.</td>
</tr>
<tr>
<td>output</td>
<td>로컬 시스템에서 보내는 패킷이 output 훅에서 처리된다.</td>
</tr>
</tbody>
</table>
<h3 id="_7">브리지 주소 패밀리</h3>
<p>브리지 주소 패밀리는 브리지 장치를 통과하는 이더넷 패킷을 다룬다.</p>
<p>지원하는 훅 목록은 위의 IPv4/IPv6/Inet 주소 패밀리와 동일하다.</p>
<h3 id="netdev">Netdev 주소 패밀리</h3>
<p>Netdev 주소 패밀리는 진입점(ingress)에서 패킷을 처리한다.</p>
<p>표 3: Netdev 주소 패밀리 훅</p>
<table>
<thead>
<tr>
<th>훅</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>ingress</td>
<td>시스템에 들어오는 모든 패킷이 이 훅에서 처리된다. 제3계층 프로토콜 핸들러 전에 호출되며 이른 필터링이나 폴리싱에 쓸 수 있다.</td>
</tr>
</tbody>
</table>
<h2 id="_8">룰셋</h2>
<pre>
{<strong>list</strong> | <strong>flush</strong>} <strong>ruleset</strong> [<em>family</em>]
</pre>

<p>현재 커널 내에 위치한 테이블, 체인 등의 세트 전체를 나타내는 데 <code>ruleset</code> 키워드를 쓴다. 다음 <code>ruleset</code> 명령이 있다.</p>
<dl>
<dt><code>list</code></dt>
<dd>사람이 읽기 좋은 형식으로 룰셋을 출력한다.</dd>
<dt><code>flush</code></dt>
<dd>룰셋 전체를 비운다. iptables와 달리 모든 테이블과 그 안에 담긴 모든 걸 제거한다는 점에 유의해야 한다. 실질적으로 빈 룰셋이 되며, 어떤 패킷 필터링도 일어나지 않게 되므로 커널에서는 수신한 모든 유효 패킷을 받아들인다.</dd>
</dl>
<p><code>list</code>와 <code>flush</code>를 특정 주소 패밀리로 한정할 수도 있다. 유효한 패밀리 이름의 목록은 위의 "주소 패밀리" 절을 보라.</p>
<p>설계상 <code>list ruleset</code> 명령의 출력을 <code>nft -f</code> 입력으로 쓸 수 있다. 실질적으로 <code>iptables-save</code>와 <code>iptables-restore</code>에 대응한다.</p>
<h2 id="_9">테이블</h2>
<pre>
{<strong>add</strong> | <strong>create</strong>} <strong>table</strong> [<em>family</em>] <em>table</em> [<strong>{ flags</strong> <em>flags</em> <strong>; }</strong>]
{<strong>delete</strong> | <strong>list</strong> | <strong>flush</strong>} <strong>table</strong> [<em>family</em>] <em>table</em>
<strong>list tables</strong> [<em>tables</em>]
<strong>delete table</strong> [<em>family</em>] <strong>handle</strong> <em>handle</em>
</pre>

<p>테이블은 체인, 집합, 상태 객체를 담는 컨테이너다. 주소 패밀리와 이름으로 식별된다. 주소 패밀리는 <code>ip</code>, <code>ip6</code>, <code>inet</code>, <code>arp</code>, <code>bridge</code>, <code>netdev</code> 중 하나여야 한다. <code>inet</code> 주소 패밀리는 하이브리드 IPv4/IPv6 테이블을 만드는 데 쓰는 가상 패밀리다. <code>meta expression nfproto</code> 키워드를 쓰면 패킷이 (IPv4와 IPv6 중) 어느 패밀리 맥락에 있는지 검사할 수 있다. 주소 패밀리를 지정하지 않으면 기본으로 <code>ip</code>를 쓴다. add와 create의 유일한 차이는 지정한 테이블이 이미 존재하는 경우에 전자는 오류를 반환하지 않는 반면 <code>create</code>은 오류를 반환한다는 점이다.</p>
<p>표 4: 테이블 플래그</p>
<table>
<thead>
<tr>
<th>플래그</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dormant</code></td>
<td>테이블을 더 이상 평가하지 않는다. (기본 체인들을 등록 해제한다.)</td>
</tr>
</tbody>
</table>
<h4 id="_10">테이블 추가, 변경, 삭제</h4>
<pre><code class="text"># 대화형으로 nft 시작
nft --interactive

# 새 테이블 생성
create table inet mytable

# 새 기본 체인 추가: 입력 패킷 받기
add chain inet mytable myin { type filter hook input priority 0; }

# 체인에 카운터 하나 추가
add rule inet mytable myin counter

# 테이블을 잠시 비활성화 -- 더는 규칙들이 평가되지 않음
add table inet mytable { flags dormant; }

# 테이블을 다시 활성화
add table inet mytable
</code></pre>

<dl>
<dt><code>add</code></dt>
<dd>지정한 이름으로 지정한 패밀리에 새 테이블 추가.</dd>
<dt><code>delete</code></dt>
<dd>지정한 테이블 삭제.</dd>
<dt><code>list</code></dt>
<dd>지정한 테이블의 모든 체인 및 규칙 나열.</dd>
<dt><code>flush</code></dt>
<dd>지정한 테이블의 모든 체인 및 규칙 비우기.</dd>
</dl>
<h2 id="_11">체인</h2>
<pre>
{<strong>add</strong> | <strong>create</strong>} <strong>chain</strong> [<em>family</em>] <em>table</em> <em>chain</em> [<strong>{ type</strong> <em>type</em> <strong>hook</strong> <em>hook</em> [<strong>device</strong> <em>device</em>] <strong>priority</strong> <em>priority</em> <strong>;</strong> [<strong>policy</strong> <em>policy</em> <strong>;</strong>] <strong>}</strong>]
{<strong>delete</strong> | <strong>list</strong> | <strong>flush</strong>} <strong>chain</strong> [<em>family</em>] <em>table chain</em>
<strong>list chains</strong> [<em>family</em>]
<strong>delete chain</strong> [<em>family</em>] <em>table</em> <strong>handle</strong> <em>handle</em>
<strong>rename chain</strong> [<em>family</em>] <em>table chain newname</em>
</pre>

<p>체인은 규칙들을 담는 컨테이너다. 두 가지 종류가 있는데, 기본 체인과 일반 체인이다. 기본 체인은 네트워킹 스택에서 패킷이 진입하는 지점이다. 일반 체인은 점프 대상으로 쓸 수 있으며 규칙들로 구조를 만드는 데 쓴다.</p>
<dl>
<dt><code>add</code></dt>
<dd>지정한 테이블에 새 체인 추가. 훅과 우선순위 값을 지정하면 기본 체인으로 만들어서 네트워킹 스택에 연결한다.</dd>
<dt><code>create</code></dt>
<dd><code>add</code> 명령과 비슷하되 체인이 이미 존재하면 오류를 반환한다.</dd>
<dt><code>delete</code></dt>
<dd>지정한 체인 삭제. 체인에 어떤 규칙도 없어야 하고 점프 대상으로 쓰이고 있지 않아야 한다.</dd>
<dt><code>rename</code></dt>
<dd>지정한 체인의 이름 변경.</dd>
<dt><code>list</code></dt>
<dd>지정한 체인의 모든 규칙 나열.</dd>
<dt><code>flush</code></dt>
<dd>지정한 체인의 모든 규칙 비우기.</dd>
</dl>
<p>기본 체인에선 <code>type</code>, <code>hook</code>, <code>priority</code> 매개변수가 필수다.</p>
<p>표 5: 지원하는 체인 타입</p>
<table>
<thead>
<tr>
<th>타입</th>
<th>패밀리</th>
<th>훅</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>filter</td>
<td>모두</td>
<td>모두</td>
<td>긴가민가할 때 쓰면 되는 표준 체인 타입.</td>
</tr>
<tr>
<td>nat</td>
<td>ip, ip6, inet</td>
<td>prerouting, input, output, postrouting</td>
<td>이 체인 타입에서는 conntrack 항목에 따라 네트워크 주소 변환을 수행한다. 연결의 첫 번째 패킷만 실제로 이 체인을 거친다. 체인 규칙에서는 일반적으로 생성되는 conntrack 항목의 세부 사항(예를 들어 NAT 문)을 규정한다.</td>
</tr>
<tr>
<td>route</td>
<td>ip, ip6</td>
<td>output</td>
<td>패킷이 이 체인 타입을 거치고서 허용되는 경우에 IP 헤더의 관련 부분이 변경됐으면 라우트 검색을 새로 수행한다. 이를 이용해 가령 nftables에서 정책 라우팅을 할 수 있다.</td>
</tr>
</tbody>
</table>
<p>위에 설명한 특별한 경우들(가령 <code>nat</code>에서 <code>forward</code> 훅을 지원하지 않거나 <code>route</code>에서 <code>output</code> 훅만 지원하는 것) 외에도 신경 써야 할 특이 사항이 두 가지 더 있다.</p>
<ul>
<li>
<p>netdev 패밀리는 한 가지 조합, 즉 <code>filter</code> 타입에 <code>ingress</code> 훅만 지원한다. 또 이 패밀리의 기본 체인에는 <code>device</code> 매개변수가 꼭 있어야 하는데, 입력 인터페이스별로 체인이 존재하기 때문이다.</p>
</li>
<li>
<p>arp 패밀리는 <code>input</code> 훅과 <code>output</code> 훅만 지원하며 둘 모두 <code>filter</code> 타입에서다.</p>
</li>
</ul>
<p><code>priority</code> 매개변수는 같은 <code>hook</code> 값의 체인들을 거치는 순서를 나타내는 부호 있는 정수 값 또는 표준 우선순위 이름을 받는다. 순서는 오름차순이다. 즉 낮은 우선순위 값이 높은 값보다 우선도가 높다.</p>
<p>표준 우선순위 값들 대신 쉽게 기억할 수 있는 이름을 쓸 수 있다. 모든 이름이 각 패밀리의 모든 훅에서 통하는 건 아니지만 (아래 호환성 표 참고) 그래도 그 숫자 값은 체인 우선순위 지정에 사용할 수 있다.</p>
<p>그 이름과 값들은 기본 체인 등록 때 xtables에서 쓰는 우선순위에 따라 정의되고 사용 가능해진다.</p>
<p>대부분의 패밀리에서 같은 값을 쓰지만 브리지는 다른 값을 쓴다. 값과 호환성을 기술하는 다음 두 표를 참고하라.</p>
<p>표 6: 표준 우선순위 이름, 패밀리, 훅 호환성 표</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>값</th>
<th>패밀리</th>
<th>훅</th>
</tr>
</thead>
<tbody>
<tr>
<td>raw</td>
<td>-300</td>
<td>ip, ip6, inet</td>
<td>모두</td>
</tr>
<tr>
<td>mangle</td>
<td>-150</td>
<td>ip, ip6, inet</td>
<td>모두</td>
</tr>
<tr>
<td>dstnat</td>
<td>-100</td>
<td>ip, ip6, inet</td>
<td>prerouting</td>
</tr>
<tr>
<td>filter</td>
<td>0</td>
<td>ip, ip6, inet, arp, netdev</td>
<td>모두</td>
</tr>
<tr>
<td>security</td>
<td>50</td>
<td>ip, ip6, inet</td>
<td>모두</td>
</tr>
<tr>
<td>srcnat</td>
<td>100</td>
<td>ip, ip6, inet</td>
<td>postrouting</td>
</tr>
</tbody>
</table>
<p>표 7: 브리지 패밀리의 표준 우선순위 이름과 훅 호환성</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>값</th>
<th>훅</th>
</tr>
</thead>
<tbody>
<tr>
<td>dstnat</td>
<td>-300</td>
<td>prerouting</td>
</tr>
<tr>
<td>filter</td>
<td>-200</td>
<td>모두</td>
</tr>
<tr>
<td>out</td>
<td>100</td>
<td>output</td>
</tr>
<tr>
<td>srcnat</td>
<td>300</td>
<td>postrouting</td>
</tr>
</tbody>
</table>
<p>이 표준 이름에 간단한 산술 연산(더하기와 빼기)을 해서 상대 우선순위를 쉽게 지정할 수도 있다. 가령 <code>mangle - 5</code>는 <code>-155</code>를 나타낸다. 값을 찍을 때도 표준 값에서 10 넘게 차이가 나지 않으면 그런 식으로 찍는다.</p>
<p>기본 체인에는 체인 <code>policy</code>를 설정할 수도 있다. 즉 안에 담긴 규칙들에서 명시적으로 허용하지도 않고 거부하지도 않은 패킷이 어떻게 되는가이다. 지원하는 정책 값은 <code>accept</code>(기본)와 <code>drop</code>이다.</p>
<h2 id="_12">규칙</h2>
<pre>
{<strong>add</strong> | <strong>insert</strong>} <strong>rule</strong> [<em>family</em>] <em>table chain</em> [<strong>handle</strong> <em>handle</em> | <strong>index</strong> <em>index</em>] <em>statement</em> ... [<strong>comment</strong> <em>comment</em>]
<strong>replace rule</strong> [<em>family</em>] <em>table chain</em> <strong>handle</strong> <em>handle statement</em> ... [<strong>comment</strong> <em>comment</em>]
<strong>delete rule</strong> [<em>family</em>] <em>table chain</em> <strong>handle</strong> <em>handle</em>
</pre>

<p>지정한 테이블의 체인에 규칙이 추가된다. 패밀리를 지정하지 않으면 ip 패밀리를 쓴다. 일군의 문법 규칙에 따라 식(expression)과 문(statement)이라는 두 가지 요소로 규칙이 구성된다.</p>
<p>add와 insert 명령에서는 선택적으로 위치 지정이 가능한데, 기존 규칙의 <code>handle</code>이나 (0에서 시작하는) <code>index</code>로 지정한다. 내부적으로는 항상 <code>handle</code>로 규칙 위치를 나타내며 <code>index</code>에서 변환하는 건 사용자 공간에서 이뤄진다. 때문에 변환이 이뤄진 후 동시에 룰셋 변경이 일어나는 경우 영향이 있을 수도 있다. 즉 참조 대상 규칙 앞에서 규칙이 삽입 내지 삭제되면 실제 규칙 인덱스가 바뀔 수 있다. 그리고 참조 대상 규칙이 삭제되면 유효하지 않은 <code>handle</code>을 준 경우처럼 명령을 커널에서 거부한다.</p>
<p><code>comment</code>는 한 단어거나 큰 따옴표(")로 감싼 여러 단어 문자열이며 실제 규칙과 관련된 메모를 하는 데 쓸 수 있다. <strong>주의</strong>: 규칙 추가 시 bash를 쓴다면 따옴표에 이스케이프를 해 줘야 한다. 예: \"enable ssh for servers\".</p>
<dl>
<dt><code>add</code></dt>
<dd>문 목록으로 나타낸 새 규칙을 추가. 위치를 지정하지 않으면 지정한 체인에 규칙을 덧붙이고, 지정한 경우에는 지정한 규칙 뒤에 규칙을 삽입한다.</dd>
<dt><code>insert</code></dt>
<dd><code>add</code>와 같되 체인의 처음이나 지정한 규칙 앞에 규칙을 삽입.</dd>
<dt><code>replace</code></dt>
<dd><code>add</code>와 비슷하되 지정한 규칙을 교체.</dd>
<dt><code>delete</code></dt>
<dd>지정한 규칙 삭제.</dd>
</dl>
<h4 id="ip-input">ip 테이블 input 체인에 규칙 추가</h4>
<pre><code class="text">nft add rule filter output ip daddr 192.168.0.0/24 accept # 'ip filter' 상정
# 같은 명령을 좀 더 길게 쓰기
nft add rule ip filter output ip daddr 192.168.0.0/24 accept
</code></pre>

<h4 id="inet">inet 테이블에서 규칙 삭제</h4>
<pre><code class="text"># nft -a list ruleset
table inet filter {
        chain input {
                type filter hook input priority 0; policy accept;
                ct state established,related accept # handle 4
                ip saddr 10.1.1.1 tcp dport ssh accept # handle 5
          ...
# 핸들이 5인 규칙 삭제하기
# nft delete rule inet filter input handle 5
</code></pre>

<h2 id="_13">집합</h2>
<p>nftables에는 두 가지 집합 개념이 있다. 익명 집합은 따로 이름이 없는 집합이다. 집합을 쓰는 규칙을 만들 때 집합 멤버들을 중괄호로 감싸고 쉼표로 원소들을 구분한다. 그 규칙이 제거되면 집합도 제거된다. 이 집합은 갱신이 불가능하다. 즉 익명 집합은 일단 선언하고 나면 그 익명 집합을 쓰는 규칙을 제거/변경하지 않고는 변경할 수 없다.</p>
<h4 id="_14">익명 집합 이용해 특정 서브넷 및 포트 허용하기</h4>
<pre><code class="text">nft add rule filter input ip saddr { 10.0.0.0/8, 192.168.0.0/16 } tcp dport { 22, 443 } accept
</code></pre>

<p>기명 집합은 규칙에서 참조하기 전에 먼저 정의해야 한다. 익명 집합과 달리 언제든 기명 집합의 원소를 추가하거나 제거할 수 있다. 규칙에서 집합 이름 앞에 @를 붙여서 집합을 참조한다.</p>
<h4 id="_15">기명 집합 이용해 주소 및 포트 허용하기</h4>
<pre><code class="text">nft add rule filter input ip saddr @allowed_hosts tcp dport @allowed_ports accept
</code></pre>

<p>집합 allowed_hosts와 allowed_ports가 먼저 만들어져 있어야 한다. 다음 절에서 nft set 문법을 더 자세히 설명한다.</p>
<pre>
<strong>add set</strong> [<em>family</em>] <em>table set</em> <strong>{ type</strong> <em>type</em> <strong>;</strong> [<strong>flags</strong> <em>flags</em> <strong>;</strong>] [<strong>timeout</strong> <em>timeout</em> <strong>;</strong>] [<strong>gc-interval</strong> <em>gc-interval</em> <strong>;</strong>] [<strong>elements = {</strong> <em>element</em>[<strong>,</strong> ...] <strong>} ;</strong>] [<strong>size</strong> <em>size</em> <strong>;</strong>] [<strong>policy</strong> <em>policy</em> <strong>;</strong>] [<strong>auto-merge ;</strong>] <strong>}</strong>
{<strong>delete</strong> | <strong>list</strong> | <strong>flush</strong>} <strong>set</strong> [<em>family</em>] <em>table set</em>
<strong>list sets</strong> [<em>family</em>]
<strong>delete set</strong> [<em>family</em>] <em>table</em> <strong>handle</strong> <em>handle</em>
{<strong>add</strong> | <strong>delete</strong>} <strong>element</strong> [<em>family</em>] <em>table set</em> <strong>{</strong> <em>element</em>[<strong>,</strong> ...] <strong>}</strong>
</pre>

<p>집합은 사용자 정의 데이터 타입인 원소 컨테이너다. 사용자 지정 이름으로 유일하게 식별되며 테이블에 붙는다. 집합 생성 시점에 지정할 수 있는 플래그들로 동작을 조정할 수 있다.</p>
<dl>
<dt><code>add</code></dt>
<dd>지정한 테이블에 새 집합 추가. 집합 속성을 지정하는 방법에 대해선 아래의 집합 지정 표 참고.</dd>
<dt><code>delete</code></dt>
<dd>지정한 집합 삭제.</dd>
<dt><code>list</code></dt>
<dd>지정한 집합의 원소 표시.</dd>
<dt><code>flush</code></dt>
<dd>지정한 집합의 모든 원소 제거.</dd>
<dt><code>add element</code></dt>
<dd>지정한 집합에 쉽표 구분 목록의 원소들을 추가.</dd>
<dt><code>delete element</code></dt>
<dd>지정한 집합에서 쉼표 구분 목록의 원소들을 삭제.</dd>
</dl>
<p>표 8: 집합 지정</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>집합 원소의 데이터 타입</td>
<td>문자열: ipv4_addr, ipv6_addr, ether_addr, inet_proto, inet_service, mark</td>
</tr>
<tr>
<td>flags</td>
<td>집합 플래그</td>
<td>문자열: constant, dynamic, interval, timeout</td>
</tr>
<tr>
<td>timeout</td>
<td>집합에서 원소가 유지되는 시간. 집합이 패킷 경로(룰셋)로부터 추가되는 경우 필수.</td>
<td>문자열, 십진수에 단위 붙음. 단위: d, h, m, s</td>
</tr>
<tr>
<td>gc&#x2011;interval</td>
<td>가비지 컬렉션 간격. timeout이나 timeout 플래그가 활성일 때만 사용 가능.</td>
<td>문자열, 십진수에 단위 붙음. 단위: d, h, m, s</td>
</tr>
<tr>
<td>elements</td>
<td>집합에 담기는 원소들</td>
<td>집합 데이터 타입</td>
</tr>
<tr>
<td>size</td>
<td>집합의 최대 원소 수. 집합이 패킷 경로(룰셋)로부터 추가되는 경우 필수.</td>
<td>부호 없는 정수 (64비트)</td>
</tr>
<tr>
<td>policy</td>
<td>집합 정책</td>
<td>문자열: performance [기본], memory</td>
</tr>
<tr>
<td>auto&#x2011;merge</td>
<td>인접/중첩 집합 원소 자동 병합 (interval 집합에만)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="_16">맵</h2>
<pre>
<strong>add map</strong> [<em>family</em>] <em>table map</em> <strong>{ type</strong> <em>type</em> [<strong>flags</strong> <em>flags</em> <strong>;</strong>] [<strong>elements = {</strong> <em>element</em>[<strong>,</strong> ...] <strong>} ;</strong>] [<strong>size</strong> <em>size</em> <strong>;</strong>] [<strong>policy</strong> <em>policy</em> <strong>;</strong>] <strong>}</strong>
{<strong>delete</strong> | <strong>list</strong> | <strong>flush</strong>} <strong>map</strong> [<em>family</em>] <em>table map</em>
<strong>list maps</strong> [<em>family</em>]
{<strong>add</strong> | <strong>delete</strong>} <strong>element</strong> [<em>family</em>] <em>table map</em> <strong>{ elements = {</strong> <em>element</em>[<strong>,</strong> ...] <strong>} ; }</strong>
</pre>

<p>맵은 입력으로 하는 어떤 특정 키에 따라 데이터를 저장한다. 사용자 지정 이름으로 유일하게 식별되며 테이블에 붙는다.</p>
<dl>
<dt><code>add</code></dt>
<dd>지정한 테이블에 새 맵 추가.</dd>
<dt><code>delete</code></dt>
<dd>지정한 맵 삭제.</dd>
<dt><code>list</code></dt>
<dd>지정한 맵의 원소 표시.</dd>
<dt><code>flush</code></dt>
<dd>지정한 맵의 모든 원소 제거.</dd>
<dt><code>add element</code></dt>
<dd>지정한 맵에 쉼표 구분 목록의 원소들을 추가.</dd>
<dt><code>delete element</code></dt>
<dd>지정한 맵에서 쉼표 구분 목록의 원소들을 삭제.</dd>
</dl>
<p>표 9: 맵 지정</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>맵 원소의 데이터 타입</td>
<td>문자열 ':' 문자열: ipv4_addr, ipv6_addr, ether_addr, inet_proto, inet_service, mark, counter, quota. counter과 quota는 키로 쓸 수 없음</td>
</tr>
<tr>
<td>flags</td>
<td>맵 플래그</td>
<td>문자열: constant, interval</td>
</tr>
<tr>
<td>elements</td>
<td>맵에 담기는 원소들</td>
<td>맵 데이터 타입</td>
</tr>
<tr>
<td>size</td>
<td>맵의 최대 원소 수</td>
<td>부호 없는 정수 (64비트)</td>
</tr>
<tr>
<td>policy</td>
<td>맵 정책</td>
<td>문자열: performance [기본], memory</td>
</tr>
</tbody>
</table>
<h2 id="_17">플로테이블</h2>
<pre>
{<strong>add</strong> | <strong>create</strong>} <strong>flowtable</strong> [<em>family</em>] <em>table flowtable</em> <strong>{ hook</strong> <em>hook</em> <strong>priority</strong> <em>priority</em> <strong>; devices = {</strong> <em>device</em>[<strong>,</strong> ...] <strong>} ; }</strong>
<strong>list flowtables</strong> [<em>family</em>]
{<strong>delete</strong> | <strong>list</strong>} <strong>flowtable</strong> {<em>family</em>] <em>table flowtable</em>
<strong>delete flowtable</strong> [<em>family</em>] <em>table</em> <strong>handle</strong> <em>handle</em>
</pre>

<p>플로테이블을 통해 소프트웨어에서 패킷 포워딩 속도를 높일 수 있다. 입력 인터페이스, 출발 및 목적 주소, 출발 및 목적 포트, 제3/4계층 프로토콜로 이뤄진 튜플을 통해 플로테이블 항목을 나타낸다. 각 항목에는 또한 패킷을 포워딩 하기 위한 목적 인터페이스와 (링크 계층 목적 주소를 갱신하기 위한) 게이트웨이 주소를 캐싱 한다. ttl 및 hoplimit 필드도 줄어든다. 그래서 플로테이블은 패킷이 전통적 포워딩 경로를 우회할 수 있는 또 다른 경로를 제공한다. 플로테이블은 prerouting 훅 전에 있는 ingress 훅에 위치한다. forward 체인에서 flow 식을 통해 오프로드 하고 싶은 흐름을 선택할 수 있다. 플로테이블은 주소 패밀리와 이름으로 식별된다. 주소 패밀리는 <code>ip</code>, <code>ip6</code>, <code>inet</code> 중 하나여야 한다. <code>inet</code> 주소 패밀리는 하이브리드 IPv4/IPv6 테이블을 만드는 데 쓰는 가상의 패밀리다. 패밀리를 지정하지 않으면 기본으로 <code>ip</code>를 쓴다.</p>
<p><code>priority</code>는 부호 있는 정수나 (0을 나타내는) <code>filter</code>일 수 있다. 더하기와 빼기를 써서 상대 우선순위를 지정할 수 있다. 가령 <code>filter + 5</code>는 <code>5</code>를 나타낸다.</p>
<dl>
<dt><code>add</code></dt>
<dd>지정한 패밀리에 지정한 이름으로 새 플로테이블 추가.</dd>
<dt><code>delete</code></dt>
<dd>지정한 플로테이블 삭제.</dd>
<dt><code>list</code></dt>
<dd>모든 플로테이블 나열.</dd>
</dl>
<h2 id="_18">상태 객체</h2>
<pre>
{<strong>add</strong> | <strong>delete</strong> | <strong>list</strong> | <strong>reset</strong>} <em>type</em> [<em>family</em>] <em>table object</em>
<strong>delete</strong> <em>type</em> [<em>family</em>] <em>table</em> <strong>handle</strong> <em>handle</em>
<strong>list counters</strong> [<em>family</em>]
<strong>list quotas</strong> [<em>family</em>]
</pre>

<p>상태 객체는 테이블에 붙으며 유일한 이름으로 식별된다. 규칙들에서 상태 정보를 모은 것이며 규칙에서 참조하려면 "타입 이름" 키워드를 쓴다. 가령 "counter 이름"으로 쓴다.</p>
<dl>
<dt><code>add</code></dt>
<dd>지정한 테이블에 새 상태 객체 추가.</dd>
<dt><code>delete</code></dt>
<dd>지정한 객체 삭제.</dd>
<dt><code>list</code></dt>
<dd>객체가 담은 상태 정보 표시.</dd>
<dt><code>reset</code></dt>
<dd>상태 객체 나열 및 재설정.</dd>
</dl>
<h3 id="ct-helper">ct helper</h3>
<pre>
<strong>ct helper</strong> <em>helper</em> <strong>{ type</strong> <em>type</em> <strong>protocol</strong> <em>protocol</em> <strong>;</strong> [<strong>l3proto</strong> <em>family</em> <strong>;</strong>] <strong>}</strong>
</pre>

<p>ct helper로 연결 추적 헬퍼를 정의하며, 그걸 <code>ct helper set</code> 문으로 사용할 수 있다. <code>type</code>과 <code>protocol</code>은 필수고 l3proto는 지정하지 않으면 테이블 패밀리로 정한다. 즉 inet 테이블에서는 커널에서 지원하면 ipv4 및 ipv6 헬퍼 백엔드를 모두 적재하려고 시도하게 된다.</p>
<p>표 10: conntrack 헬퍼 지정</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>헬퍼 타입 이름</td>
<td>따옴표 친 문자열 (예: "ftp")</td>
</tr>
<tr>
<td>protocol</td>
<td>헬퍼의 제4계층 프로토콜</td>
<td>문자열 (예: tcp)</td>
</tr>
<tr>
<td>l3proto</td>
<td>헬퍼의 제3계층 프로토콜</td>
<td>주소 패밀리 (예: ip)</td>
</tr>
</tbody>
</table>
<h4 id="ftp">ftp 헬퍼 정의하고 할당하기</h4>
<p>iptables와 달리 conntrack 검색이 완료된 후에, 예를 들어 기본 훅 우선순위 0으로 헬퍼 할당을 수행해야 한다.</p>
<pre><code class="text">table inet myhelpers {
    ct helper ftp-standard {
        type &quot;ftp&quot; protocol tcp
    }
    chain prerouting {
        type filter hook prerouting priority 0;
        tcp dport 21 ct helper set &quot;ftp-standard&quot;
    }
}
</code></pre>

<h3 id="ct-timeout">ct timeout</h3>
<pre>
<strong>ct timeout</strong> <em>name</em> <strong>{ protocol</strong> <em>protocol</em> <strong>; policy = {</strong> <em>state</em><strong>:</strong> <em>value</em> [<strong>,</strong> ...] <strong>} ;</strong> [<strong>l3proto</strong> <em>family</em> <strong>;</strong>] <strong>}</strong>
</pre>

<p>ct timeout으로 연결 추적 타임아웃 값을 변경한다. <code>ct timeout set</code> 문으로 타임아웃 정책을 할당한다. <code>protocol</code>과 <code>policy</code>는 필수고 l3proto는 지정하지 않으면 테이블 패밀리로 정한다.</p>
<p>표 11: conntrack 타임아웃 지정</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocol</td>
<td>타임아웃 객체의 제4계층 프로토콜</td>
<td>문자열 (예: tcp)</td>
</tr>
<tr>
<td>state</td>
<td>연결 상태 이름</td>
<td>문자열 (예: "established")</td>
</tr>
<tr>
<td>value</td>
<td>연결 상태의 타임아웃 값</td>
<td>부호 없는 정수</td>
</tr>
<tr>
<td>l3proto</td>
<td>타임아웃 객체의 제3계층 프로토콜</td>
<td>주소 패밀리 (예: ip)</td>
</tr>
</tbody>
</table>
<h4 id="ct">ct 타임아웃 정책 정의하고 할당하기</h4>
<pre><code class="text">table ip filter {
        ct timeout customtimeout {
                protocol tcp;
                l3proto ip
                policy = { established: 120, close: 20 }
        }

        chain output {
                type filter hook output priority filter; policy accept;
                ct timeout set &quot;customtimeout&quot;
        }
}
</code></pre>

<h4 id="_19">갱신된 타임아웃 정책 확인하기</h4>
<pre><code class="text">% conntrack -E
</code></pre>

<p>다음처럼 나와야 한다.</p>
<pre><code class="text">[UPDATE] tcp      6 120 ESTABLISHED src=172.16.19.128 dst=172.16.19.1
sport=22 dport=41360 [UNREPLIED] src=172.16.19.1 dst=172.16.19.128
sport=41360 dport=22
</code></pre>

<h3 id="ct-expectation">ct expectation</h3>
<pre>
<strong>ct expectation</strong> <em>name</em> <strong>{ protocol</strong> <em>protocol</em> <strong>; dport</strong> <em>dport</em> <strong>; timeout</strong> <em>timeout</em> <strong>; size</strong> <em>size</em> <strong>;</strong> [<strong>l3proto</strong> <em>family</em> <strong>;</strong>] <strong>}</strong>
</pre>

<p>ct expectation으로 연결 예상을 만든다. <code>ct expectation set</code> 문으로 예상을 할당한다. <code>protocol</code>, <code>dport</code>, <code>timeout</code>, <code>size</code>는 필수고 l3proto는 지정하지 않으면 테이블 패밀리로 정한다.</p>
<p>표 12: 연결 예상 지정</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>protocol</td>
<td>예상 객체의 제4계층 프로토콜</td>
<td>문자열 (예: tcp)</td>
</tr>
<tr>
<td>dport</td>
<td>예상 연결의 목적 포트</td>
<td>부호 없는 정수</td>
</tr>
<tr>
<td>timeout</td>
<td>예상의 타임아웃 값</td>
<td>부호 없는 정수</td>
</tr>
<tr>
<td>size</td>
<td>예상의 크기 값</td>
<td>부호 없는 정수</td>
</tr>
<tr>
<td>l3proto</td>
<td>예상 객체의 제3계층 프로토콜</td>
<td>주소 패밀리 (예: ip)</td>
</tr>
</tbody>
</table>
<h4 id="ct_1">ct 예상 정책 정의하고 할당하기</h4>
<pre><code class="text">table ip filter {
        ct expectation expect {
                protocol udp
                dport 9876
                timeout 2m
                size 8
                l3proto ip
        }

        chain input {
                type filter hook input priority filter; policy accept;
                ct expectation set &quot;expect&quot;
        }
}
</code></pre>

<h3 id="counter">counter</h3>
<pre>
<strong>counter</strong> [<em>packets bytes</em>]
</pre>

<p>표 13: 카운터 지정</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>packets</td>
<td>시작 패킷 카운트</td>
<td>부호 없는 정수 (64비트)</td>
</tr>
<tr>
<td>bytes</td>
<td>시작 바이트 카운트</td>
<td>부호 없는 정수 (64비트)</td>
</tr>
</tbody>
</table>
<h3 id="quota">quota</h3>
<pre>
<strong>quota</strong> [<strong>over</strong> | <strong>until</strong>] [<em>used</em>]
</pre>

<p>표 14: 쿼터 지정</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>quota</td>
<td>쿼터 제한, 쿼터 이름으로 사용</td>
<td>인자 둘. 부호 없는 정수(64비트)와 문자열: bytes, kbytes, mbytes. 그 인자 앞에 "over"와 "until"이 옴.</td>
</tr>
<tr>
<td>used</td>
<td>쿼터의 시작 값</td>
<td>인자 둘. 부호 없는 정수(64비트)와 문자열: bytes, kbytes, mbytes</td>
</tr>
</tbody>
</table>
<h2 id="_20">식</h2>
<p>식은 값을 나타내는데, 네트워크 주소나 포트 번호 같은 상수일 수도 있고 룰셋을 평가하면서 패킷에서 수집한 데이터일 수도 있다. 이진식, 논리식, 관계식 등으로 식들을 결합해서 (검사를 위한) 복합식 내지 관계식을 만들 수 있다. NAT나 패킷 마킹 같은 특정 동작에 인자로 쓰기도 한다.</p>
<p>각 식에는 데이터 타입이 있고, 그에 따라 크기, 심볼 값의 파싱 및 표현 방법, 다른 식과의 타입 호환성이 결정된다.</p>
<h3 id="describe">describe 명령</h3>
<pre>
<strong>describe</strong> <em>expression</em> | <em>data type</em>
</pre>

<p><code>describe</code> 명령은 식의 종류와 그 데이터 타입에 대한 정보를 보여 준다. 데이터 타입을 줄 수도 있으며, 그 경우 nft는 그 타입에 대한 추가 정보를 표시한다.</p>
<h4 id="describe_1">describe 명령</h4>
<pre><code class="text">$ nft describe tcp flags
payload expression, datatype tcp_flag (TCP flag) (basetype bitmask, integer), 8 bits

predefined symbolic constants:
fin                           0x01
syn                           0x02
rst                           0x04
psh                           0x08
ack                           0x10
urg                           0x20
ecn                           0x40
cwr                           0x80
</code></pre>

<h2 id="_21">데이터 타입</h2>
<p>데이터 타입에 따라 크기, 심볼 값의 파싱 및 표현 방법, 식의 타입 호환성이 결정된다. 여러 가지 전역 데이터 타입이 있으며, 추가로 어떤 식들에서 그 식 종류에 한정된 데이터 타입을 추가로 정의한다. 대부분의 데이터 타입은 크기가 고정돼 있지만 일부는 크기가 동적일 수 있는데, 가령 문자열 타입이 그렇다.</p>
<p>어떤 타입에는 미리 정의된 심볼 상수들이 있다. nft <code>describe</code> 명령으로 그 상수들을 나열할 수 있다.</p>
<pre><code class="text">$ nft describe ct_state
datatype ct_state (conntrack state) (basetype bitmask, integer), 32 bits

pre-defined symbolic constants (in hexadecimal):
invalid                         0x00000001
new ...
</code></pre>

<p>하위 타입에서 다른 타입이 파생될 수도 있다. 예를 들어 IPv4 주소 타입은 정수 타입에서 파생된 것인데, IPv4 주소를 정수 값으로도 나타낼 수 있다는 뜻이다.</p>
<p>특정 맥락(집합 및 맵 정의)에서는 데이터 타입을 명시적으로 지정해야 한다. 타입마다 있는 이름을 거기 쓴다.</p>
<h3 id="_22">정수 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>정수</td>
<td>integer</td>
<td>가변</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>정수 타입은 수 값에 쓴다. 10진수, 16진수, 8진수로 나타낼 수 있다. 정수 타입에는 정해진 크기가 없으며 쓰이는 식에 따라 그 크기가 결정된다.</p>
<h3 id="_23">비트마스크 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>비트마스크</td>
<td>bitmask</td>
<td>가변</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>비트마스크 타입(<code>bitmask</code>)은 비트마스크에 쓴다.</p>
<h3 id="_24">문자열 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>문자열</td>
<td>string</td>
<td>가변</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>문자열 타입은 문자열에 쓴다. 문자열은 알파벳 문자(a-zA-Z)로 시작하고 0개 이상의 알파벳이나 숫자, /, -, _, . 문자가 온다. 추가로 큰괄호(")로 감싼 건 뭐든 문자열로 인식한다.</p>
<h4 id="_25">문자열 표시</h4>
<pre><code class="text"># 인터페이스 이름
filter input iifname eth0

# 기이한 인터페이스 이름
filter input iifname &quot;(eth0)&quot;
</code></pre>

<h3 id="_26">링크 계층 주소 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>링크 계층 주소</td>
<td>lladdr</td>
<td>가변</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>링크 계층 주소 타입은 링크 계층 주소에 쓴다. 링크 계층 주소는 가변 개수의 16진수 숫자 두개 묶음을 콜론(:)으로 구분해서 나타낸다.</p>
<h4 id="_27">링크 계층 주소 표시</h4>
<pre><code class="text"># 이더넷 목적 MAC 주소
filter input ether daddr 20:c9:d0:43:12:d9
</code></pre>

<h3 id="ipv4">IPv4 주소 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPv4 주소</td>
<td>ipv4_addr</td>
<td>32비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>IPv4 주소 타입은 IPv4 주소에 쓴다. 점 찍은 10진수, 점 찍은 16진수, 점 찍은 8진수, 10진수, 16진수, 8진수 표기, 또는 호스트 이름으로 주소를 나타낸다. 호스트 이름은 표준 시스템 리졸버를 이용해 해석한다.</p>
<h4 id="ipv4_1">IPv4 주소 표시</h4>
<pre><code class="text"># 점 찍은 10진수 표기
filter output ip daddr 127.0.0.1

# 호스트 이름
filter output ip daddr localhost
</code></pre>

<h3 id="ipv6">IPv6 주소 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPv6 주소</td>
<td>ipv6_addr</td>
<td>128비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>IPv6 주소 타입은 IPv6 주소에 쓴다. 호스트 이름이나 콜론으로 구분된 16진수 하프워드들로 나타낸다. 포트 번호와 구별하기 위해 주소를 대괄호("[]")로 감쌀 수도 있다.</p>
<h4 id="ipv6_1">IPv6 주소 표시</h4>
<pre><code class="text"># 축약된 루프백 주소
filter output ip6 daddr ::1
</code></pre>

<h4 id="ipv6_2">대괄호 표기법을 쓴 IPv6 주소 표시</h4>
<pre><code class="text"># []가 없으면 포트 번호(22)가 ipv6 주소의 일부인 것으로
# 파싱 됨
ip6 nat prerouting tcp dport 2222 dnat to [1ce::d0]:22
</code></pre>

<h3 id="_28">불리언 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>불리언</td>
<td>boolean</td>
<td>1비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>불리언 타입은 편의를 위한 사용자 공간의 문법적 타입이다. (보통 암묵적인) 관계 식의 오른쪽에 쓰여서 왼쪽 식을 불리언 (일반적으로 존재 여부) 검사로 바꾼다.</p>
<p>표 15: 다음 키워드들은 자동으로 해당 값의 불리언 타입으로 결정된다.</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>exists</td>
<td>1</td>
</tr>
<tr>
<td>missing</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>표 16: 불리언 비교를 지원하는 식들</p>
<table>
<thead>
<tr>
<th>식</th>
<th>동작</th>
</tr>
</thead>
<tbody>
<tr>
<td>fib</td>
<td>라우트 존재 확인.</td>
</tr>
<tr>
<td>exthdr</td>
<td>IPv6 확장 헤더 존재 확인.</td>
</tr>
<tr>
<td>tcp option</td>
<td>TCP 옵션 헤더 존재 확인.</td>
</tr>
</tbody>
</table>
<h4 id="_29">불리언 지정</h4>
<pre><code class="text"># 라우트 존재하면 일치
filter input fib daddr . iif oif exists

# IPv6 트래픽 중 단편화 안 된 패킷에 일치
filter input exthdr frag missing

# TCP 타임스탬프 옵션이 있으면 일치
filter input tcp option timestamp exists
</code></pre>

<h3 id="icmp">ICMP 타입 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>ICMP 타입</td>
<td>icmp_type</td>
<td>8비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>ICMP 타입 타입은 ICMP 헤더의 type 필드를 간편하게 지정하는 데 쓴다.</p>
<p>표 17: ICMP 타입 지정 시 사용할 수 있는 키워드</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>echo-reply</td>
<td>0</td>
</tr>
<tr>
<td>destination-unreachable</td>
<td>3</td>
</tr>
<tr>
<td>source-quench</td>
<td>4</td>
</tr>
<tr>
<td>redirect</td>
<td>5</td>
</tr>
<tr>
<td>echo-request</td>
<td>8</td>
</tr>
<tr>
<td>router-advertisement</td>
<td>9</td>
</tr>
<tr>
<td>router-solicitation</td>
<td>10</td>
</tr>
<tr>
<td>time-exceeded</td>
<td>11</td>
</tr>
<tr>
<td>parameter-problem</td>
<td>12</td>
</tr>
<tr>
<td>timestamp-request</td>
<td>13</td>
</tr>
<tr>
<td>timestamp-reply</td>
<td>14</td>
</tr>
<tr>
<td>info-request</td>
<td>15</td>
</tr>
<tr>
<td>info-reply</td>
<td>16</td>
</tr>
<tr>
<td>address-mask-request</td>
<td>17</td>
</tr>
<tr>
<td>address-mask-reply</td>
<td>18</td>
</tr>
</tbody>
</table>
<h4 id="icmp_1">ICMP 타입 지정</h4>
<pre><code class="text"># 핑 패킷 일치
filter output icmp type { echo-request, echo-reply }
</code></pre>

<h3 id="icmp_2">ICMP 코드 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>ICMP 코드</td>
<td>icmp_code</td>
<td>8비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>ICMP 코드 타입은 ICMP 헤더의 code 필드를 간편하게 지정하는 데 쓴다.</p>
<p>표 18: ICMP 코드 지정 시 사용할 수 있는 키워드</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>net-unreachable</td>
<td>0</td>
</tr>
<tr>
<td>host-unreachable</td>
<td>1</td>
</tr>
<tr>
<td>prot-unreachable</td>
<td>2</td>
</tr>
<tr>
<td>port-unreachable</td>
<td>3</td>
</tr>
<tr>
<td>net-prohibited</td>
<td>9</td>
</tr>
<tr>
<td>host-prohibited</td>
<td>10</td>
</tr>
<tr>
<td>admin-prohibited</td>
<td>13</td>
</tr>
</tbody>
</table>
<h3 id="icmpv6">ICMPv6 타입 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>ICMPv6 타입</td>
<td>icmpv6_type</td>
<td>8비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>ICMPv6 타입 타입은 ICMPv6 헤더의 type 필드를 간편하게 지정하는 데 쓴다.</p>
<p>표 19: ICMPv6 타입 지정 시 사용할 수 있는 키워드</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>destination-unreachable</td>
<td>1</td>
</tr>
<tr>
<td>packet-too-big</td>
<td>2</td>
</tr>
<tr>
<td>time-exceeded</td>
<td>3</td>
</tr>
<tr>
<td>parameter-problem</td>
<td>4</td>
</tr>
<tr>
<td>echo-request</td>
<td>128</td>
</tr>
<tr>
<td>echo-reply</td>
<td>129</td>
</tr>
<tr>
<td>mld-listener-query</td>
<td>130</td>
</tr>
<tr>
<td>mld-listener-report</td>
<td>131</td>
</tr>
<tr>
<td>mld-listener-done</td>
<td>132</td>
</tr>
<tr>
<td>mld-listener-reduction</td>
<td>132</td>
</tr>
<tr>
<td>nd-router-solicit</td>
<td>133</td>
</tr>
<tr>
<td>nd-router-advert</td>
<td>134</td>
</tr>
<tr>
<td>nd-neighbor-solicit</td>
<td>135</td>
</tr>
<tr>
<td>nd-neighbor-advert</td>
<td>136</td>
</tr>
<tr>
<td>nd-redirect</td>
<td>137</td>
</tr>
<tr>
<td>router-renumbering</td>
<td>138</td>
</tr>
<tr>
<td>ind-neighbor-solicit</td>
<td>141</td>
</tr>
<tr>
<td>ind-neighbor-advert</td>
<td>142</td>
</tr>
<tr>
<td>mld2-listener-report</td>
<td>143</td>
</tr>
</tbody>
</table>
<h4 id="icmpv6_1">ICMPv6 타입 지정</h4>
<pre><code class="text"># ICMPv6 핑 패킷 일치
filter output icmpv6 type { echo-request, echo-reply }
</code></pre>

<h3 id="icmpv6_2">ICMPv6 코드 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>ICMPv6 코드</td>
<td>icmpv6_code</td>
<td>8비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>ICMPv6 코드 타입은 ICMPv6 헤더의 code 필드를 간편하게 지정하는 데 쓴다.</p>
<p>표 20: ICMPv6 코드 지정 시 사용할 수 있는 키워드</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-route</td>
<td>0</td>
</tr>
<tr>
<td>admin-prohibited</td>
<td>1</td>
</tr>
<tr>
<td>addr-unreachable</td>
<td>3</td>
</tr>
<tr>
<td>port-unreachable</td>
<td>4</td>
</tr>
<tr>
<td>policy-fail</td>
<td>5</td>
</tr>
<tr>
<td>reject-route</td>
<td>6</td>
</tr>
</tbody>
</table>
<h3 id="icmpvx">ICMPvX 코드 타입</h3>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>ICMPvX 코드</td>
<td>icmpv6_type</td>
<td>8비트</td>
<td>integer</td>
</tr>
</tbody>
</table>
<p>ICMPvX 코드 타입은 ICMP와 ICMPv6의 코드 타입에서 겹치는 값들을 추출한 것이며 inet 패밀리에서 쓰기 위한 것이다.</p>
<p>표 21: ICMPvX 코드 지정 시 사용할 수 있는 키워드</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>no-route</td>
<td>0</td>
</tr>
<tr>
<td>port-unreachable</td>
<td>1</td>
</tr>
<tr>
<td>host-unreachable</td>
<td>2</td>
</tr>
<tr>
<td>admin-prohibited</td>
<td>3</td>
</tr>
</tbody>
</table>
<h3 id="conntrack">conntrack 타입</h3>
<p>표 22: ct 식과 문에 쓰는 타입들</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>키워드</th>
<th>크기</th>
<th>기반 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>conntrack 상태</td>
<td>ct_state</td>
<td>4바이트</td>
<td>bitmask</td>
</tr>
<tr>
<td>conntrack 방향</td>
<td>ct_dir</td>
<td>8비트</td>
<td>integer</td>
</tr>
<tr>
<td>conntrack 상황</td>
<td>ct_status</td>
<td>4바이트</td>
<td>bitmask</td>
</tr>
<tr>
<td>conntrack 이벤트 비트</td>
<td>ct_event</td>
<td>4바이트</td>
<td>bitmask</td>
</tr>
<tr>
<td>conntrack 레이블</td>
<td>ct_label</td>
<td>128비트</td>
<td>bitmask</td>
</tr>
</tbody>
</table>
<p>위의 타입들 각각에 대해 편의를 위한 키워드들이 있다.</p>
<p>표 23: conntrack 상태 (ct_state)</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>invalid</td>
<td>1</td>
</tr>
<tr>
<td>established</td>
<td>2</td>
</tr>
<tr>
<td>related</td>
<td>4</td>
</tr>
<tr>
<td>new</td>
<td>8</td>
</tr>
<tr>
<td>untracked</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>표 24: conntrack 방향 (ct_dir)</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>original</td>
<td>0</td>
</tr>
<tr>
<td>reply</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>표 25: conntrack 상황 (ct_status)</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>expected</td>
<td>1</td>
</tr>
<tr>
<td>seen-reply</td>
<td>2</td>
</tr>
<tr>
<td>assured</td>
<td>4</td>
</tr>
<tr>
<td>confirmed</td>
<td>8</td>
</tr>
<tr>
<td>snat</td>
<td>16</td>
</tr>
<tr>
<td>dnat</td>
<td>32</td>
</tr>
<tr>
<td>dying</td>
<td>512</td>
</tr>
</tbody>
</table>
<p>표 26: conntrack 이벤트 비트 (ct_event)</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>new</td>
<td>1</td>
</tr>
<tr>
<td>related</td>
<td>2</td>
</tr>
<tr>
<td>destroy</td>
<td>4</td>
</tr>
<tr>
<td>reply</td>
<td>8</td>
</tr>
<tr>
<td>assured</td>
<td>16</td>
</tr>
<tr>
<td>protoinfo</td>
<td>32</td>
</tr>
<tr>
<td>helper</td>
<td>64</td>
</tr>
<tr>
<td>mark</td>
<td>128</td>
</tr>
<tr>
<td>seqadj</td>
<td>256</td>
</tr>
<tr>
<td>secmark</td>
<td>512</td>
</tr>
<tr>
<td>label</td>
<td>1024</td>
</tr>
</tbody>
</table>
<p>conntrack 레이블 타입(ct_label)에 가능한 키워드들은 런타임에 <code>/etc/connlabel.conf</code>에서 읽어 들인다.</p>
<h2 id="_30">기본 식</h2>
<p>가장 하위의 식이 기본 식이며 상수, 또는 패킷 페이로드나 메타 데이터, 상태 모듈에서 온 데이터 하나를 나타낸다.</p>
<h3 id="meta">meta 식</h3>
<pre>
<strong>meta</strong> {<strong>length</strong> | <strong>nfproto</strong> | <strong>l4proto</strong> | <strong>protocol</strong> | <strong>priority</strong>}
[<strong>meta</strong>] {<strong>mark</strong> | <strong>iif</strong> | <strong>iifname</strong> | <strong>iiftype</strong> | <strong>oif</strong> | <strong>oifname</strong> | <strong>oiftype</strong> | <strong>skuid</strong> | <strong>skgid</strong> | <strong>nftrace</strong> | <strong>rtclassid</strong> | <strong>ibrname</strong> | <strong>obrname</strong> | <strong>pkttype</strong> | <strong>cpu</strong> | <strong>iifgroup</strong> | <strong>oifgroup</strong> | <strong>cgroup</strong> | <strong>random</strong> | <strong>ipsec</strong> | <strong>iifkind</strong> | <strong>oifkind</strong> | <strong>time</strong> | <strong>hour</strong> | <strong>day</strong>}
</pre>

<p>meta 식은 패킷과 연관된 메타 데이터를 나타내는 식이다.</p>
<p>meta 식에는 지정 meta 식과 비지정 meta 식 두 종류가 있다. 지정 meta 식에선 메타 키 앞에 meta 키워드가 필요하고 비지정 meta 식은 메타 키를 바로 쓰거나 지정 meta 식으로 지정할 수 있다. meta l4proto는 IPv4나 IPv6 패킷에 포함된 특정 전송 프로토콜을 맞춰 보는 데 유용하다. IPv6 패킷에 IPv6 확장 헤더가 있으면 그 역시 건너뛰게 된다.</p>
<p>meta iif, oif, iifname, oifname는 패킷이 도착한 인터페이스와 나갈 인터페이스를 맞춰 보는 데 쓴다.</p>
<p>iif와 oif는 인터페이스 번호로 맞춰 보는 반면 iifname과 oifname은 인터페이스 이름으로 맞춰 본다. 이 둘은 같지 않다. 가령 다음 규칙을 생각해 보면,</p>
<pre><code class="text">filter input meta iif &quot;foo&quot;
</code></pre>

<p>인터페이스 "foo"가 존재하는 경우에만 이 규칙을 추가할 수 있다. 또한 그 규칙은 인터페이스 "foo"의 이름이 "bar"로 바뀐 경우에도 계속 일치하게 된다.</p>
<p>그렇게 되는 이유는 내부적으로 인터페이스 번호를 쓰기 때문이다. tun/tap이나 다이얼업 인터페이스(예를 들어 ppp)처럼 동적으로 생성되는 인터페이스인 경우 iifname과 oifname을 쓰는 게 더 나을 수 있다.</p>
<p>그런 경우에 이름을 쓰면 규칙을 추가하기 위해 인터페이스가 꼭 존재할 필요가 없고, 인터페이스 이름이 바뀌면 일치하지 않게 됐다가 인터페이스가 삭제되고 같은 이름의 새 인터페이스가 생기면 다시 일치하게 된다.</p>
<p>표 27: meta 식 타입</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td>바이트 단위 패킷 길이</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>nfproto</td>
<td>실제 훅 프로토콜 패밀리, inet 테이블에서만 유용</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>l4proto</td>
<td>제4계층 프로토콜, ipv6 확장 헤더 건너뜀</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>protocol</td>
<td>EtherType 프로토콜 값</td>
<td>ether_type</td>
</tr>
<tr>
<td>priority</td>
<td>TC 패킷 우선순위</td>
<td>tc_handle</td>
</tr>
<tr>
<td>mark</td>
<td>패킷 마크</td>
<td>mark</td>
</tr>
<tr>
<td>iif</td>
<td>입력 인터페이스 번호</td>
<td>iface_index</td>
</tr>
<tr>
<td>iifname</td>
<td>입력 인터페이스 이름</td>
<td>ifname</td>
</tr>
<tr>
<td>iiftype</td>
<td>입력 인터페이스 타입</td>
<td>iface_type</td>
</tr>
<tr>
<td>oif</td>
<td>출력 인터페이스 번호</td>
<td>iface_index</td>
</tr>
<tr>
<td>oifname</td>
<td>출력 인터페이스 이름</td>
<td>ifname</td>
</tr>
<tr>
<td>oiftype</td>
<td>출력 인터페이스 하드웨어 타입</td>
<td>iface_type</td>
</tr>
<tr>
<td>skuid</td>
<td>발신 소켓에 연계된 UID</td>
<td>uid</td>
</tr>
<tr>
<td>skgid</td>
<td>발신 소켓에 연계된 GID</td>
<td>gid</td>
</tr>
<tr>
<td>rtclassid</td>
<td>라우팅 realm</td>
<td>realm</td>
</tr>
<tr>
<td>ibrname</td>
<td>입력 브리지 인터페이스 이름</td>
<td>ifname</td>
</tr>
<tr>
<td>obrname</td>
<td>출력 브리지 인터페이스 이름</td>
<td>ifname</td>
</tr>
<tr>
<td>pkttype</td>
<td>패킷 타입</td>
<td>pkt_type</td>
</tr>
<tr>
<td>cpu</td>
<td>패킷 처리 중인 cpu 번호</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>iifgroup</td>
<td>입력 장치 그룹</td>
<td>devgroup</td>
</tr>
<tr>
<td>oifgroup</td>
<td>출력 장치 그룹</td>
<td>devgroup</td>
</tr>
<tr>
<td>cgroup</td>
<td>제어 그룹 ID</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>random</td>
<td>유사 난수</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>ipsec</td>
<td>불리언</td>
<td>boolean (1비트)</td>
</tr>
<tr>
<td>iifkind</td>
<td>입력 인터페이스 종류</td>
<td></td>
</tr>
<tr>
<td>oifkind</td>
<td>출력 인터페이스 종류</td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>패킷을 수신한 절대 시간</td>
<td>integer (32비트) 또는 string</td>
</tr>
<tr>
<td>day</td>
<td>주 중 요일</td>
<td>integer (8비트) 또는 string</td>
</tr>
<tr>
<td>hour</td>
<td>하루 중 시간</td>
<td>string</td>
</tr>
</tbody>
</table>
<p>표 28: meta 식 한정 타입</p>
<table>
<thead>
<tr>
<th>타입</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>iface_index</td>
<td>인터페이스 번호 (32비트 수). 숫자로 또는 기존 인터페이스의 이름으로 지정 가능.</td>
</tr>
<tr>
<td>ifname</td>
<td>인터페이스 이름 (16바이트 문자열). 존재하지 않아도 됨.</td>
</tr>
<tr>
<td>iface_type</td>
<td>인터페이스 타입 (16비트 수).</td>
</tr>
<tr>
<td>uid</td>
<td>사용자 ID (32비트 수). 숫자로 또는 사용자 이름으로 지정 가능.</td>
</tr>
<tr>
<td>gid</td>
<td>그룹 ID (32비트 수). 숫자로 또는 그룹 이름으로 지정 가능.</td>
</tr>
<tr>
<td>realm</td>
<td>라우팅 realm (32비트 수). 숫자로 또는 /etc/iproute2/rt_realms에 정의된 심볼 이름으로 지정 가능.</td>
</tr>
<tr>
<td>devgroup_type</td>
<td>장치 그룹 (32비트 수). 숫자로 또는 /etc/iproute2/group에 정의된 심볼 이름으로 지정 가능.</td>
</tr>
<tr>
<td>pkt_type</td>
<td>패킷 종류: <code>host</code> (로컬 호스트 향함), <code>broadcast</code> (모두에게), <code>multicast</code> (그룹에게), <code>other</code> (다른 호스트 향함).</td>
</tr>
<tr>
<td>ifkind</td>
<td>인터페이스 종류 (16바이트 문자열). 존재하지 않아도 됨.</td>
</tr>
<tr>
<td>time</td>
<td>정수 또는 ISO 형식 날짜. 예를 들어 "2019-06-06 17:00". 시간과 초는 선택적이며 원하는 생략 가능. 생략 시 자정을 상정함. 즉 "2019-06-06", "2019-06-06 00:00", "2019-06-06 00:00:00"은 동등함. 정수를 주는 경우 유닉스 타임스탬프라고 상정함.</td>
</tr>
<tr>
<td>day</td>
<td>주 중 요일("Monday", "Tuesday", 등) 또는 0에서 6 사이 정수. 문자열 일치 여부에 대소문자를 구별하지 않으며 완전히 일치할 필요 없음. (가령 "Mon"이라고 하면 "Monday"에 일치함.) 정수를 주는 경우 0이 일요일이고 6이 토요일임.</td>
</tr>
<tr>
<td>hour</td>
<td>24시간 형식으로 시간을 나타내는 문자열. 초를 선택적으로 지정할 수 있음. 예를 들어 17:00과 17:00:00이 동등함.</td>
</tr>
</tbody>
</table>
<h4 id="meta_1">meta 식 사용하기</h4>
<pre><code class="text"># 지정 meta 식
filter output meta oif eth0

# 비지정 meta 식
filter output oif eth0

# 패킷이 ipsec 처리 대상이었음
raw prerouting meta ipsec exists accept
</code></pre>

<h3 id="socket">socket 식</h3>
<pre>
<strong>socket</strong> {<strong>transparent</strong> | <strong>mark</strong>}
</pre>

<p>socket 식을 사용해 기존의 열린 TCP/UDP 소켓이나 패킷에 연계될 수 있는 소켓 속성을 탐색할 수 있다. 수립 상태이거나 0 아닌 주소에 (가능하면 로컬 아닌 주소에) 결속된 리스닝 소켓을 찾는다.</p>
<p>표 29: 사용 가능한 소켓 속성</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>transparent</td>
<td>찾은 소켓의 IP_TRANSPARENT 소켓 옵션 값. 0 또는 1일 수 있음.</td>
<td>boolean (1비트)</td>
</tr>
<tr>
<td>mark</td>
<td>소켓 마크(SOL_SOCKET, SO_MARK) 값.</td>
<td>mark</td>
</tr>
</tbody>
</table>
<h4 id="_31">소켓 식 사용하기</h4>
<pre><code class="text"># 투명 소켓에 대응하는 패킷에 표시
table inet x {
    chain y {
        type filter hook prerouting priority -150; policy accept;
        socket transparent 1 mark set 0x00000001 accept
    }
}

# mark 값이 15인 소켓에 대응하는 패킷 추적
table inet x {
    chain y {
        type filter hook prerouting priority -150; policy accept;
        socket mark 0x0000000f nftrace set 1
    }
}

# 패킷 mark를 소켓 mark로 설정
table inet x {
    chain y {
        type filter hook prerouting priority -150; policy accept;
        tcp dport 8080 mark set socket mark
    }
}
</code></pre>

<h3 id="osf">osf 식</h3>
<pre>
<strong>osf</strong> [<strong>ttl</strong> {<strong>loose</strong> | <strong>skip</strong>}] {<strong>name</strong> | <strong>version</strong>}
</pre>

<p>osf 식은 수동적 운영 체제 감식을 한다. 이 식은 SYN 비트가 설정된 패킷에서 가져온 몇 가지 데이터(윈도 크기, MSS, 옵션 및 순서, DF 등)를 비교한다.</p>
<p>표 30: 사용 가능한 osf 속성</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>ttl</td>
<td>운영 체제를 판단하기 위해 패킷의 TTL 검사를 하기.</td>
<td>string</td>
</tr>
<tr>
<td>version</td>
<td>패킷에서 OS 버전 검사 하기.</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>맞춰 볼 OS 시그너처 이름. pf.os 파일에 전체 시그너처들이 있음. 식에서 탐지할 수 없었던 OS 시그너처엔 "unknown" 사용.</td>
<td>string</td>
</tr>
</tbody>
</table>
<h4 id="ttl">사용 가능한 ttl 값</h4>
<p>TTL 속성을 주지 않으면 IP 헤더의 값과 핑거프린트 TTL 값이 같은지 비교한다. 일반적으로 LAN에서 잘 동작한다.</p>
<ul>
<li>loose: IP 헤더의 TTL이 핑거프린트 값보다 작은지 검사한다. 전역 라우팅 가능 주소에 잘 동작한다.</li>
<li>skip: TTL을 아예 비교하지 않는다.</li>
</ul>
<h4 id="osf_1">osf 식 사용하기</h4>
<pre><code class="text"># TTL 비교 없이 &quot;Linux&quot; OS 계열 시그너처에 일치하는 패킷 허용하기
table inet x {
    chain y {
        type filter hook input priority 0; policy accept;
        osf ttl skip name &quot;Linux&quot;
    }
}
</code></pre>

<h3 id="fib">fib 식</h3>
<pre>
<strong>fib</strong> {<strong>saddr</strong> | <strong>daddr</strong> | <strong>mark</strong> | <strong>iif</strong> | <strong>oif</strong>} [<strong>.</strong> ...] {<strong>oif</strong> | <strong>oifname</strong> | <strong>type</strong>}
</pre>

<p>fib 식은 fib(forwarding information base)를 조회해서 특정 주소가 사용하게 될 출력 인터페이스 번호 같은 정보를 얻는다. 입력은 fib 검색 함수 입력으로 쓸 요소들의 튜플이다.</p>
<p>표 31: fib 식 한정 타입</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>oif</td>
<td>출력 인터페이스 번호</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>oifname</td>
<td>출력 인터페이스 이름</td>
<td>string</td>
</tr>
<tr>
<td>type</td>
<td>주소 타입</td>
<td>fib_addrtype</td>
</tr>
</tbody>
</table>
<p>모든 주소 타입들의 목록을 보려면 <code>nft describe fib_addrtype</code>.</p>
<h4 id="fib_1">fib 식 사용하기</h4>
<pre><code class="text"># 역경로 없는 패킷 버리기
filter prerouting fib saddr . iif oif missing drop
</code></pre>

<p>이 예에서 <code>saddr . iif</code>는 출발 주소와 입력 인터페이스를 가지고 라우팅 정보를 검색한다. oif는 그 라우팅 정보에서 출력 인터페이스 번호를 뽑아낸다. 그 출발 주소/입력 인터페이스 조합에 대한 라우트를 찾지 못했으면 출력 인터페이스 번호가 0이다. 입력 키 중 일부로 입력 인터페이스를 지정한 경우 출력 인터페이스 번호는 언제나 입력 인터페이스 번호와 같거나 0이다. <code>saddr oif</code>만 준 경우에는 oif가 아무 인터페이스 번호 또는 0일 수 있다.</p>
<pre><code class="text"># 인터페이스에 설정 안 된 주소를 향한 패킷 버리기
filter prerouting fib daddr . iif type != { local, broadcast, multicast } drop

# 특정 '블랙홀' 테이블(0xdead, 적절한 ip rule 필요)에서 검색 수행하기
filter prerouting meta mark set 0xdead fib daddr . mark type vmap { blackhole : drop, prohibit : jump prohibited, unreachable : drop }
</code></pre>

<h3 id="_32">라우팅 식</h3>
<pre>
<strong>rt</strong> [<strong>ip</strong> | <strong>ip6</strong>] {<strong>classid</strong> | <strong>nexthop</strong> | <strong>mtu</strong> | <strong>ipsec</strong>}
</pre>

<p>라우팅 식은 패킷에 연계된 라우팅 데이터를 가리킨다.</p>
<p>표 32: 라우팅 식 타입</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>classid</td>
<td>라우팅 realm</td>
<td>realm</td>
</tr>
<tr>
<td>nexthop</td>
<td>라우팅 nexthop</td>
<td>ipv4_addr/ipv6_addr</td>
</tr>
<tr>
<td>mtu</td>
<td>라우트의 TCP 최대 세그먼트 크기</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>ipsec</td>
<td>ipsec 터널 또는 트랜스포트를 통한 라우트</td>
<td>boolean</td>
</tr>
</tbody>
</table>
<p>표 33: 라우팅 식 한정 타입</p>
<table>
<thead>
<tr>
<th>타입</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>realm</td>
<td>라우팅 realm (32비트 수). 숫자로 또는 /etc/iproute2/rt_realms에 정의된 심볼 이름으로 지정 가능.</td>
</tr>
</tbody>
</table>
<h4 id="_33">라우팅 식 사용하기</h4>
<pre><code class="text"># IP 패밀리와 무관한 rt 식
filter output rt classid 10
filter output rt ipsec missing

# IP 패밀리에 의존적인 rt 식
ip filter output rt nexthop 192.168.0.1
ip6 filter output rt nexthop fd00::1
inet filter output rt ip nexthop 192.168.0.1
inet filter output rt ip6 nexthop fd00::1
</code></pre>

<h3 id="ipsec">ipsec 식</h3>
<pre>
<strong>ipsec</strong> {<strong>in</strong> | <strong>out</strong>} [ <strong>spnum</strong> <em>NUM</em> ] {<strong>reqid</strong> | <strong>spi</strong>}
<strong>ipsec</strong> {<strong>in</strong> | <strong>out</strong>} [ <strong>spnum</strong> <em>NUM</em> ] {<strong>ip</strong> | <strong>ip6</strong>} {<strong>saddr</strong> | <strong>daddr</strong>}
</pre>

<p>ipsec 식은 패킷에 연계된 ipsec 데이터를 가리킨다.</p>
<p>식에서 입력 또는 출력 방향 정책을 검사해야 하는 경우 <code>in</code> 또는 <code>out</code> 키워드를 써서 방향을 지정해야 한다. <code>in</code> 키워드는 prerouting, input, forward 훅에서 쓸 수 있다. <code>out</code> 키워드는 forward, output, postrouting 훅에 해당한다. 선택적인 spnum 키워드를 써서 체인 내의 특정 상태에 맞춰 볼 수 있으며 기본은 0이다.</p>
<p>표 34: ipsec 식 타입</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>reqid</td>
<td>요청 ID</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>spi</td>
<td>보안 매개변수 색인</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>saddr</td>
<td>터널의 출발 주소</td>
<td>ipv4_addr/ipv6_addr</td>
</tr>
<tr>
<td>daddr</td>
<td>터널의 목적 주소</td>
<td>ipv4_addr/ipv6_addr</td>
</tr>
</tbody>
</table>
<h3 id="numgen">numgen 식</h3>
<pre>
<strong>numgen</strong> {<strong>inc</strong> | <strong>random</strong>} <strong>mod</strong> <em>NUM</em> [ <strong>offset</strong> <em>NUM</em> ]
</pre>

<p>수 생성기를 만든다. <code>inc</code> 및 <code>random</code> 키워드가 동작 방식을 결정한다. <code>inc</code> 방식에서는 마지막 반환 값을 증가시킬 뿐이다. <code>random</code> 방식에선 새 난수를 반환한다. <code>mod</code> 키워드 뒤의 값은 반환되는 수가 도달할 수 없는 상한을 (모듈로 연산) 지정한다. 선택적인 <code>offset</code>를 통해 반환 값을 고정된 간격만큼 증가시킬 수 있다.</p>
<p><code>numgen</code>의 일반적인 용도는 부하 분산이다.</p>
<h4 id="numgen_1">numgen 식 사용하기</h4>
<pre><code class="text"># 192.168.10.100과 192.168.20.200 중 하나로 라운드 로빈:
add rule nat prerouting dnat to numgen inc mod 2 map \
        { 0 : 192.168.10.100, 1 : 192.168.20.200 }

# 구간을 이용해 불균일하게 확률 기반 분산:
add rule nat prerouting dnat to numgen random mod 10 map \
        { 0-2 : 192.168.10.100, 3-9 : 192.168.20.200 }
</code></pre>

<h2 id="_34">페이로드 식</h2>
<p>페이로드 식은 패킷 페이코드에서 온 데이터를 가리킨다.</p>
<h3 id="_35">이더넷 헤더 식</h3>
<pre>
<strong>ether</strong> {<strong>daddr</strong> | <strong>saddr</strong> | <strong>type</strong>}
</pre>

<p>표 35: 이더넷 헤더 식 타입</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>daddr</td>
<td>목적 MAC 주소</td>
<td>ether_addr</td>
</tr>
<tr>
<td>saddr</td>
<td>출발 MAC 주소</td>
<td>ether_addr</td>
</tr>
<tr>
<td>type</td>
<td>EtherType</td>
<td>ether_type</td>
</tr>
</tbody>
</table>
<h3 id="vlan">VLAN 헤더 식</h3>
<pre>
<strong>vlan</strong> {<strong>id</strong> | <strong>cfi</strong> | <strong>pcp</strong> | <strong>type</strong>}
</pre>

<p>표 36: VLAN 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>VLAN ID (VID)</td>
<td>integer (12비트)</td>
</tr>
<tr>
<td>cfi</td>
<td>Canonical Format Indicator</td>
<td>integer (1비트)</td>
</tr>
<tr>
<td>pcp</td>
<td>Priority Code Point</td>
<td>integer (3비트)</td>
</tr>
<tr>
<td>type</td>
<td>EtherType</td>
<td>ether_type</td>
</tr>
</tbody>
</table>
<h3 id="arp_1">ARP 헤더 식</h3>
<pre>
<strong>arp</strong> {<strong>htype</strong> | <strong>ptype</strong> | <strong>hlen</strong> | <strong>plen</strong> | <strong>operation</strong> | <strong>saddr</strong> { <strong>ip</strong> | <strong>ether</strong> } | <strong>daddr</strong> { <strong>ip</strong> | <strong>ether</strong> }}
</pre>

<p>표 37: ARP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>htype</td>
<td>ARP 하드웨어 타입</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>ptype</td>
<td>EtherType</td>
<td>ether_type</td>
</tr>
<tr>
<td>hlen</td>
<td>하드웨어 주소 길이</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>plen</td>
<td>프로토콜 주소 길이</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>operation</td>
<td>동작</td>
<td>arp_op</td>
</tr>
<tr>
<td>saddr ether</td>
<td>이더넷 송신자 주소</td>
<td>ether_addr</td>
</tr>
<tr>
<td>daddr ether</td>
<td>이더넷 대상 주소</td>
<td>ether_addr</td>
</tr>
<tr>
<td>saddr ip</td>
<td>IPv4 송신자 주소</td>
<td>ipv4_addr</td>
</tr>
<tr>
<td>daddr ip</td>
<td>IPv4 대상 주소</td>
<td>ipv4_addr</td>
</tr>
</tbody>
</table>
<h3 id="ipv4_2">IPv4 헤더 식</h3>
<pre>
<strong>ip</strong> {<strong>version</strong> | <strong>hdrlength</strong> | <strong>dscp</strong> | <strong>ecn</strong> | <strong>length</strong> | <strong>id</strong> | <strong>frag-off</strong> | <strong>ttl</strong> | <strong>protocol</strong> | <strong>checksum</strong> | <strong>saddr</strong> | <strong>daddr</strong> }
</pre>

<p>표 38: IPv4 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>IP 헤더 버전 (4)</td>
<td>integer (4비트)</td>
</tr>
<tr>
<td>hdrlength</td>
<td>옵션 포함 IP 헤더 길이</td>
<td>integer (4비트) FIXME 단위</td>
</tr>
<tr>
<td>dscp</td>
<td>Differentiated Services Code Point</td>
<td>dscp</td>
</tr>
<tr>
<td>ecn</td>
<td>Explicit Congestion Notification</td>
<td>ecn</td>
</tr>
<tr>
<td>length</td>
<td>패킷 총 길이</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>id</td>
<td>IP ID</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>frag-off</td>
<td>단편 오프셋</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>ttl</td>
<td>Time to live</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>protocol</td>
<td>상위 계층 프로토콜</td>
<td>inet_proto</td>
</tr>
<tr>
<td>checksum</td>
<td>IP 헤더 체크섬</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>saddr</td>
<td>출발 주소</td>
<td>ipv4_addr</td>
</tr>
<tr>
<td>daddr</td>
<td>목적 주소</td>
<td>ipv4_addr</td>
</tr>
</tbody>
</table>
<h3 id="icmp_3">ICMP 헤더 식</h3>
<pre>
<strong>icmp</strong> {<strong>type</strong> | <strong>code</strong> | <strong>checksum</strong> | <strong>id</strong> | <strong>sequence</strong> | <strong>gateway</strong> | <strong>mtu</strong>}
</pre>

<p>표 39: ICMP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>ICMP type 필드</td>
<td>icmp_type</td>
</tr>
<tr>
<td>code</td>
<td>ICMP code 필드</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>checksum</td>
<td>ICMP checksum 필드</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>id</td>
<td>echo request/response의 ID</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>sequence</td>
<td>echo request/response의 일련 번호</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>gateway</td>
<td>redirect의 게이트웨이</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>mtu</td>
<td>경로 MTU 탐색의 MTU</td>
<td>integer (16비트)</td>
</tr>
</tbody>
</table>
<h3 id="igmp">IGMP 헤더 식</h3>
<pre>
<strong>igmp</strong> {<strong>type</strong> | <strong>mrt</strong> | <strong>checksum</strong> | <strong>group</strong>}
</pre>

<p>이 식은 IGMP 헤더 필드들을 가리킨다. <code>inet</code>, <code>bridge</code>, <code>netdev</code> 패밀리에서 쓸 때는 IPv4에 대한 암묵적 의존성이 생기게 된다. IPv6 상의 IGMP 같은 특이한 경우에 일치하게 하려면 규칙에 따로 <code>meta protocol ip6</code>를 추가해 줘야 한다.</p>
<p>표 40: ICMP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>IGMP type 필드</td>
<td>igmp_type</td>
</tr>
<tr>
<td>mrt</td>
<td>IGMP maximum response time 필드</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>checksum</td>
<td>IGMP checksum 필드</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>group</td>
<td>그룹 주소</td>
<td>integer (32비트)</td>
</tr>
</tbody>
</table>
<h3 id="ipv6_3">IPv6 헤더 식</h3>
<pre>
<strong>ip6</strong> {<strong>version</strong> | <strong>dscp</strong> | <strong>ecn</strong> | <strong>flowlabel</strong> | <strong>length</strong> | <strong>nexthdr</strong> | <strong>hoplimit</strong> | <strong>saddr</strong> | <strong>daddr</strong>}
</pre>

<p>이 식은 IPv6 헤더 필드들을 가리킨다. <code>ip6 nexthdr</code> 사용 시 조심해야 한다. 그 값은 다음 헤더를 가리킬 뿐이다. 즉 <code>ip6 nexthdr tcp</code>는 IPv6 패킷에 확장 헤더가 하나도 없는 경우에만 걸린다. 단편화 돼 있거나 가령 라우팅 확장 헤더를 담고 있는 패킷은 걸리지 않게 된다. 실제 전송 헤더를 확인하고 싶고 확장 헤더는 무시하고 싶다면 <code>meta l4proto</code>를 써 달라.</p>
<p>표 41: IPv6 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>IP 헤더 버전 (6)</td>
<td>integer (4비트)</td>
</tr>
<tr>
<td>dscp</td>
<td>Differentiated Services Code Point</td>
<td>dscp</td>
</tr>
<tr>
<td>ecn</td>
<td>Explicit Congestion Notification</td>
<td>ecn</td>
</tr>
<tr>
<td>flowlabel</td>
<td>Flow label</td>
<td>integer (20비트)</td>
</tr>
<tr>
<td>length</td>
<td>페이로드 길이</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>nexthdr</td>
<td>nexthdr 프로토콜</td>
<td>inet_proto</td>
</tr>
<tr>
<td>hoplimit</td>
<td>Hop limit</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>saddr</td>
<td>출발 주소</td>
<td>ipv6_addr</td>
</tr>
<tr>
<td>daddr</td>
<td>목적 주소</td>
<td>ipv6_addr</td>
</tr>
</tbody>
</table>
<h4 id="ip6">ip6 헤더 식 사용하기</h4>
<pre><code class="text"># 첫 번째 확장 헤더가 단편을 나타내면 일치
ip6 nexthdr ipv6-frag
</code></pre>

<h3 id="icmpv6_3">ICMPv6 헤더 식</h3>
<pre>
<strong>icmpv6</strong> {<strong>type</strong> | <strong>code</strong> | <strong>checksum</strong> | <strong>parameter-problem</strong> | <strong>packet-too-big</strong> | <strong>id</strong> | <strong>sequence</strong> | <strong>max-delay</strong>}
</pre>

<p>이 식은 ICMPv6 헤더 필드들을 가리킨다. <code>inet</code>, <code>bridge</code>, <code>netdev</code> 패밀리에서 쓸 때는 IPv6에 대한 암묵적 의존성이 생기게 된다. IPv4 상의 ICMPv6 같은 특이한 경우에 일치하게 하려면 규칙에 따로 <code>meta protocol ip</code>를 추가해 줘야 한다.</p>
<p>표 42: ICMPv6 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>ICMPv6 type 필드</td>
<td>icmpv6_type</td>
</tr>
<tr>
<td>code</td>
<td>ICMPv6 code 필드</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>checksum</td>
<td>ICMPv6 checksum 필드</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>parameter-problem</td>
<td>문제 포인터</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>packet-too-big</td>
<td>초과한 MTU</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>id</td>
<td>echo request/response의 ID</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>sequence</td>
<td>echo request/response의 일련 번호</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>max-delay</td>
<td>MLD 질의 응답 최대 지연</td>
<td>integer (16비트)</td>
</tr>
</tbody>
</table>
<h3 id="tcp">TCP 헤더 식</h3>
<pre>
<strong>tcp</strong> {<strong>sport</strong> | <strong>dport</strong> | <strong>sequence</strong> | <strong>ackseq</strong> | <strong>doff</strong> | <strong>reserved</strong> | <strong>flags</strong> | <strong>window</strong> | <strong>checksum</strong> | <strong>urgptr</strong>}
</pre>

<p>표 43: TCP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>sport</td>
<td>출발 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>dport</td>
<td>목적 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>sequence</td>
<td>일련 번호</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>ackseq</td>
<td>확인 번호</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>doff</td>
<td>데이터 오프셋</td>
<td>integer (4비트) FIXME 단위</td>
</tr>
<tr>
<td>reserved</td>
<td>예비 영역</td>
<td>integer (4비트)</td>
</tr>
<tr>
<td>flags</td>
<td>TCP 플래그</td>
<td>tcp_flag</td>
</tr>
<tr>
<td>window</td>
<td>윈도</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>checksum</td>
<td>체크섬</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>urgptr</td>
<td>긴급 포인터</td>
<td>integer (16비트)</td>
</tr>
</tbody>
</table>
<h3 id="udp">UDP 헤더 식</h3>
<pre>
<strong>udp</strong> {<strong>sport</strong> | <strong>dport</strong> | <strong>length</strong> | <strong>checksum</strong>}
</pre>

<p>표 44: UDP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>sport</td>
<td>출발 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>dport</td>
<td>목적 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>length</td>
<td>패킷 총 길이</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>checksum</td>
<td>체크섬</td>
<td>integer (16비트)</td>
</tr>
</tbody>
</table>
<h3 id="udp-lite">UDP-Lite 헤더 식</h3>
<pre>
<strong>udplite</strong> {<strong>sport</strong> | <strong>dport</strong> | <strong>checksum</strong>}
</pre>

<p>표 45: UDP-Lite 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>sport</td>
<td>출발 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>dport</td>
<td>목적 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>checksum</td>
<td>체크섬</td>
<td>integer (16비트)</td>
</tr>
</tbody>
</table>
<h3 id="sctp">SCTP 헤더 식</h3>
<pre>
<strong>sctp</strong> {<strong>sport</strong> | <strong>dport</strong> | <strong>vtag</strong> | <strong>checksum</strong>}
</pre>

<p>표 46: SCTP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>sport</td>
<td>출발 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>dport</td>
<td>목적 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>vtag</td>
<td>검증 태그</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>checksum</td>
<td>체크섬</td>
<td>integer (32비트)</td>
</tr>
</tbody>
</table>
<h3 id="dccp">DCCP 헤더 식</h3>
<pre>
<strong>dccp</strong> {<strong>sport</strong> | <strong>dport</strong>}
</pre>

<p>표 47: DCCP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>sport</td>
<td>출발 포트</td>
<td>inet_service</td>
</tr>
<tr>
<td>dport</td>
<td>목적 포트</td>
<td>inet_service</td>
</tr>
</tbody>
</table>
<h3 id="_36">인증 헤더 식</h3>
<pre>
<strong>ah</strong> {<strong>nexthdr</strong> | <strong>hdrlength</strong> | <strong>reserved</strong> | <strong>spi</strong> | <strong>sequence</strong>}
</pre>

<p>표 48: AH 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>nexthdr</td>
<td>다음 헤더 프로토콜</td>
<td>inet_proto</td>
</tr>
<tr>
<td>hdrlength</td>
<td>AH 헤더 길이</td>
<td>integer (8비트)</td>
</tr>
<tr>
<td>reserved</td>
<td>예비 영역</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>spi</td>
<td>보안 매개변수 색인</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>sequence</td>
<td>일련 번호</td>
<td>integer (32비트)</td>
</tr>
</tbody>
</table>
<h3 id="_37">보안 페이로드 캡슐화 헤더 식</h3>
<pre>
<strong>esp</strong> {<strong>spi</strong> | <strong>sequence</strong>}
</pre>

<p>표 49: ESP 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>spi</td>
<td>보안 매개변수 색인</td>
<td>integer (32비트)</td>
</tr>
<tr>
<td>sequence</td>
<td>일련 번호</td>
<td>integer (32비트)</td>
</tr>
</tbody>
</table>
<h3 id="ipcomp">IPCOMP 헤더 식</h3>
<pre>
<strong>comp</strong> {<strong>nexthdr</strong> | <strong>flags</strong> | <strong>cpi</strong>}
</pre>

<p>표 50: IPComp 헤더 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>nexthdr</td>
<td>다음 헤더 프로토콜</td>
<td>inet_proto</td>
</tr>
<tr>
<td>flags</td>
<td>플래그</td>
<td>bitmask</td>
</tr>
<tr>
<td>cpi</td>
<td>압축 매개변수 색인</td>
<td>integer (16비트)</td>
</tr>
</tbody>
</table>
<h3 id="_38">비가공 페이로드 식</h3>
<pre>
<strong>@</strong><em>base</em><strong>,</strong><em>offset</em><strong>,</strong><em>length</em>
</pre>

<p>비가공 페이로드 식은 <em>offset</em> 번째 비트부터 <em>length</em> 개 비트를 읽어 온다. 0번째 비트는 제일 첫 비트를 가리킨다. C 프로그래밍 언어로는 최상위 비트, 즉 옥텟이라면 0x80에 해당한다. 아직 사람이 읽을 수 있는 템플릿 식이 없는 헤더에 맞춰 보는 데 유용하다. 참고로 nft에서 비가공 페이로드 식에 자동으로 의존 조건을 추가해 주지 않는다. 가령 프로토콜 번호 5인 전송 헤더의 프로토콜 필드에 맞춰 보고 싶다면 그 비가공 식 앞에 <code>meta l4proto 5</code>처럼 써서 다른 전송 헤더의 패킷들을 직접 제외해 줘야 한다.</p>
<p>표 51: 지원하는 페이로드 프로토콜 base</p>
<table>
<thead>
<tr>
<th>base</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>ll</td>
<td>링크 계층. 예를 들어 이더넷 헤더</td>
</tr>
<tr>
<td>nh</td>
<td>네트워크 헤더. 예를 들어 IPv4나 IPv6</td>
</tr>
<tr>
<td>th</td>
<td>전송 헤더. 예를 들어 TCP</td>
</tr>
</tbody>
</table>
<h4 id="udp-tcp">UDP와 TCP 모두의 목적 포트 확인하기</h4>
<pre><code class="text">inet filter input meta l4proto {tcp, udp} @th,16,16 { 53, 80 }
</code></pre>

<p>위를 다음처럼 쓸 수도 있다.</p>
<pre><code class="text">inet filter input meta l4proto {tcp,udp} th dport { 53, 80 }
</code></pre>

<p>더 편리하긴 하지만 비가공 식 표기와 마찬가지로 어떤 의존 조건도 만들거나 확인하지 않는다. 포트 개념이 있는 헤더 종류들로만 검사를 한정하는 건 사용자의 책임이다. 그렇게 해 주지 않으면 가령 ESP 패킷의 SPI 필드를 포트로 잘못 해석해서 식과 무관한 패킷이 잘못 걸리게 된다.</p>
<h4 id="arp_2">ARP 패킷 목적 프로토콜 주소가 지정 주소와 일치하면 대상 하드웨어 주소 다시 쓰기</h4>
<pre><code class="text">input meta iifname enp2s0 arp ptype 0x0800 arp htype 1 arp hlen 6 arp plen 4 @nh,192,32 0xc0a88f10 @nh,144,48 set 0x112233445566 accept
</code></pre>

<h3 id="_39">확장 헤더 식</h3>
<p>확장 헤더 식은 IPv6 확장 헤더, TCP 옵션, IPv4 옵션 같은 가변 크기 프로토콜 헤더의 데이터를 가리킨다.</p>
<p>nftables에서는 현재 IPv6 확장 헤더, TCP 옵션, IPv4 옵션 검사(찾기)를 지원한다.</p>
<pre>
<strong>hbh</strong> {<strong>nexthdr</strong> | <strong>hdrlength</strong>}
<strong>frag</strong> {<strong>nexthdr</strong> | <strong>frag-off</strong> | <strong>more-fragments</strong> | <strong>id</strong>}
<strong>rt</strong> {<strong>nexthdr</strong> | <strong>hdrlength</strong> | <strong>type</strong> | <strong>seg-left</strong>}
<strong>dst</strong> {<strong>nexthdr</strong> | <strong>hdrlength</strong>}
<strong>mh</strong> {<strong>nexthdr</strong> | <strong>hdrlength</strong> | <strong>checksum</strong> | <strong>type</strong>}
<strong>srh</strong> {<strong>flags</strong> | <strong>tag</strong> | <strong>sid</strong> | <strong>seg-left</strong>}
<strong>tcp option</strong> {<strong>eol</strong> | <strong>noop</strong> | <strong>maxseg</strong> | <strong>window</strong> | <strong>sack-permitted</strong> | <strong>sack</strong> | <strong>sack0</strong> | <strong>sack1</strong> | <strong>sack2</strong> | <strong>sack3</strong> | <strong>timestamp</strong>} <em>tcp_option_field</em>
<strong>ip option</strong> {<strong>lsrr</strong> | <strong>ra</strong> | <strong>rr</strong> | <strong>ssrr</strong>} <em>ip_option_field</em>
</pre>

<p>다음 문법은 식 오른편이 헤더 존재 여부만 확인하는 불리언 타입인 관계 식에서만 유효하다.</p>
<pre>
<strong>exthdr</strong> {<strong>hbh</strong> | <strong>frag</strong> | <strong>rt</strong> | <strong>dst</strong> | <strong>mh</strong>}
<strong>tcp option</strong> {<strong>eol</strong> | <strong>noop</strong> | <strong>maxseg</strong> | <strong>window</strong> | <strong>sack-permitted</strong> | <strong>sack</strong> | <strong>sack0</strong> | <strong>sack1</strong> | <strong>sack2</strong> | <strong>sack3</strong> | <strong>timestamp</strong>}
<strong>ip option</strong> {<strong>lsrr</strong> | <strong>ra</strong> | <strong>rr</strong> | <strong>ssrr</strong>}
</pre>

<p>표 52: IPv6 확장 헤더</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>hbh</td>
<td>Hop by Hop</td>
</tr>
<tr>
<td>rt</td>
<td>Routing Header</td>
</tr>
<tr>
<td>frag</td>
<td>Fragmentation Header</td>
</tr>
<tr>
<td>dst</td>
<td>dst 옵션</td>
</tr>
<tr>
<td>mh</td>
<td>Mobility Header</td>
</tr>
<tr>
<td>srh</td>
<td>Segment Routing Header</td>
</tr>
</tbody>
</table>
<p>표 53: TCP 옵션</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>TCP 옵션 필드</th>
</tr>
</thead>
<tbody>
<tr>
<td>eol</td>
<td>옵션 목록 끝</td>
<td>kind</td>
</tr>
<tr>
<td>noop</td>
<td>1 바이트 TCP no-op 옵션</td>
<td>kind</td>
</tr>
<tr>
<td>maxseg</td>
<td>TCP 세그먼트 최대 크기</td>
<td>kind, length, size</td>
</tr>
<tr>
<td>window</td>
<td>TCP 윈도 스케일링</td>
<td>kind, length, count</td>
</tr>
<tr>
<td>sack-permitted</td>
<td>TCP SACK 허용</td>
<td>kind, length</td>
</tr>
<tr>
<td>sack</td>
<td>TCP 선택적 확인 (0번 블록 별칭)</td>
<td>kind, length, left, right</td>
</tr>
<tr>
<td>sack0</td>
<td>TCP 선택적 확인 (0번 블록)</td>
<td>kind, length, left, right</td>
</tr>
<tr>
<td>sack1</td>
<td>TCP 선택적 확인 (1번 블록)</td>
<td>kind, length, left, right</td>
</tr>
<tr>
<td>sack2</td>
<td>TCP 선택적 확인 (2번 블록)</td>
<td>kind, length, left, right</td>
</tr>
<tr>
<td>sack3</td>
<td>TCP 선택적 확인 (3번 블록)</td>
<td>kind, length, left, right</td>
</tr>
<tr>
<td>timestamp</td>
<td>TCP 타임스탬프</td>
<td>kind, elngth, tsval, tsecr</td>
</tr>
</tbody>
</table>
<p>표 54: IP 옵션</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>IP 옵션 필드</th>
</tr>
</thead>
<tbody>
<tr>
<td>lsrr</td>
<td>Loose Source Route</td>
<td>type, length, ptr, addr</td>
</tr>
<tr>
<td>ra</td>
<td>Router Alert</td>
<td>type, length, value</td>
</tr>
<tr>
<td>rr</td>
<td>Record Route</td>
<td>type, length, ptr, addr</td>
</tr>
<tr>
<td>ssrr</td>
<td>Strict Source Route</td>
<td>type, length, ptr, addr</td>
</tr>
</tbody>
</table>
<h4 id="tcp_1">TCP 옵션 찾기</h4>
<pre><code class="text">filter input tcp option sack-permitted kind 1 counter
</code></pre>

<h4 id="ipv6-exthdr">IPv6 exthdr 확인하기</h4>
<pre><code class="text">ip6 filter input frag more-fragments 1 counter
</code></pre>

<h4 id="ip">IP 옵션 찾기</h4>
<pre><code class="text">filter input ip option lsrr exists counter
</code></pre>

<h3 id="conntrack_1">conntrack 식</h3>
<p>conntrack 식은 패킷과 연계된 연결 추적 항목의 메타 데이터를 가리킨다.</p>
<p>세 가지 conntrack 식이 있다. 어떤 conntrack 식에선 conntrack 키 앞에 흐름 방향이 필요하지만 다른 식은 방향과 무관할 수 있기 때문에 바로 쓸 수도 있다. <code>packets</code>, <code>bytes</code>, <code>avgpkt</code> 키워드는 방향과 함께 쓸 수도 있고 없이 쓸 수도 있다. 방향을 생략하면 original 방향과 reply 방향의 합을 내놓는다. <code>zone</code>도 마찬가진데, 방향을 주면 그 존 ID가 해당 방향에 결속돼 있는 경우에만 존이 일치한다.</p>
<pre>
<strong>ct</strong> {<strong>state</strong> | <strong>direction</strong> | <strong>status</strong> | <strong>mark</strong> | <strong>expiration</strong> | <strong>helper</strong> | <strong>label</strong>}
<strong>ct</strong> [<strong>original</strong> | <strong>reply</strong>] {<strong>l3proto</strong> | <strong>protocol</strong> | <strong>bytes</strong> | <strong>packets</strong> | <strong>avgpkt</strong> | <strong>zone</strong>}
<strong>ct</strong> {<strong>original</strong> | <strong>reply</strong>} {<strong>proto-src</strong> | <strong>proto-dst</strong>}
<strong>ct</strong> {<strong>original</strong> | <strong>reply</strong>} {<strong>ip</strong> | <strong>ip6</strong>} {<strong>saddr</strong> | <strong>daddr</strong>}
</pre>

<p>표 55: conntrack 식</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody>
<tr>
<td>state</td>
<td>연결의 상태</td>
<td>ct_state</td>
</tr>
<tr>
<td>direction</td>
<td>연결 기준 패킷 방향</td>
<td>ct_dir</td>
</tr>
<tr>
<td>status</td>
<td>연결의 상황</td>
<td>ct_status</td>
</tr>
<tr>
<td>mark</td>
<td>연결 마크</td>
<td>mark</td>
</tr>
<tr>
<td>expiration</td>
<td>연결 만료 시간</td>
<td>time</td>
</tr>
<tr>
<td>helper</td>
<td>연결에 연계된 헬퍼</td>
<td>string</td>
</tr>
<tr>
<td>label</td>
<td>연결 추적 레이블 비트 또는 nftables include 경로의 connlabel.conf에 정의된 심볼 이름</td>
<td>ct_label</td>
</tr>
<tr>
<td>l3proto</td>
<td>연결의 제3계층 프로토콜</td>
<td>nf_proto</td>
</tr>
<tr>
<td>saddr</td>
<td>해당 방향의 연결의 출발 주소</td>
<td>ipv4_addr/ipv6_addr</td>
</tr>
<tr>
<td>daddr</td>
<td>해당 방향의 연결의 목적 주소</td>
<td>ipv4_addr/ipv6_addr</td>
</tr>
<tr>
<td>protocol</td>
<td>해당 방향의 연결의 제4계층 프로토콜</td>
<td>inet_proto</td>
</tr>
<tr>
<td>proto-src</td>
<td>해당 방향의 제4계층 프로토콜 출발 주소</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>proto-dst</td>
<td>해당 방향의 제4계층 프로토콜 목적 주소</td>
<td>integer (16비트)</td>
</tr>
<tr>
<td>packets</td>
<td>해당 방향 또는 original과 reply 모두에서 지나간 패킷 수</td>
<td>integer (64비트)</td>
</tr>
<tr>
<td>bytes</td>
<td>지나간 바이트 수. <code>packets</code> 키워드 설명 참고</td>
<td>integer (64비트)</td>
</tr>
<tr>
<td>avgpkt</td>
<td>패킷당 평균 바이트. <code>packets</code> 키워드 설명 참고</td>
<td>integer (64비트)</td>
</tr>
<tr>
<td>zone</td>
<td>conntrack 존</td>
<td>integer (16비트)</td>
</tr>
</tbody>
</table>
<p>위에 나열된 conntrack 한정 타입들에 대한 설명을 위의 conntrack 타입 절에서 볼 수 있다.</p>
<h4 id="_40">서버로 동시에 향하는 연결 수 제한하기</h4>
<pre><code class="text">filter input tcp dport 22 meter test { ip saddr ct count over 2 } reject
</code></pre>

<h2 id="_41">문</h2>
<h3 id="_42">판정 문</h3>
<h3 id="_43">페이로드 문</h3>
<h3 id="_44">확장 헤더 문</h3>
<h3 id="_45">로그 문</h3>
<h3 id="_46">거절 문</h3>
<h3 id="_47">카운터 문</h3>
<h3 id="conntrack_2">conntrack 문</h3>
<h3 id="meta_2">meta 문</h3>
<h3 id="_48">제한 문</h3>
<h3 id="nat">NAT 문</h3>
<h3 id="tproxy">TPROXY 문</h3>
<h3 id="synproxy">SYNPROXY 문</h3>
<h3 id="flow">flow 문</h3>
<h3 id="queue">queue 문</h3>
<h3 id="dup">dup 문</h3>
<h3 id="fwd">fwd 문</h3>
<h3 id="set">set 문</h3>
<h3 id="map">map 문</h3>
<h3 id="vmap">vmap 문</h3>
<h2 id="_49">추가 명령</h2>
<h3 id="monitor">monitor</h3>
<h2 id="_50">오류 보고</h2>
<h2 id="_51">종료 상태</h2>
<h2 id="see-also">SEE ALSO</h2>
<p><code>libnftables(3)</code>, <code>libnftables-json(5)</code>, <code>iptables(8)</code>, <code>ip6tables(8)</code>, <code>arptables(8)</code>, <code>ebtables(8)</code>, <code>ip(8)</code>, <code>tc(8)</code></p>
<p>공식 위키: <a href="https://wiki.nftables.org">https://wiki.nftables.org</a></p>
<h2 id="authors">AUTHORS</h2>
<p>Patrick McHardy와 Pablo Neira Ayuso가 Netfilter 커뮤니티의 여러 다른 공헌자들과 함께 nftables를 작성했다.</p>
<h2 id="copyright">COPYRIGHT</h2>
<p>Copyright © 2008-2014 Patrick McHardy <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#107;&#97;&#98;&#101;&#114;&#64;&#116;&#114;&#97;&#115;&#104;&#46;&#110;&#101;&#116;">&#107;&#97;&#98;&#101;&#114;&#64;&#116;&#114;&#97;&#115;&#104;&#46;&#110;&#101;&#116;</a> Copyright © 2013-2018 Pablo Neira Ayuso <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#112;&#97;&#98;&#108;&#111;&#64;&#110;&#101;&#116;&#102;&#105;&#108;&#116;&#101;&#114;&#46;&#111;&#114;&#103;">&#112;&#97;&#98;&#108;&#111;&#64;&#110;&#101;&#116;&#102;&#105;&#108;&#116;&#101;&#114;&#46;&#111;&#114;&#103;</a></p>
<p>nftables is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License version 2 as published by the Free Software Foundation.</p>
<p>This documentation is licensed under the terms of the Creative Commons Attribution-ShareAlike 4.0 license, CC BY-SA 4.0 <a href="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</a>.</p>
<hr />
<p>12/06/2019 a8347553</p></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
