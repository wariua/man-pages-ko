## NAME

uselib - 공유 라이브러리 적재하기

## SYNOPSIS

```c
#include <unistd.h>

int uselib(const char *library);
```

*주의*: glibc 헤더에 이 시스템 호출의 선언이 없다. NOTES 참고.

## DESCRIPTION

`uselib()` 시스템 호출은 호출 프로세스에서 사용할 공유 라이브러리를 적재해 준다. 경로명을 받는다. 적재할 주소는 라이브러리 자체에서 찾아낸다. 지원하는 어떤 바이너리 형식이든 적재할 수 있다.

## RETURN VALUE

성공 시 0을 반환한다. 오류 시 -1을 반환하며 오류를 나타내도록 `errno`를 설정한다.

## ERRORS

<tt>[[open(2)]]</tt>과 <tt>[[mmap(2)]]</tt>이 반환하는 모든 오류 코드에 더해서 다음을 반환할 수 있다.

`EACCES`
:   `library`로 지정한 라이브러리에 읽기 또는 실행 권한이 없다. 또는 경로 선두부의 한 디렉터리에 대해 호출자가 탐색 권한을 가지고 있지 않다. (<tt>[[path_solution(7)]]</tt>도 참고.)

`ENFILE`
:   열린 파일 총개수에 대한 시스템 전역 제한에 도달했다.

`ENOEXEC`
:   `library`로 지정한 파일이 알려진 종류의 실행 가능 파일이 아니다. 예를 들어 매직 번호가 올바르지 않다.

## CONFORMING TO

`uselib()`는 리눅스 전용이므로 이식성이 있어야 하는 프로그램에서는 사용하지 말아야 한다.

## NOTES

glibc에서 이 구식 시스템 호출을 지원하지 않는다. glibc 헤더에서 어떤 선언도 제공하지 않는다. 하지만 특이하게도 glibc 2.23 전 버전에선 이 시스템 호출에 대한 ABI를 내보였다. 그래서 이 시스템 호출을 이용하려면 코드에 직접 인터페이스를 선언해 주기만 하면 됐다. 또는 <tt>[[syscall(2)]]</tt>로 시스템 호출을 부를 수도 있었다.

고대의 (glibc 2.0 전의) libc 버전에서 `uselib()`를 사용해 바이너리의 이름 배열에 있는 이름들로 공유 라이브러리들을 적재했다.

리눅스 3.15부터는 `CONFIG_USELIB` 옵션을 써서 커널을 구성했을 때만 이 시스템 호출을 이용할 수 있다.

## SEE ALSO

`ar(1)`, `gcc(1)`, `ld(1)`, `ldd(1)`, <tt>[[mmap(2)]]</tt>, <tt>[[open(2)]]</tt>, <tt>[[dlopen(3)]]</tt>, <tt>[[capabilities(7)]]</tt>, <tt>[[ld.so(8)]]</tt>

----

2021-03-22
