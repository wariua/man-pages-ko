## NAME

time - 초 단위 시간 얻기

## SYNOPSIS

```c
#include <time.h>

time_t time(time_t *tloc);
```

## DESCRIPTION

`time()`은 에포크(Epoch), 즉 1970-01-01 00:00:00 +0000 (UTC) 이후의 초 수로 시간을 반환한다.

`tloc`이 NULL이 아니면 반환 값을 `tloc`이 가리키는 메모리에도 저장한다.

## RETURN VALUE

성공 시 에포크 이후 초 단위 시간 값을 반환한다. 오류 시 `((time_t) -1)`을 반환하며 오류를 나타내도록 `errno`를 설정한다.

## ERRORS

`EFAULT`
:   `tloc`이 접근 가능한 주소 공간 밖을 가리킨다. (하지만 BUGS 참고.)

    C 라이브러리의 `time()` 래퍼 함수가 <tt>[[vdso(7)]]</tt>에서 제공하는 구현체를 호출하는 (그래서 커널 내 트랩이 발생하지 않는) 시스템에서는 유효하지 않은 주소 사용 시 `SIGSEGV` 시그널이 유발될 수 있다.

## CONFORMING TO

SVr4, 4.3BSD, C89, C99, POSIX.1-2001. POSIX에서는 어떤 오류 조건도 명세하고 있지 않다.

## NOTES

POSIX.1에서는 *에포크 이후의 초 수*를 정의할 때 특정 시간과 에포크 사이 초 수를 근사적으로 계산하는 식을 쓴다. 이 식에서는 4로 나눠떨어지는 해가 윤년이면서 100으로 나눠떨어지는 해는 윤년이 아니고, 400으로 나눠떨어지는 해는 다시 윤년이라는 점을 참작한다. 하지만 이 값이 어떤 시간과 에포크 사이의 실제 초 수와 같지는 않은데, 윤초 때문이기도 하고 시스템 클럭이 꼭 어떤 표준 기준에 동기화돼 있지는 않을 수도 있기 때문이다. 어쨌든 그 의도는 에포크 이후 초 값이라는 것을 일관적으로 해석할 수 있게 하는 것이다. 다른 근거들은 POSIX.1-2008 Rationale A.4.15 참고.

리눅스에서 `tloc`을 NULL로 해서 `time()`을 호출하면 ABI에서 `time_t`가 부호 있는 32비트 정수이고 클럭이 2\*\*31 시점(2038-01-19 03:14:08 UTC, 윤초는 계산에서 제외)을 넘어가는 경우에도 `EOVERFLOW` 오류로 실패할 수 없다. (POSIX.1에서는 에포크 이후 초 수가 `time_t`에 들어가지 않는 경우에 `EOVERFLOW` 오류를 허용하되 요구하지는 않는다.) 시스템 시간이 `time_t` 범위 밖일 때 리눅스에서의 동작 방식은 규정돼 있지 않다. 2038년 후에도 동작해야 하는 응용에서는 `time_t`가 32비트보다 큰 ABI를 이용하는 게 좋다.

## BUGS

이 시스템 호출에서 오류를 반환하는 경우와 에포크에서 몇 초 *전* 시간에 성공 값을 알려 주는 경우를 구별할 수 없다. 따라서 C 라이브러리 래퍼 함수에서는 절대로 이 호출의 결과 값에 따라 `errno`를 설정하지 않는다.

`tloc` 인자는 구식이 됐으며 새로 작성하는 코드에서는 항상 NULL로 설정하는 게 좋다. `tloc`이 NULL일 때 이 호출은 실패할 수 없다.

### C 라이브러리/커널 차이

일부 아키텍처에서는 <tt>[[vdso(7)]]</tt>에서 `time()` 구현을 제공한다.

## SEE ALSO

`date(1)`, <tt>[[gettimeofday(2)]]</tt>, <tt>[[ctime(3)]]</tt>, <tt>[[ftime(3)]]</tt>, <tt>[[time(7)]]</tt>, <tt>[[vdso(7)]]</tt>

----

2021-03-22
