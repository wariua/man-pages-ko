## NAME

strptime - 시간 문자열 표현을 시간 tm 구조체로 변환하기

## SYNOPSIS

```c
#define _XOPEN_SOURCE       /* feature_test_macros(7) 참고 */
#include <time.h>

char *strptime(const char *restrict s, const char *restrict format,
               struct tm *restrict tm);
```

## DESCRIPTION

`strptime()` 함수는 <tt>[[strftime(3)]]</tt>의 반대이다. 즉 `s`가 가리키는 문자열을 `format`에 지정된 서식을 써서 `tm`이 가리키는 "분할 시간" 구조체에 저장된 값들로 변환한다.

분할 시간 구조체 `tm`은 `<time.h>`에 다음처럼 정의돼 있다.

```c
struct tm {
    int tm_sec;    /* 초 (0-60) */
    int tm_min;    /* 분 (0-59) */
    int tm_hour;   /* 시간 (0-23) */
    int tm_mday;   /* 월 중 날 번호 (1-31) */
    int tm_mon;    /* 월 (0-11) */
    int tm_year;   /* 년 - 1900 */
    int tm_wday;   /* 주 중 날 번호 (0-6, 일요일 = 0) */
    int tm_yday;   /* 연 중 날 번호 (0-365, 1월 1일 = 0) */
    int tm_isdst;  /* 일광 절약 시간 */
};
```

`tm` 구조체에 대한 더 자세한 내용은 <tt>[[ctime(3)]]</tt>을 보라.

`format` 인자는 <tt>[[scanf(3)]]</tt>를 연상시키는 필드 기술 항목과 텍스트 문자들로 이뤄진 문자열이다. 각 필드 기술 항목은 % 문자와 뒤이은 다른 문자 하나로 되어 있어서 그 필드 기술 항목이 무엇을 대신하는지 나타낸다. `format` 문자열의 다른 문자들은 모두 입력 문자열에 대응하는 문자가 있어야 한다. 단 예외적으로 공백 문자는 입력 문자열의 0개 이상의 공백 문자와 대응한다. 두 필드 기술 항목 사이에는 공백이나 다른 영자 또는 숫자 문자가 있어야 한다.

`strptime()` 함수는 왼쪽에서 오른쪽으로 입력 문자열을 처리해 나간다. 가능한 세 가지 입력 요소(공백, 리터럴, 서식) 각각을 하나씩 처리한다. 입력이 서식 문자열에 일치되지 않으면 함수 동작을 멈춘다. 서식 및 입력 문자열 나머지는 처리하지 않는다.

지원하는 입력 필드 기술 항목들이 아래 나열돼 있다. 텍스트 문자열(가령 요일 이름이나 월 이름)을 맞춰 보는 경우에는 대소문자 구분 없이 비교한다. 수를 맞춰 보는 경우에는 앞에 0이 오는 걸 허용하되 요구하지는 않는다.

| | |
| --- | --- |
| `%%` | % 문자. |
| `%a` 또는 `%A` | 현재 로캘에 따른 요일 이름. 축약 이름 또는 원래 이름. |
| `%b` 또는 `%B` 또는 `%h` | 현재 로캘에 따른 월 이름. 축약 이름 또는 원래 이름. |
| `%c` | 현재 로캘의 날짜 및 시간 표현. |
| `%C` | 세기 번호. (0-99) |
| `%d` 또는 `%e` | 월 중 날짜. (1-31) |
| `%D` | `%m/%d/%y`와 같음. (미국 방식 날짜로 미국인 아닌 이들에게 대단히 혼란스러운 방식이다. 유럽에서는 `%d/%m/%y`가 널리 쓰이기 때문에 특히 그렇다. ISO 8601 표준 형식은 `%Y-%m-%d`이다. |
| `%H` | 시간. (0-23) |
| `%I` | 12시간 시계의 시간. (1-12) |
| `%j` | 연 중 날짜. (1-366) |
| `%m` | 월 번호. (1-12) |
| `%M` | 분. (0-59) |
| `%n` | 임의 길이 공백. |
| `%p` | 로캘의 오전 오후 텍스트. (주의: 없을 수도 있음.) |
| `%r` | 12시간 시계의 시간. (로캘의 오전 오후 사용.) POSIX 로캘에서는 `%I:%M:%S %p`와 같다. 현재 로캘의 `LC_TIME`에서 `t_fmt_ampm`이 비어 있으면 동작 방식이 규정돼 있지 않다. |
| `%R` | `%H:%M`과 같음. |
| `%S` | 초. (0-60. 윤초 때문에 60이 가능. 이전에는 61도 허용했음.) |
| `%t` | 임의 길이 공백. |
| `%T` | `%H:%M:%S`와 같음. |
| `%U` | 일요일을 주의 첫째 날로 하는 주 번호. (0-53) 1월 첫 번째 일요일이 1번 주 첫날이다. |
| `%w` | 주 중 날 번호. (0-6) 일요일 = 0. |
| `%W` | 월요일을 주의 첫째 날로 하는 주 번호. (0-53) 1월 첫 번째 월요일이 1번 주 첫날이다. |
| `%x` | 날짜. 로캘의 날짜 형식 사용. |
| `%X` | 시간. 로캘의 시간 형식 사용. |
| `%y` | 세기 내 연도. (0-99) 세기를 따로 지정하지 않았을 때 69-99 범위의 값은 20세기의 연도(1969-1999)를 가리키고, 00-68 범위의 값은 21세기의 연도(2000-2068)를 가리킨다. |
| `%Y` | 세기 포함 연도. (예를 들어 1991) |

수식자 E 또는 O로 일부 필드 기술 항목들을 변경해서 대체 형식 내지 지정 방식을 써야 함을 나타낼 수 있다. 현재 로캘에 대체 형식 내지 지정 방식이 존재하지 않는 경우에는 변경 안 된 필드 기술 항목을 쓴다.

E 수식자는 입력 문자열에 날짜 및 시간을 위한 로캘별 대체 표현이 있을 수 있음을 나타낸다.

| | |
| --- | --- |
| `%Ec` | 로캘의 날짜 및 시간 대체 표현. |
| `%EC` | 로캘의 대체 표현으로 된 기준 연도(기간) 이름. |
| `%Ex` | 로캘의 날짜 대체 표현. |
| `%EX` | 로캘의 시간 대체 표현. |
| `%Ey` | 로캘의 대체 표현으로 된 `%EC`의 오프셋. (연도만) |
| `%EY` | 전체 연도 대체 표현. |

O 수식자는 숫자 입력이 로캘별 대체 형식일 수 있음을 나타낸다.

| | |
| --- | --- |
| `%Od` 또는 `%Oe` | 로캘의 대체 숫자 심볼을 이용한 월 중 날짜. 앞의 0을 허용하되 요구하지는 않는다. |
| `%OH` | 로캘의 대체 숫자 심볼을 이용한 (24시간 시계) 시간. |
| `%OI` | 로캘의 대체 숫자 심볼을 이용한 (12시간 시계) 시간. |
| `%Om` | 로캘의 대체 숫자 심볼을 이용한 월. |
| `%OM` | 로캘의 대체 숫자 심볼을 이용한 분. |
| `%OS` | 로캘의 대체 숫자 심볼을 이용한 초. |
| `%OU` | 로캘의 대체 숫자 심볼을 이용한 연 중 주 번호. (일요일이 주의 첫날) |
| `%Ow` | 로캘의 대체 숫자 심볼을 이용한 주 중 날 번호. (일요일=0) |
| `%OW` | 로캘의 대체 숫자 심볼을 이용한 연 중 주 번호. (월요일이 주의 첫날) |
| `%Oy` | 로캘의 대체 숫자 심볼을 이용한 연도. (`%C` 기준 오프셋) |

## RETURN VALUE

함수의 반환 값은 그 함수 호출에서 처리되지 않은 첫 문자에 대한 포인터이다. 입력 문자열이 서식 문자열에서 요구하는 것보다 많은 문자를 담고 있는 경우에는 마지막으로 소모한 입력 문자 바로 다음을 반환 값이 가리킨다. 입력 문자열 전체를 소모한 경우에는 문자열 끝의 널 바이트를 반환 값이 가리킨다. `strptime()`에서 서식 문자열 전체를 맞추는 데 실패하면, 즉 오류가 발생했으면 함수가 NULL을 반환한다.

## ATTRIBUTES

이 절에서 사용하는 용어들에 대한 설명은 <tt>[[attributes(7)]]</tt>를 보라.

| 인터페이스 | 속성 | 값 |
| --- | --- | --- |
| `strptime()` | 스레드 안전성 | MT-Safe env locale |

## CONFORMING TO

POSIX.1-2001, POSIX.1-2008, SUSv2.

## NOTES

원칙적으로 이 함수에서는 `tm`을 초기화 하지 않고 명시된 값들을 저장할 뿐이다. 이는 호출 전에 `tm`을 초기화 해야 한다는 뜻이다. 하지만 세부 사항은 유닉스 시스템들 간에 조금씩 다르다. glibc 구현에서는 명확히 지정돼 있지 않은 필드들을 건드리지 않는다. 단 연월일 요소들 중 하나라도 바뀌었으면 `tm_wday` 및 `tm_yday` 필드를 다시 계산한다.

'y'(세기 내 연도) 지정 항목을 glibc 2.0에선 1950-2049 범위의 연도를 나타내는 것으로 처리한다. glibc 2.1부터는 1969-2068 내 연도로 받는다.

### glibc 참고 사항

대칭성을 위해 glibc에서는 <tt>[[strftime(3)]]</tt>에서와 같은 서식 문자들을 `strptime()`에서 지원하려고 노력한다. (대부분의 경우 해당 필드를 파싱은 하되 `tm` 내 필드는 바꾸지 않는다.)

| | |
| --- | --- |
| `%F` | `%Y-%m-%d`와 같음. ISO 8601 날짜 형식. |
| `%g` | ISO 주 번호 방식에 부합하는 세기 없는 연도. (0-99) |
| `%G` | ISO 주 번호 방식에 부합하는 연도. (예를 들어 1991) |
| `%u` | 십진수로 된 주 중 날 번호. (1-7, 월요일 = 1) |
| `%V` | 십진수로 된 ISO 8601:1988 주 번호. (1-53) 1월 1일을 포함한 (월요일부터 시작하는) 주에서 4일 이상이 새해에 있으면 1번 주로 본다. 아니면 전년 마지막 주이고 그 다음 주가 1번 주가 된다. |
| `%z` | RFC-822/ISO 8601 표준 시간대 지정. |
| `%Z` | 시간대 이름. |

비슷하게 <tt>[[strftime(3)]]</tt>의 GNU 확장 때문에 `%H` 동의어로 `%k`를 받아들이고, `%I` 동의어로 `%l`을, `%p` 동의어로 `%P`를 받아들인다. 마지막으로 다음을 지원한다.

| | |
| --- | --- |
| `%s` | 에포크 1970-01-01 00:00:00 +0000 (UTC) 이후의 초 수. 윤초를 지원하지 않는 경우에는 윤초를 세지 않는다. |

glibc 구현에서는 두 필드 기술 항목 사이에 공백이 있기를 요구하지 않는다.

## EXAMPLES

다음 예는 `strptime()` 및 <tt>[[strftime(3)]]</tt> 사용 방식을 보여 준다.

```c
#define _XOPEN_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

int
main(void)
{
    struct tm tm;
    char buf[255];

    memset(&tm, 0, sizeof(tm));
    strptime("2001-11-12 18:31:01", "%Y-%m-%d %H:%M:%S", &tm);
    strftime(buf, sizeof(buf), "%d %b %Y %H:%M", &tm);
    puts(buf);
    exit(EXIT_SUCCESS);
}
```

## SEE ALSO

<tt>[[time(2)]]</tt>, <tt>[[getdate(3)]]</tt>, <tt>[[scanf(3)]]</tt>, <tt>[[setlocale(3)]]</tt>, <tt>[[strftime(3)]]</tt>

----

2021-03-22
