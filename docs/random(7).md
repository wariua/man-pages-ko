## NAME

random - 난수 획득 인터페이스 개요

## DESCRIPTION

커널 난수 생성기는 장치 드라이버 및 기타 환경 잡음 원천에서 수집한 엔트로피에 의존한다. 이 엔트로피를 암호학적으로 안전한 유사 난수 생성기(cryptographically secure pseudorandom number generator; CSPRNG)의 시드로 사용한다. 속도보다는 보안성을 목표로 설계되었다.

다음 인터페이스들을 통해 커널 CSPRNG로부터의 출력에 접근할 수 있다.

* `/dev/urandom` 및 `/dev/random` 장치. <tt>[[random(4)]]</tt>에서 그 둘을 기술한다. 이 장치들은 리눅스에 초기부터 있었으며 여러 다른 시스템들에도 사용 가능하다.

* 리눅스 전용 <tt>[[getrandom(2)]]</tt> 시스템 호출. 리눅스 3.17부터 사용 가능하다. 이 시스템 호출을 통해 `/dev/urandom`과 동일한 원천(이 페이지에서 `urandom` 원천)이나 `/dev/random`과 동일한 원천(이 페이지에서 `random` 원천)에 접근할 수 있다. 기본은 `urandom` 원천이다. `random` 원천은 시스템 호출에 `GRND_RANDOM` 플래그를 지정하여 선택한다. (<tt>[[getentropy(3)]]</tt> 함수는 <tt>[[getrandom(2)]]</tt> 위에서 좀 더 이식성 있는 인터페이스를 제공한다.)

### 엔트로피 풀 초기화

커널이 주변 환경으로부터 엔트로피 비트를 수집한다. 충분한 수의 난수 비트가 수집되었을 때 엔트로피 풀이 초기화 된 것으로 본다.

### 난수 원천 선택

장기 키 생성을 하려는 게 아니라면 (그리고 아마 그런 경우라 해도) `/dev/random` 장치를 읽어들이거나 <tt>[[getrandom(2)]]</tt>을 `GRND_RANDOM` 플래그로 사용하지 말아야 할 것이다. 대신 `/dev/urandom` 장치를 읽어들이거나 <tt>[[getrandom(2)]]</tt>을 `GRND_RANDOM` 플래그 없이 사용해야 한다. `urandom` 원천에서 쓰는 암호학적 알고리즘은 꽤 보수적이므로 어떤 용도에도 충분할 것이다.

`GRND_RANDOM` 및 `/dev/random` 읽기의 단점은 동작이 무한정 블록 될 수 있다는 점이다. 더불어 `GRND_RANDOM`을 사용하거나 `/dev/random`에서 읽어들일 때 발생할 수 있는 요청 불완전 처리를 다루는 것 때문에 코드 복잡도가 증가한다.

### 몬테카를로 및 기타 확률적 샘플링 응용

몬테카를로 시뮬레이션이나 기타 확률적 샘플링 수행 프로그램/알고리즘에 많은 양의 데이터를 제공하는 데 이 인터페이스를 사용하면 속도가 느릴 것이다. 게다가 그렇게 하는 것은 불필요하기도 한데, 그런 응용들에는 암호학적으로 안전한 난수가 필요하지 않기 때문이다. 대신 이 페이지에서 기술하는 인터페이스를 이용해 작은 양의 데이터를 얻어서 사용자 공간 유사 난수 생성기의 시드로 하고 그런 응용들에선 그 난수 생성기를 사용하게 하라.

### `getrandom`, `/dev/urandom`, `/dev/random` 비교

다음 표는 난수 획득에 사용할 수 있는 다양한 인터페이스의 동작 방식을 요약한 것이다. `GRND_NONBLOCK`은 <tt>[[getrandom(2)]]</tt>의 블로킹 동작 제어에 사용할 수 있는 플래그이다. 표의 마지막 열에서 다루는 경우는 엔트로피 풀이 아직 초기화 되어 있지 않은 초기 부팅 시점에 발생할 수 있다.

| 인터페이스 | 풀 | 블로킹 동작 | 풀이 아직 준비 안 되었을 때의 동작 |
| --- | --- | --- | --- |
| `/dev/random` | 블로킹 풀 | 엔트로피가 너무 낮으면 충분한 엔트로피가 있을 때까지 블록 | 충분한 엔트로피가 모일 때까지 블록 |
| `/dev/urandom` | CSPRNG 출력 | 절대 블록 하지 않음 | 초기화 안 된 CSPRNG의 출력 반환 (엔트로피가 낮을 수 있으므로 암호 연산에 부적합) |
| `getrandom()` | `/dev/urandom`과 동일 | 풀이 준비 상태가 되고 나면 블록 하지 않음 | 풀이 준비될 때까지 블록 |
| `getrandom()`<br>`GRND_RANDOM` | `/dev/random`과 동일 | 엔트로피가 너무 낮으면 충분한 엔트로피가 있을 때까지 블록 | 풀이 준비될 때까지 블록 |
| `getrandom()`<br>`GRND_NONBLOCK` | `/dev/urandom`과 동일 | 풀이 준비 상태가 되고 나면 블록 하지 않음 | `EAGAIN` |
| `getrandom()`<br>`GRND_RANDOM + GRND_NONBLOCK` | `/dev/random`과 동일 | 사용 가능 엔트로피가 충분치 않으면 `EAGAIN` | `EAGAIN` |

### 암호학적 키 생성

암호학적 키 생성에 필요한 시드 재료의 양은 키의 실효 키 크기와 같다. 예를 들어 3072비트 RSA 내지 디피헬만 개인키의 실효 키 크기는 128비트이다. (깨는 데 약 2^128번의 연산이 필요하다.) 따라서 키 생성자에게는 `/dev/random`에서 온 128비트(16바이트)의 시드 재료만 있으면 된다.

CSPRNG 알고리즘의 결함에 대비하기 위해 위의 최소치에 약간의 여유를 두는 것이 합리적이기는 하지만 오늘날 사용 가능한 어떤 암호학 요소도 256비트 넘는 보안성 제공을 약속하기를 기대하지 못한다. 따라서 어떤 프로그램에서 호출마다, 또는 적당한 (1분은 넘는) 시드 교환 주기마다 커널 난수 풀로부터 256비트(32바이트) 넘게 읽어들인다면 암호 기능을 숙련되게 구현하지 *않은* 신호로 보아야 할 것이다.

## SEE ALSO

<tt>[[getrandom(2)]]</tt>, <tt>[[getauxval(3)]]</tt>, <tt>[[getentropy(3)]]</tt>, <tt>[[random(4)]]</tt>, <tt>[[urandom(4)]]</tt>, <tt>[[signal(7)]]</tt>

----

2017-03-13
