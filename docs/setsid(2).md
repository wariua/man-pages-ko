## NAME

setsid - 세션 만들고 프로세스 그룹 ID 설정하기

## SYNOPSIS

```c
#include <unistd.h>

pid_t setsid(void);
```

## DESCRIPTION

`setsid()`는 호출 프로세스가 프로세스 그룹 리더가 아니면 새 세션을 만든다. 호출 프로세스가 새 세션의 리더가 된다. (즉, 세션 ID가 프로세스 ID와 같게 된다.) 또한 호출 프로세스가 세션의 새 프로세스 그룹의 프로세스 그룹 리더가 된다. (즉 프로세스 그룹 ID가 프로세스 ID와 같게 된다.)

호출 프로세스가 새 프로세스 그룹과 새 세션의 유일한 프로세스가 된다.

처음에는 새 세션에 제어 터미널이 없다. 세션의 제어 터미널을 얻는 방법에 대해선 <tt>[[credentials(7)]]</tt>를 보라.

## RETURN VALUE

성공 시 호출 프로세스의 (새로운) 세션 ID를 반환한다. 오류 시 `(pid_t) -1`을 반환하며 오류를 나타내도록 `errno`를 설정한다.

## ERRORS

`EPERM`
:   어느 프로세스의 프로세스 그룹 ID가 호출 프로세스의 PID와 같다. 그러므로 호출 프로세스가 이미 프로세스 그룹 리더이면 `setsid()`가 실패한다.

## CONFORMING TO

POSIX.1-2001, POSIX.1-2008, SVr4.

## NOTES

<tt>[[fork(2)]]</tt>를 통해 생성된 자식이 부모의 세션 ID를 물려받는다. <tt>[[execve(2)]]</tt>를 거치면서 세션 ID가 유지된다.

프로세스 그룹 리더는 프로세스 그룹 ID가 PID와 같은 프로세스다. 프로세스 그룹 리더의 `setsid()` 호출을 허용하지 않는 건 어떤 프로세스 그룹 리더가 새 세션으로 이동하면서 같은 프로세스 그룹의 다른 프로세스는 원래 세션에 남게 될 가능성을 막기 위해서다. 만약 그렇게 되면 세션과 프로세스 그룹의 엄격한 2단계 계층 구조가 깨지게 된다. `setsid()`가 꼭 성공하게 하려면 <tt>[[fork(2)]]</tt>를 호출하고서 부모는 <tt>[[_exit(2)]]</tt> 시키고 (정의상 프로세스 그룹 리더일 수 없는) 자식에서 `setsid()`를 호출하면 된다.

세션에 제어 터미널이 있는데 그 터미널에 `CLOCAL` 플래그가 설정돼 있지 않으면 터미널이 끊길 때 세션 리더에게 `SIGHUP` 시그널이 전송된다.

세션 리더인 프로세스가 종료하면 제어 터미널의 전경 프로세스 그룹의 각 프로세스로 `SIGHUP` 시그널이 전송된다.

## SEE ALSO

`setsid(1)`, <tt>[[getsid(2)]]</tt>, <tt>[[setpgid(2)]]</tt>, <tt>[[setpgrp(2)]]</tt>, <tt>[[tcgetsid(3)]]</tt>, <tt>[[credentials(7)]]</tt>, <tt>[[sched(7)]]</tt>

----

2021-03-22
