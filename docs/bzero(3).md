## NAME

bzero, explicit_bzero - 바이트 열을 0으로 채우기

## SYNOPSIS

```c
#include <strings.h>

void bzero(void *s, size_t n);

#include <string.h>

void explicit_bzero(void *s, size_t n);
```

## DESCRIPTION

`bzero()` 함수는 `s`가 가리키는 위치에서 시작하는 메모리 `n` 바이트에 0을 ('\0'을 담은 바이트들을) 기록해서 데이터를 지운다.

`explicit_bzero()` 함수는 `bzero()`와 같은 일을 수행한다. `bzero()`와 다른 점은 컴파일러에서 지우기 동작이 "불필요"하다고 추론한 경우에도 컴파일러 최적화가 그 동작을 제거하지 않도록 보장한다는 것이다.

## RETURN VALUE

없음.

## VERSIONS

glibc 2.25에서 `explicit_bzero()`가 처음 등장했다.

## ATTRIBUTES

이 절에서 사용하는 용어들에 대한 설명은 <tt>[[attributes(7)]]</tt>를 보라.

| 인터페이스 | 속성 | 값 |
| --- | --- | --- |
| `bzero()`, `explicit_bzero()` | 스레드 안전성 | MT-Safe |

## CONFORMING TO

`bzero()` 함수는 제거 예정이다. (POSIX.1-2001에서 LEGACY로 표시됨.) 새 프로그램에서는 `memset(3)`을 사용하라. POSIX.1-2008에서 `bzero()` 명세를 제거하였다. 4.3BSD에서 `bzero()` 함수가 처음 등장했다.

`explicit_bzero()` 함수는 BSD 계열 일부에도 있는 비표준 확장이다. 몇몇 다른 구현에는 `memset_explicit()`이나 `memset_s()` 같은 비슷한 함수가 있다.

## NOTES

`explicit_bzero()` 함수는 보안에 신경쓰는 응용에서 `bzero()` 사용 시 맞닥뜨릴 수 있는 문제를 해결하기 위한 것이다. 0으로 채운 위치를 *올바른* 프로그램에서 절대 다시 건드리지 않는다고 컴파일러에서 추론하면 `bzero()` 호출을 아예 없앨 수도 있다. 그런데 그 `bzero()` 호출의 의도가 민감한 데이터(가령 암호)를 지워서 잘못 동작하거나 탈취된 프로그램에 의해 데이터가 누출될 가능성을 막는 것이었다면 문제가 된다. `explicit_bzero()` 호출은 절대 컴파일러 최적화로 제거되지 않는다.

`explicit_bzero()` 함수가 민감한 데이터 지우기와 관련된 모든 문제를 해결해 주지는 않는다.

1. `explicit_bzero()` 함수는 민감한 데이터가 메모리에서 완전히 지워졌음을 보장하지 *않는다*. (`bzero()`도 마찬가지다.) 예를 들어 레지스터나 "작업용" 스택 영역에 민감한 데이터의 사본이 있을 수 있다. `explicit_bzero()` 함수에서는 그런 사본들에 대해 알지 못하므로 지울 수가 없다.

2. 어떤 상황에서는 `explicit_bzero()`가 보안성을 *떨어뜨릴* 수 있다. (데이터가 충분히 작으며 `explicit_bzero()` 호출 말고는 변수 주소를 받는 동작이 없어서) 민감한 데이터를 담은 변수를 레지스터에 저장하게 최적화할 수 있다고 컴파일러가 판단한 경우에는 `explicit_bzero()` 호출 시 레지스터에서 RAM의 어떤 위치로 데이터를 복사하고서 그걸 즉시 지우게 된다. (레지스터의 사본은 영향을 받지 않는다.) 여기서 문제는 RAM의 데이터가 레지스터의 데이터보다 버그에 노출될 가능성이 높고, 그래서 `explicit_bzero()` 호출이 만드는 작은 시간 틈새 동안에 민감한 데이터가 데이터 지우기 시도를 하지 않았을 경우보다 취약해진다는 점이다.

참고로 민감한 변수를 `volatile` 한정자로 선언해도 위 문제가 제거되지 *않는다*. 사실은 더 악화되는데, 예를 들어 레지스터에 저장하게 최적화할 수도 있었을 변수를 전체 수명 동안 (더 취약한) RAM에 유지하도록 만들 수 있기 때문이다.

위의 세부 내용들에도 불구하고 보안에 신경쓰는 응용에서는 일반적으로 `explicit_bzero()`를 쓰는 게 안 쓰는 것보다 낫다. `explicit_bzero()`의 개발자들은 미래의 컴파일러가 `explicit_bzero()` 호출을 인식해서 레지스터와 "작업용" 스택 영역의 사본을 포함해 민감한 데이터의 모든 사본들이 지워지도록 조치를 취할 것으로 기대한다.

## SEE ALSO

<tt>[[bstring(3)]]</tt>, `memset(3)`, <tt>[[swab(3)]]</tt>

----

2021-03-22
